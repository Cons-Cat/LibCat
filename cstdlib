// -*- mode: c++;-*-
#include "unistd.h"

/* +---+--------------------+
 * | r |    Register(s)     |
 * +---+--------------------+
 * | a |   %eax, %ax, %al   |
 * | b |   %ebx, %bx, %bl   |
 * | c |   %ecx, %cx, %cl   |
 * | d |   %edx, %dx, %dl   |
 * | S |   %esi, %si        |
 * | D |   %edi, %di        |
 * +---+--------------------+ */

/* Syscall calling convention
 * Param 	Register
 * 1st   	%rdi
 * 2nd  	%rsi
 * 3rd  	%rdx
 * 4th  	%rcx
 * 5th  	%r8
 * 6th  	%r9
 *
 * syscall number is %rax */

void _start() {  // NOLINT
    asm(R"(
# Define _start in symbol table:
.global _start
_start:

xor %rbp,%rbp # Zero out stack pointer.
pop %rdi # Set argc
movq %rsi,%rsp # Set argv
call main
movq %rdi,%rax # Get the return value of main().
movq $60,%rax # Mov 60 into rax for "exit" syscall.
syscall)"
        // : No outputs.
        // : No inputs.
        // : No clobbers.
    );
}

// TODO: Is a variadic syscall possible?

auto write(int file_descriptor, char const* p_string_buffer,
           size_t string_length) -> ssize_t {
    ssize_t rax;
    asm(R"(syscall)"
        // Return write-only rax value.
        : "=a"(rax)
        // D is %edi, which is for string operations.
        // S is for %rsi, which is the first argument in a syscall.
        // d is for %rdx, which is the second argument in a syscall.
        : "0"(1), "D"(file_descriptor), "S"(p_string_buffer), "d"(string_length)
        // MUTABLE CLOBBERS
        : "rcx", "r11", "memory");
    return rax;
}

// TODO: Overload write() with automatic string length.
