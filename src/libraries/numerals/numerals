// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

namespace cat {

namespace detail {
    template <typename T>
    concept CatNumeral = meta::is_cat_numeral<T>;

    template <typename T, typename U>
    consteval auto is_safe_conversion() -> bool {
        // clang-format off
    return (sizeof(T) >= sizeof(U))
		   && (meta::is_signed<T> == meta::is_signed<U>)
	       && (meta::is_floating_point<T> == meta::is_floating_point<U>);
        // clang-format on
    }

    template <CatNumeral T, typename U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingT = typename T::Type;
        // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(U))
		   && (meta::is_signed<UnderlyingT> == meta::is_signed<U>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<U>);
        // clang-format on
    }

    template <typename T, CatNumeral U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingU = typename U::Type;
        // clang-format off
    return (sizeof(T) >= sizeof(UnderlyingU))
		   && (meta::is_signed<T> == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<T>
               == meta::is_floating_point<UnderlyingU>);
        // clang-format on
    }

    template <CatNumeral T, CatNumeral U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingT = typename T::Type;
        using UnderlyingU = typename U::Type;
        // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(UnderlyingU))
		   && (meta::is_signed<UnderlyingT>
               == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<UnderlyingU>);
        // clang-format on
    }

    // `Numeral` is a container for numeric data types which prevents unsafe or
    // pessimizing implicit casts, such as loss of precision, change in
    // signed-ness, or `float4` to `float8` conversion.
    //
    // All of its conversion operators, arithmetic operators and constructors
    // are generic with constraints. Because these methods are constrained, it
    // is possible that the compiler will fail to resolve any satisfying
    // overloads for an invocation of an arithmetic operator, constructor, or
    // conversion operator, and thus prevent compilation.
    //
    // Constraints such as "the operand's size must be less than or equal to my
    // own size" guarantee that the an unwanted overload cannot be resolved.
    // This solution is concise, because any constraint broadly applies to all
    // possible type conversions.
    template <typename T>
    struct Numeral {
        // `Type` allows SIMD specializations to easily get the underlying
        // numeric data type of a `Numeral`.
        using Type = T;
        T storage;

        constexpr Numeral() = default;

        template <typename U>
        constexpr explicit(!is_safe_conversion<T, U>()) Numeral(U const from)
            : storage(static_cast<T const>(from)){};

        template <typename U>
        constexpr explicit operator U() {
            if constexpr (meta::IsSpecializationTrait<U, Numeral>::value) {
                // If `U` is a `Numeral`, cast into `U`'s underlying type.
                return static_cast<typename U::Type>(this->storage);
            } else {
                // If `U` is not a `Numeral`, cast into `U`.
                return static_cast<U>(this->storage);
            }
        }

        template <typename U>
        constexpr explicit operator U() const {
            if constexpr (meta::IsSpecializationTrait<U, Numeral>::value) {
                // If `U` is a `Numeral`, cast into `U`'s underlying type.
                return static_cast<typename U::Type>(this->storage);
            } else {
                // If `U` is not a `Numeral`, cast into `U`.
                return static_cast<U>(this->storage);
            }
        }

        // Get the underlying C API type.
        constexpr auto c() const -> T {
            return this->storage;
        }

        template <typename U>
        constexpr auto operator=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator>(U const from) const
            -> bool requires(is_safe_conversion<T, U>()) {
            return this->storage > static_cast<T const>(from);
        }

        template <typename U>
        constexpr auto operator>=(U const from) const
            -> bool requires(is_safe_conversion<T, U>()) {
            return this->storage >= static_cast<T const>(from);
        }

        template <typename U>
        constexpr auto operator<(U const from) const
            -> bool requires(is_safe_conversion<T, U>()) {
            return this->storage < static_cast<T const>(from);
        }

        template <typename U>
        constexpr auto operator<=(U const from) const
            -> bool requires(is_safe_conversion<T, U>()) {
            return this->storage <= static_cast<T const>(from);
        }

        template <typename U>
        constexpr auto operator+=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage + static_cast<T const>(from);
            return *this;
        }

        constexpr auto operator++() -> Numeral& {
            ++storage;
            return *this;
        }

        constexpr auto operator++(int) -> Numeral& {
            storage++;
            return *this;
        }

        template <typename U>
        constexpr auto operator-=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage - static_cast<T const>(from);
            return *this;
        }

        constexpr auto operator--() -> Numeral<T> {
            return --storage;
        }

        constexpr auto operator--(int) -> Numeral<T> {
            return storage--;
        }

        template <typename U>
        constexpr auto operator*=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage * static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator/(U const from) const -> Numeral<T>
        requires(is_safe_conversion<T, U>()) {
            return static_cast<T const>(this->storage /
                                        static_cast<T const>(from));
        }

        template <typename U>
        constexpr auto operator/=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage / static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator%(U const from) const -> Numeral<T>
        requires(is_safe_conversion<T, U>()) {
            return static_cast<T const>(this->storage %
                                        static_cast<T const>(from));
        }

        template <typename U>
        constexpr auto operator%=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage % static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator&=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage & static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator|=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage | static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator<<(U const from) const -> Numeral<T>
        requires(is_safe_conversion<T, U>()) {
            return static_cast<T const>(this->storage << static_cast<T>(from));
        }

        template <typename U>
        constexpr auto operator<<=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage << static_cast<T const>(from);
            return *this;
        }

        template <typename U>
        constexpr auto operator>>(U const from) const -> Numeral<T>
        requires(is_safe_conversion<T, U>()) {
            return static_cast<T const>(this->storage >> static_cast<T>(from));
        }

        template <typename U>
        constexpr auto operator>>=(U const from)
            -> Numeral& requires(is_safe_conversion<T, U>()) {
            this->storage = this->storage >> static_cast<T const>(from);
            return *this;
        }

        constexpr auto operator~() -> Numeral& {
            this->storage = ~(this->storage);
            return *this;
        }
    };

    template <typename T>
    Numeral(T) -> Numeral<T>;

    // Compare primitive numerals to `Numeral`s.
    // TODO: Return a `Numeral` that is the larger size of either operand.
    template <typename T, typename U>
    constexpr auto operator>(T const lhs, Numeral<U> const rhs)
        -> bool requires(meta::is_convertible<U, T> &&
                         !meta::IsSpecializationTrait<T, Numeral>::value) {
        return lhs > rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator>=(T const lhs, Numeral<U> const rhs)
        -> bool requires(meta::is_convertible<U, T> &&
                         !meta::IsSpecializationTrait<T, Numeral>::value) {
        return lhs >= rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator<(T const lhs, Numeral<U> const rhs)
        -> bool requires(meta::is_convertible<U, T> &&
                         !meta::IsSpecializationTrait<T, Numeral>::value) {
        return lhs < rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator<=(T const lhs, Numeral<U> const rhs)
        -> bool requires(meta::is_convertible<U, T> &&
                         !meta::IsSpecializationTrait<T, Numeral>::value) {
        return lhs <= rhs.storage;
    }

    // Order-independant operators for `Numeral` and primitive numerals.
    template <typename T, typename U>
    constexpr auto operator==(Numeral<T> const lhs, U const rhs)
        -> bool requires(meta::is_signed<T> == meta::is_signed<U> &&
                         meta::is_floating_point<T> ==
                             meta::is_floating_point<U>) {
        return lhs.storage == static_cast<T const>(rhs);
    }

    template <typename T, typename U>
    constexpr auto operator+(Numeral<T> const lhs, U const rhs) requires(
        meta::is_signed<T> == meta::is_signed<U> &&
        meta::is_floating_point<T> == meta::is_floating_point<U>) {
        return Numeral{lhs.storage + static_cast<T const>(rhs)};
    }

    template <typename T, typename U>
    constexpr auto operator-(Numeral<T> const lhs, U const rhs) requires(
        meta::is_signed<T> == meta::is_signed<U> &&
        meta::is_floating_point<T> == meta::is_floating_point<U>) {
        return Numeral{lhs.storage - static_cast<T const>(rhs)};
    }

    template <typename T, typename U>
    constexpr auto operator*(Numeral<T> const lhs, U const rhs) requires(
        meta::is_signed<T> == meta::is_signed<U> &&
        meta::is_floating_point<T> == meta::is_floating_point<U>) {
        return Numeral{lhs.storage * static_cast<T const>(rhs)};
    }

    template <typename T, typename U>
    constexpr auto operator&(Numeral<T> const lhs, U const rhs) requires(
        meta::is_signed<T> == meta::is_signed<U> &&
        meta::is_floating_point<T> == meta::is_floating_point<U>) {
        return Numeral{lhs.storage & static_cast<T const>(rhs)};
    }

    template <typename T, meta::Integral U>
    constexpr auto operator|(Numeral<T> const lhs, U const rhs) requires(
        meta::is_signed<T> == meta::is_signed<U> &&
        meta::is_floating_point<T> == meta::is_floating_point<U>) {
        return Numeral{lhs.storage | static_cast<T>(rhs)};
    }

    // Pointer arithmetic operators for `Numeral`s.
    template <typename T, typename U>
    constexpr auto operator+(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs + rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator+=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs += rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator-(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs - rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator-=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs -= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator*(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs * rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator*=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs *= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator/(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs / rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator/=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs /= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator<<(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs << rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator<<=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs <<= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator>>(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs >> rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator>>=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs >>= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator%(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs % rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator%=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs %= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator&(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs & rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator&=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs &= rhs.storage;
        return p_lhs;
    }

    template <typename T, typename U>
    constexpr auto operator|(T* const p_lhs, Numeral<U> const rhs) -> T* {
        return p_lhs | rhs.storage;
    }

    template <typename T, typename U>
    constexpr auto operator|=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
        p_lhs |= rhs.storage;
        return p_lhs;
    }
}  // namespace detail

// These macros are defined by the GCC compiler.
using int1 = cat::detail::Numeral<__INT8_TYPE__>;
using uint1 = cat::detail::Numeral<__UINT8_TYPE__>;
using int2 = cat::detail::Numeral<__INT16_TYPE__>;
using uint2 = cat::detail::Numeral<__UINT16_TYPE__>;
using int4 = cat::detail::Numeral<__INT32_TYPE__>;
using uint4 = cat::detail::Numeral<__UINT32_TYPE__>;
using int8 = cat::detail::Numeral<__INT64_TYPE__>;
using uint8 = cat::detail::Numeral<__UINT64_TYPE__>;
// using i128 = cat::detail::Numeral<int128_t>;
// using u128 = cat::detail::Numeral<uint128_t>;

using float4 = cat::detail::Numeral<float>;
using float8 = cat::detail::Numeral<double>;

// TODO: `__SIZE_TYPE__`.
using usize = uint8;
using ssize = int8;

using bool1 = bool;
static_assert(sizeof(bool1) == 1);

struct bool2 {  // NOLINT
    using Type = uint2;
    uint2 value;
    constexpr bool2() = default;
    constexpr bool2(bool1 const input) : value(input){};
    constexpr operator bool() const {
        return this->value != 0u;
    }
};

struct bool4 {  // NOLINT
    using Type = uint4;
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool1 const input) : value(input){};
    constexpr bool4(bool2 const input) : value(input){};
    constexpr operator bool() const {
        return this->value != 0u;
    }
};

namespace detail {
    template <typename T>
    concept NonPtrIntegral =
        meta::is_integral<T> && !meta::IsSpecializationTrait<T, intptr>::value;
}

// `intptr` can be constructed from any integer type or any pointer. It can only
// convert into `T*`, but it is otherwise interchangeable with integers. It
// satisfies the `meta::is_integral` type trait and `meta::Integral` concept.
template <typename T>
// NOLINTNEXTLINE
struct intptr {
    // `Type` is needed to convert into `cat::detail::Numeral`s.
    // This macro is a GCC builtin.
    using Type = __INTPTR_TYPE__;
    Type storage;

    constexpr intptr() = default;

    constexpr intptr(intptr<T> const&) = default;

    constexpr intptr(intptr<T>&& input) : storage(cat::move(input).storage){};

    constexpr intptr(detail::NonPtrIntegral auto const input)
        : storage(static_cast<Type>(input)){};

    constexpr intptr(T* const& p_input) {
        this->storage = reinterpret_cast<Type>(p_input);
    }

    constexpr operator T*() {
        return reinterpret_cast<T*>(this->storage);
    }

    constexpr operator T*() const {
        return reinterpret_cast<T* const>(this->storage);
    }

    constexpr auto operator=(intptr<T> const from) -> intptr<T>& {
        this->storage = from.storage;
        return *this;
    }

    constexpr auto operator=(intptr<T>&& from) -> intptr<T>& {
        this->storage = cat::move(from).storage;
        return *this;
    }

    constexpr auto operator=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>(intptr<U> const from) const -> bool1 {
        return this->storage > from.storage;
    }
    constexpr auto operator>(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage > static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator>=(intptr<U> const from) const -> bool1 {
        return this->storage >= from.storage;
    }
    constexpr auto operator>=(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage >= static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator<(intptr<U> const from) const -> bool1 {
        return this->storage < from.storage;
    }
    constexpr auto operator<(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage < static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator<=(intptr<U> const from) const -> bool1 {
        return this->storage <= from.storage;
    }
    constexpr auto operator<=(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage <= static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator+=(intptr<U> const from) -> intptr<T>& {
        this->storage += from.storage;
        return *this;
    }
    constexpr auto operator+=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage += static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator++() -> intptr<T> {
        return ++(this->storage);
    }

    constexpr auto operator++(int) -> intptr<T> {
        return (this->storage)++;
    }

    template <typename U>
    constexpr auto operator-=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage - static_cast<Type>(from);
        return *this;
    }
    constexpr auto operator-=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage - static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator--() -> intptr<T> {
        return --(this->storage);
    }

    constexpr auto operator--(int) -> intptr<T> {
        return (this->storage)--;
    }

    template <typename U>
    constexpr auto operator*=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage * static_cast<Type>(from);
        return *this;
    }
    constexpr auto operator*=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage * static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator/(intptr<U> const from) const -> intptr<T> {
        return this->storage / from.storage;
    }
    constexpr auto operator/(detail::NonPtrIntegral auto const from) const
        -> intptr<T> {
        return this->storage / static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator/=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage / from.storage;
        return *this;
    }
    constexpr auto operator/=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage / static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator%(intptr<U> const from) const -> intptr<T> {
        return this->storage % from.storage;
    }
    constexpr auto operator%(detail::NonPtrIntegral auto const from) const
        -> intptr<T> {
        return this->storage % static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator%=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage % from.storage;
        return *this;
    }
    constexpr auto operator%=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage % static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator&=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage & from.storage;
        return *this;
    }
    constexpr auto operator&=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage & static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator|(intptr<U> const from) const -> intptr<T> {
        return this->storage | from.storage;
    }
    constexpr auto operator|(detail::NonPtrIntegral auto const from) const
        -> intptr<T> {
        return this->storage | static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator|=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage | from.storage;
        return *this;
    }
    constexpr auto operator|=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage | static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator<<(intptr<U> const from) const -> intptr<T> {
        return this->storage << from.storage;
    }
    constexpr auto operator<<(detail::NonPtrIntegral auto const from) const
        -> intptr<T> {
        return this->storage << static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator<<=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage << from.storage;
        return *this;
    }
    constexpr auto operator<<=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage << static_cast<Type>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>>(intptr<U> const from) const -> intptr<T> {
        return this->storage >> from.storage;
    }
    constexpr auto operator>>(detail::NonPtrIntegral auto const from) const
        -> intptr<T> {
        return this->storage >> static_cast<Type>(from);
    }

    template <typename U>
    constexpr auto operator>>=(intptr<U> const from) -> intptr<T>& {
        this->storage = this->storage >> from.storage;
        return *this;
    }
    constexpr auto operator>>=(detail::NonPtrIntegral auto const from)
        -> intptr<T>& {
        this->storage = this->storage >> static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator~() -> intptr<T>& {
        this->storage = ~(this->storage);
        return *this;
    }
};

// Order-independant operators between an `intptr` and a pointer.
template <typename T>
constexpr auto operator==(intptr<T> const lhs, T* const p_rhs) -> bool {
    return lhs.storage == intptr<T>{p_rhs}.storage;
}

template <typename T>
constexpr auto operator+(intptr<T> const lhs, T* const p_rhs) -> intptr<T> {
    return lhs.storage + intptr<T>{p_rhs}.storage;
}

template <typename T>
constexpr auto operator-(intptr<T> const lhs, T* const p_rhs) -> intptr<T> {
    return lhs.storage - intptr<T>{p_rhs}.storage;
}

template <typename T>
constexpr auto operator*(intptr<T> const lhs, T* const p_rhs) -> intptr<T> {
    return lhs.storage * intptr<T>{p_rhs}.storage;
}

template <typename T>
constexpr auto operator&(intptr<T> const lhs, T* const p_rhs) -> intptr<T> {
    return lhs.storage & intptr<T>{p_rhs}.storage;
}

template <typename T>
constexpr auto operator|(intptr<T> const lhs, T* const p_rhs) -> intptr<T> {
    return lhs.storage | intptr<T>{p_rhs}.storage;
}

// Order-independant operators between an `intptr<T>` and an integer.
template <typename T>
constexpr auto operator==(intptr<T> const lhs,
                          detail::NonPtrIntegral auto const rhs) -> bool {
    return lhs.storage == rhs;
}

template <typename T>
constexpr auto operator+(intptr<T> const lhs,
                         detail::NonPtrIntegral auto const rhs) -> intptr<T> {
    return lhs.storage + intptr<T>{rhs}.storage;
}

template <typename T>
constexpr auto operator-(intptr<T> const lhs,
                         detail::NonPtrIntegral auto const rhs) -> intptr<T> {
    return lhs.storage - static_cast<typename intptr<T>::Type>(rhs);
}

template <typename T, typename U>
constexpr auto operator-(intptr<T> const lhs, intptr<U> const rhs)
    -> intptr<T> {
    return lhs.storage - rhs.storage;
}

template <typename T>
constexpr auto operator*(intptr<T> const lhs,
                         detail::NonPtrIntegral auto const rhs) -> intptr<T> {
    return lhs.storage * intptr<T>{rhs}.storage;
}

template <typename T>
constexpr auto operator&(intptr<T> const lhs,
                         detail::NonPtrIntegral auto const rhs) -> intptr<T> {
    return lhs.storage & intptr<T>{rhs}.storage;
}

template <typename T>
constexpr auto operator|(intptr<T> const lhs,
                         detail::NonPtrIntegral auto const rhs) -> intptr<T> {
    return lhs.storage | intptr<T>{rhs}.storage;
}

}  // namespace cat

using cat::bool1;
using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;
template <typename T>
using intptr = cat::intptr<T>;
