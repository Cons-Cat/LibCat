// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <meta>

namespace cat {

template <typename T>
struct NumericLimits;

namespace detail {
    template <typename T>
    concept CatNumeral = meta::is_cat_numeral<T>;

    template <typename T, typename U>
    consteval auto is_safe_conversion() -> bool {
        // clang-format off
    return (sizeof(T) >= sizeof(U))
		   && (meta::is_signed<T> == meta::is_signed<U>)
	       && (meta::is_floating_point<T> == meta::is_floating_point<U>);
        // clang-format on
    }

    template <CatNumeral T, typename U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingT = typename T::Type;
        // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(U))
		   && (meta::is_signed<UnderlyingT> == meta::is_signed<U>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<U>);
        // clang-format on
    }

    template <typename T, CatNumeral U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingU = typename U::Type;
        // clang-format off
    return (sizeof(T) >= sizeof(UnderlyingU))
		   && (meta::is_signed<T> == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<T>
               == meta::is_floating_point<UnderlyingU>);
        // clang-format on
    }

    template <CatNumeral T, CatNumeral U>
    consteval auto is_safe_conversion() -> bool {
        using UnderlyingT = typename T::Type;
        using UnderlyingU = typename U::Type;
        // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(UnderlyingU))
		   && (meta::is_signed<UnderlyingT>
               == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<UnderlyingU>);
        // clang-format on
    }
}  // namespace detail

// `Numeral` is a container for numeric data types which prevents unsafe or
// pessimizing implicit casts, such as loss of precision or signed-ness.
//
// All of its conversion operators, arithmetic operators and constructors
// are generic with constraints. Because these methods are constrained, it
// is possible that the compiler will fail to resolve any satisfying
// overloads for an invocation of an arithmetic operator, constructor, or
// conversion operator, and thus prevent compilation.
//
// Constraints such as "the operand's size must be less than or equal to my
// own size" guarantee that the an unwanted overload cannot be resolved.
// This solution is concise, because any constraint broadly applies to all
// possible type conversions.
template <typename T>
struct Numeral {
    // `Type` allows SIMD specializations to easily get the underlying
    // numeric data type of a `Numeral`.
    using Type = T;
    T storage;

    static constexpr Numeral<T> min = NumericLimits<Type>::min;
    static constexpr Numeral<T> max = NumericLimits<Type>::max;

    constexpr Numeral() = default;

    template <typename U>
    constexpr explicit(!detail::is_safe_conversion<T, U>())
        Numeral(U const from)
        : storage(static_cast<T const>(from)){};

    template <typename U>
    constexpr explicit operator U() {
        if constexpr (meta::IsSpecializationTrait<U, Numeral>::value) {
            // If `U` is a `Numeral`, cast into `U`'s underlying type.
            return static_cast<typename U::Type>(this->storage);
        } else {
            // If `U` is not a `Numeral`, cast into `U`.
            return static_cast<U>(this->storage);
        }
    }

    template <typename U>
    constexpr explicit operator U() const {
        if constexpr (meta::IsSpecializationTrait<U, Numeral>::value) {
            // If `U` is a `Numeral`, cast into `U`'s underlying type.
            return static_cast<typename U::Type>(this->storage);
        } else {
            // If `U` is not a `Numeral`, cast into `U`.
            return static_cast<U>(this->storage);
        }
    }

    // Get the underlying C API type.
    constexpr auto c() const -> T {
        return this->storage;
    }

    template <typename U>
    constexpr auto operator=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>(U const from) const
        -> bool requires(detail::is_safe_conversion<T, U>()) {
        return this->storage > static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator>=(U const from) const
        -> bool requires(detail::is_safe_conversion<T, U>()) {
        return this->storage >= static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator<(U const from) const
        -> bool requires(detail::is_safe_conversion<T, U>()) {
        return this->storage < static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator<=(U const from) const
        -> bool requires(detail::is_safe_conversion<T, U>()) {
        return this->storage <= static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator+=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage + static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator++() -> Numeral& {
        ++storage;
        return *this;
    }

    constexpr auto operator++(int) -> Numeral& {
        storage++;
        return *this;
    }

    template <typename U>
    constexpr auto operator-=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage - static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator--() -> Numeral<T> {
        return --storage;
    }

    constexpr auto operator--(int) -> Numeral<T> {
        return storage--;
    }

    template <typename U>
    constexpr auto operator*=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage * static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator/(U const from) const -> Numeral<T>
    requires(detail::is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage / static_cast<T const>(from));
    }

    template <typename U>
    constexpr auto operator/=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage / static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator%(U const from) const -> Numeral<T>
    requires(detail::is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage % static_cast<T const>(from));
    }

    template <typename U>
    constexpr auto operator%=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage % static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator&=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage & static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator|=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage | static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator<<(U const from) const -> Numeral<T>
    requires(detail::is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage << static_cast<T>(from));
    }

    template <typename U>
    constexpr auto operator<<=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage << static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>>(U const from) const -> Numeral<T>
    requires(detail::is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage >> static_cast<T>(from));
    }

    template <typename U>
    constexpr auto operator>>=(U const from)
        -> Numeral& requires(detail::is_safe_conversion<T, U>()) {
        this->storage = this->storage >> static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator~() -> Numeral& {
        this->storage = ~(this->storage);
        return *this;
    }
};

template <typename T>
Numeral(T) -> Numeral<T>;

// Compare primitive numerals to `Numeral`s.
// TODO: Return a `Numeral` that is the larger size of either operand.
template <typename T, typename U>
constexpr auto operator>(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs > rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>=(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs >= rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs < rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<=(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs <= rhs.storage;
}

// Order-independant operators for `Numeral` and primitive numerals.
template <typename T, typename U>
constexpr auto operator==(Numeral<T> const lhs, U const rhs)
    -> bool requires(meta::is_signed<T> == meta::is_signed<U> &&
                     meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return lhs.storage == static_cast<T const>(rhs);
}

template <typename T, typename U>
constexpr auto operator+(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage + static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator-(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage - static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator*(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage * static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator&(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage & static_cast<T const>(rhs)};
}

template <typename T, meta::Integral U>
constexpr auto operator|(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage | static_cast<T>(rhs)};
}

// Pointer arithmetic operators for `Numeral`s.
template <typename T, typename U>
constexpr auto operator+(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs + rhs.storage;
}

template <typename T, typename U>
constexpr auto operator+=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs += rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator-(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs - rhs.storage;
}

template <typename T, typename U>
constexpr auto operator-=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs -= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator*(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs * rhs.storage;
}

template <typename T, typename U>
constexpr auto operator*=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs *= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator/(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs / rhs.storage;
}

template <typename T, typename U>
constexpr auto operator/=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs /= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator<<(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs << rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<<=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs <<= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator>>(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs >> rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>>=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs >>= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator%(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs % rhs.storage;
}

template <typename T, typename U>
constexpr auto operator%=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs %= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator&(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs & rhs.storage;
}

template <typename T, typename U>
constexpr auto operator&=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs &= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator|(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs | rhs.storage;
}

template <typename T, typename U>
constexpr auto operator|=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs |= rhs.storage;
    return p_lhs;
}

// These macros are defined by the GCC compiler.
using int1 = cat::Numeral<__INT8_TYPE__>;
using uint1 = cat::Numeral<__UINT8_TYPE__>;
using int2 = cat::Numeral<__INT16_TYPE__>;
using uint2 = cat::Numeral<__UINT16_TYPE__>;
using int4 = cat::Numeral<__INT32_TYPE__>;
using uint4 = cat::Numeral<__UINT32_TYPE__>;
using int8 = cat::Numeral<__INT64_TYPE__>;
using uint8 = cat::Numeral<__UINT64_TYPE__>;
// using i128 = cat::Numeral<int128_t>;
// using u128 = cat::Numeral<uint128_t>;

using float4 = cat::Numeral<float>;
using float8 = cat::Numeral<double>;

// TODO: `__SIZE_TYPE__`.
using usize = uint8;
using ssize = int8;

using bool1 = bool;
static_assert(sizeof(bool1) == 1);

struct bool2 {  // NOLINT
    using Type = uint2;
    uint2 value;
    constexpr bool2() = default;
    constexpr bool2(bool1 const input) : value(input){};
    constexpr operator bool() const {
        return this->value != 0u;
    }
};

struct bool4 {  // NOLINT
    using Type = uint4;
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool1 const input) : value(input){};
    constexpr bool4(bool2 const input) : value(input){};
    constexpr operator bool() const {
        return this->value != 0u;
    }
};

namespace detail {
    // Satisfies any type that is an integer and is not `intptr` or `uintptr`.
    template <typename T>
    concept NonPtrIntegral = meta::is_integral<T> &&
        !meta::IsSpecializationTrait<T, ArithmeticPtr>::value;
}  // namespace detail

// `ArithmeticPtr` can be constructed from any integer type or any pointer. It
// can only convert into `T*`, but it is otherwise interchangeable with
// integers. It satisfies the `meta::is_integral` type trait and
// `meta::Integral` concept.
template <typename T, typename Storage>
struct ArithmeticPtr {
    Storage storage;
    // `Type` is required for the `NumeralLimits` trait.
    using Type = Storage;

    constexpr ArithmeticPtr() = default;

    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage> const&) = default;

    constexpr ArithmeticPtr(ArithmeticPtr<T, Storage>&& input)
        : storage(cat::move(input).storage){};

    constexpr ArithmeticPtr(detail::NonPtrIntegral auto const input)
        : storage(static_cast<Storage>(input)){};

    constexpr ArithmeticPtr(T* const& p_input) {
        this->storage = reinterpret_cast<Storage>(p_input);
    }

    constexpr auto c() const -> Storage {
        return this->storage;
    }

    constexpr operator T*() {
        return reinterpret_cast<T*>(this->storage);
    }

    constexpr operator T*() const {
        return reinterpret_cast<T* const>(this->storage);
    }

    constexpr auto operator=(ArithmeticPtr<T, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = from.storage;
        return *this;
    }

    constexpr auto operator=(ArithmeticPtr<T, Storage>&& from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = cat::move(from).storage;
        return *this;
    }

    constexpr auto operator=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>(ArithmeticPtr<U, Storage> const from) const
        -> bool1 {
        return this->storage > from.storage;
    }
    constexpr auto operator>(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage > static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator>=(ArithmeticPtr<U, Storage> const from) const
        -> bool1 {
        return this->storage >= from.storage;
    }
    constexpr auto operator>=(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage >= static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator<(ArithmeticPtr<U, Storage> const from) const
        -> bool1 {
        return this->storage < from.storage;
    }
    constexpr auto operator<(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage < static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator<=(ArithmeticPtr<U, Storage> const from) const
        -> bool1 {
        return this->storage <= from.storage;
    }
    constexpr auto operator<=(detail::NonPtrIntegral auto const from) const
        -> bool1 {
        return this->storage <= static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator+=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage += from.storage;
        return *this;
    }
    constexpr auto operator+=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage += static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator++() -> ArithmeticPtr<T, Storage> {
        return ++(this->storage);
    }

    constexpr auto operator++(int) -> ArithmeticPtr<T, Storage> {
        return (this->storage)++;
    }

    template <typename U>
    constexpr auto operator-=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage - static_cast<Storage>(from);
        return *this;
    }
    constexpr auto operator-=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage - static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator--() -> ArithmeticPtr<T, Storage> {
        return --(this->storage);
    }

    constexpr auto operator--(int) -> ArithmeticPtr<T, Storage> {
        return (this->storage)--;
    }

    template <typename U>
    constexpr auto operator*=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage * static_cast<Storage>(from);
        return *this;
    }
    constexpr auto operator*=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage * static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator/(ArithmeticPtr<U, Storage> const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage / from.storage;
    }
    constexpr auto operator/(detail::NonPtrIntegral auto const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage / static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator/=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage / from.storage;
        return *this;
    }
    constexpr auto operator/=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage / static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator%(ArithmeticPtr<U, Storage> const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage % from.storage;
    }
    constexpr auto operator%(detail::NonPtrIntegral auto const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage % static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator%=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage % from.storage;
        return *this;
    }
    constexpr auto operator%=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage % static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator&=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage & from.storage;
        return *this;
    }
    constexpr auto operator&=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage & static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator|(ArithmeticPtr<U, Storage> const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage | from.storage;
    }
    constexpr auto operator|(detail::NonPtrIntegral auto const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage | static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator|=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage | from.storage;
        return *this;
    }
    constexpr auto operator|=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage | static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator<<(ArithmeticPtr<U, Storage> const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage << from.storage;
    }
    constexpr auto operator<<(detail::NonPtrIntegral auto const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage << static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator<<=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage << from.storage;
        return *this;
    }
    constexpr auto operator<<=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage << static_cast<Storage>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>>(ArithmeticPtr<U, Storage> const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage >> from.storage;
    }
    constexpr auto operator>>(detail::NonPtrIntegral auto const from) const
        -> ArithmeticPtr<T, Storage> {
        return this->storage >> static_cast<Storage>(from);
    }

    template <typename U>
    constexpr auto operator>>=(ArithmeticPtr<U, Storage> const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage >> from.storage;
        return *this;
    }
    constexpr auto operator>>=(detail::NonPtrIntegral auto const from)
        -> ArithmeticPtr<T, Storage>& {
        this->storage = this->storage >> static_cast<Storage>(from);
        return *this;
    }

    constexpr auto operator~() -> ArithmeticPtr<T, Storage>& {
        this->storage = ~(this->storage);
        return *this;
    }
};

// Order-independant operators between an `ArithmeticPtr` and a pointer.
template <typename T, typename Storage>
constexpr auto operator==(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> bool {
    return lhs.storage == ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator+(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage + ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator-(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage - ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator*(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage * ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator&(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage & ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator|(ArithmeticPtr<T, Storage> const lhs, T* const p_rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage | ArithmeticPtr<T, Storage>{p_rhs}.storage;
}

// Order-independant operators between an `ArithmeticPtr<T>` and an integer.
template <typename T, typename Storage>
constexpr auto operator==(ArithmeticPtr<T, Storage> const lhs,
                          detail::NonPtrIntegral auto const rhs) -> bool {
    return lhs.storage == rhs;
}

template <typename T, typename Storage>
constexpr auto operator+(ArithmeticPtr<T, Storage> const lhs,
                         detail::NonPtrIntegral auto const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage + ArithmeticPtr<T, Storage>{rhs}.storage;
}

template <typename T, typename U, typename Storage>
constexpr auto operator+(ArithmeticPtr<T, Storage> const lhs,
                         ArithmeticPtr<U, Storage> const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage + rhs.storage;
}

template <typename T, typename Storage>
constexpr auto operator-(ArithmeticPtr<T, Storage> const lhs,
                         detail::NonPtrIntegral auto const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage - static_cast<Storage>(rhs);
}

template <typename T, typename U, typename Storage>
constexpr auto operator-(ArithmeticPtr<T, Storage> const lhs,
                         ArithmeticPtr<U, Storage> const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage - rhs.storage;
}

template <typename T, typename Storage>
constexpr auto operator*(ArithmeticPtr<T, Storage> const lhs,
                         detail::NonPtrIntegral auto const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage * ArithmeticPtr<T, Storage>{rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator&(ArithmeticPtr<T, Storage> const lhs,
                         detail::NonPtrIntegral auto const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage & ArithmeticPtr<T, Storage>{rhs}.storage;
}

template <typename T, typename Storage>
constexpr auto operator|(ArithmeticPtr<T, Storage> const lhs,
                         detail::NonPtrIntegral auto const rhs)
    -> ArithmeticPtr<T, Storage> {
    return lhs.storage | ArithmeticPtr<T, Storage>{rhs}.storage;
}

// `__INTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using intptr = cat::ArithmeticPtr<T, __INTPTR_TYPE__>;
// `__UINTPTR_TYPE__` is defined by the GCC compiler.
template <typename T>
using uintptr = cat::ArithmeticPtr<T, __UINTPTR_TYPE__>;

template <typename>
struct NumericLimits {};

template <typename T>
struct NumericLimits<Numeral<T>> {
    consteval NumericLimits() = delete;

    // Forward the underlying storage type to `.max`.
    constexpr static auto max = NumericLimits<T>::max;

    // Forward the underlying storage type to `.min`.
    constexpr static auto min = NumericLimits<T>::min;
};

template <>
struct NumericLimits<__INT8_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __INT8_TYPE__ max = 127;
    constexpr static __INT8_TYPE__ min = -128;
};

template <>
struct NumericLimits<__UINT8_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __UINT8_TYPE__ max = 255u;
    constexpr static __UINT8_TYPE__ min = 0u;
};

template <>
struct NumericLimits<__INT16_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __INT16_TYPE__ max = 32'767;
    constexpr static __INT16_TYPE__ min = -32'768;
};

template <>
struct NumericLimits<__UINT16_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __UINT16_TYPE__ max = 65535u;
    constexpr static __UINT16_TYPE__ min = 0u;
};

template <>
struct NumericLimits<__INT32_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __INT32_TYPE__ max = 2'147'483'647;
    constexpr static __INT32_TYPE__ min = -2'147'483'648;
};

template <>
struct NumericLimits<__UINT32_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __UINT32_TYPE__ max = 4'294'967'295;
    constexpr static __UINT32_TYPE__ min = 0u;
};

template <>
struct NumericLimits<__INT64_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __INT64_TYPE__ max = 9'223'372'036'854'775'807;
    constexpr static __INT64_TYPE__ min = -9'223'372'036'854'775'807;
};

template <>
struct NumericLimits<__UINT64_TYPE__> {
    consteval NumericLimits() = delete;
    constexpr static __UINT64_TYPE__ max = 18'446'744'073'709'551'615u;
    constexpr static __UINT64_TYPE__ min = 0u;
};

// TODO: `float` and `double` limits.
template <>
struct NumericLimits<float> {
    consteval NumericLimits() = delete;
    constexpr static float max = 0.f;
    constexpr static float min = 0.f;
};

template <>
struct NumericLimits<double> {
    consteval NumericLimits() = delete;
    constexpr static double max = 0.f;
    constexpr static double min = 0.f;
};

}  // namespace cat

using cat::bool1;
using cat::bool2;
using cat::bool4;
using cat::float4;
using cat::float8;
using cat::int1;
using cat::int2;
using cat::int4;
using cat::int8;
using cat::ssize;
using cat::uint1;
using cat::uint2;
using cat::uint4;
using cat::uint8;
using cat::usize;

template <typename T>
using intptr = cat::intptr<T>;
template <typename T>
using uintptr = cat::uintptr<T>;
