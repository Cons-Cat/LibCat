// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

/* Safe arithmetic does compile with no known issues. However, clangd 12 and 13
 * keel over after a single glance at this metaprogramming, so I am currently
 * hiding this behind a feature flag. It likely doesn't work anymore, because I
 * have been developing libCat mostly without safe arithmetic due to clangd. */
#ifdef SAFE_ARITHMETIC

namespace meta {

/* Get the value of a primitive number, or the value held by a
 * SafeNumeral<>. */
constexpr auto decay_numeral(int_or_float auto from) {
    return from;
}
constexpr auto decay_numeral(auto from) {
    return from.data;
}

}  // namespace meta

namespace cat::detail {

/* SafeNumeral<> is the most interesting part of <stdint.h>. libCat uses
 * this struct to represent all of its scalar numerical data types.
 * Operations between two specializations of a SafeNumeral<> that would
 * cause a narrowing conversion such as loss of precision, change in
 * signed-ness, or an implicit float to int conversion, *do not compile*, and
 * the code to ensure this is very simple compared to many other mechanisms.
 *
 * This works because all of its implicit conversion operators, arithmetic
 * operators, and constructors are generic with constraints. In other words,
 * these methods do not exist until they are actually called somewhere.
 *
 * At a method's call site, the compiler will attempt to find an overload of the
 * generic method that satisfies the inputs you provided. Because these methods
 * are constrained by concepts, it is possible that the compiler will fail to
 * find any satisfying overload, and thus not compile.
 *
 * So, we can provide constraints such as "the operand must have a size that is
 * less than or equal to my own size", and this will guarantee that the compiler
 * cannot generate a method that could cause a narrowing conversion between an
 * i8 and an i4 type. This solution is very concise because that same
 * constraint broadly applies to all possible type conversions. */

template <typename T>
struct SafeNumeral {
    // TODO: Rename to value
    T data;  // Uninitialized by default.

    constexpr SafeNumeral() = default;
    // Any number that is smaller than this can safely cast into it.
    constexpr SafeNumeral(auto from) requires(
        cat::is_signed_v<T> ==
            cat::is_signed_v<decltype(decay_numeral(from))> &&
        sizeof(T) >= sizeof(decltype(decay_numeral(from))) &&
        cat::is_floating_point_v<T> ==
            cat::is_floating_point_v<decltype(decay_numeral(from))>) {
        this->data = decay_numeral(from);
    }
    // TODO: Make a concept that limits signed-ness and size.
    constexpr operator cat::int_or_float auto() const {
        return this->data;
    };

        /* TODO: Putting concepts or constexpr functions in these requires
         * clauses doesn't work, for some reason. */
#define REQUIRES_HELPER                                                       \
    cat::is_signed_v<T> == cat::is_signed_v<decltype(decay_numeral(from))> && \
        sizeof(T) >= sizeof(decltype(decay_numeral(from))) &&                 \
        cat::is_floating_point_v<T> ==                                        \
            cat::is_floating_point_v<decltype(decay_numeral(from))>

    auto operator=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = decay_numeral(from);
        return *this;
    }
    auto operator==(auto from) -> bool requires(REQUIRES_HELPER) {
        return this->data == decay_numeral(from);
    }

    auto operator>(auto from) -> bool requires(REQUIRES_HELPER) {
        return this->data > decay_numeral(from);
    }
    auto operator>=(auto from) -> bool requires(REQUIRES_HELPER) {
        return this->data >= decay_numeral(from);
    }

    auto operator<(auto from) -> bool requires(REQUIRES_HELPER) {
        return this->data < decay_numeral(from);
    }
    auto operator<=(auto from) -> bool requires(REQUIRES_HELPER) {
        return this->data <= decay_numeral(from);
    }

    auto operator+(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data + decay_numeral(from);
    }
    auto operator+=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data + decay_numeral(from);
        return *this;
    }

    auto operator++() -> SafeNumeral<T> {
        return ++data;
    }
    auto operator++(int) -> SafeNumeral<T> {
        return data++;
    }

    auto operator-(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data - decay_numeral(from);
    }
    auto operator-=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this - from;
        return *this;
    }

    auto operator--() -> SafeNumeral<T> {
        return --data;
    }
    auto operator--(int) -> SafeNumeral<T> {
        return data--;
    }

    auto operator*(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data * decay_numeral(from);
    }
    auto operator*=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data * from.data;
        return *this;
    }

    auto operator/(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data / decay_numeral(from);
    }
    auto operator/=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data / from.data;
        return *this;
    }

    auto operator%(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data % decay_numeral(from);
    }
    auto operator%=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data % from.data;
        return *this;
    }

    auto operator&(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data & decay_numeral(from);
    }
    auto operator&=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data & from.data;
        return *this;
    }

    auto operator|(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data | decay_numeral(from);
    }
    auto operator|=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data | from.data;
        return *this;
    }

    auto operator<<(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data << decay_numeral(from);
    }
    auto operator<<=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data << from.data;
        return *this;
    }

    auto operator>>(auto from) -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return this->data >> decay_numeral(from);
    }
    auto operator>>=(auto from) -> SafeNumeral<T>& requires(REQUIRES_HELPER) {
        this->data = this->data >> from.data;
        return *this;
    }
};

}  // namespace cat::detail

// These macros are defined by the GCC compiler.
using int1 = cat::detail::SafeNumeral<__INT8_TYPE__>;
using uint1 = cat::detail::SafeNumeral<__UINT8_TYPE__>;
using int2 = cat::detail::SafeNumeral<__INT16_TYPE__>;
using uint2 = cat::detail::SafeNumeral<__UINT16_TYPE__>;
using int4 = cat::detail::SafeNumeral<__INT32_TYPE__>;
using uint4 = cat::detail::SafeNumeral<__UINT32_TYPE__>;
using int8 = cat::detail::SafeNumeral<__INT64_TYPE__>;
using uint8 = cat::detail::SafeNumeral<__UINT64_TYPE__>;
// using i128 = cat::detail::SafeNumeral<int128_t>;
// using u128 = cat::detail::SafeNumeral<uint128_t>;

// These are GCC built-in types:
using float4 = cat::detail::SafeNumeral<float>;
using float8 = cat::detail::SafeNumeral<double>;
#else

namespace meta {

constexpr auto decay_numeral(auto from) {
    return from;
}

}  // namespace meta

// TODO: Add and test 16-byte types and complex numbers.
// These macros are defined by the GCC compiler.
using int1 = __INT8_TYPE__;
using uint1 = __UINT8_TYPE__;
using int2 = __INT16_TYPE__;
using uint2 = __UINT16_TYPE__;
using int4 = __INT32_TYPE__;
using uint4 = __UINT32_TYPE__;
using int8 = __INT64_TYPE__;
using uint8 = __UINT64_TYPE__;
using float4 = float;
using float8 = double;
#endif

using usize = uint8;
// TODO: Solve circular dependency:
// using ssize = i8;

// TODO: Document `bool1`.
struct bool1 {  // NOLINT
    uint1 value;
    constexpr bool1() = default;
    constexpr bool1(bool const input) {
        this->value = static_cast<uint1>(input);
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool2 {  // NOLINT
    uint1 value;
    constexpr bool2() = default;
    constexpr bool2(bool const input) {
        this->value = static_cast<uint4>(input);
    }
    constexpr bool2(bool1 const input) {
        this->value = static_cast<uint4>(input);
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool4 {  // NOLINT
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool const input) {
        this->value = static_cast<uint4>(input);
    }
    constexpr bool4(bool1 const input) {
        this->value = static_cast<uint4>(input);
    }
    constexpr bool4(bool2 const input) {
        this->value = static_cast<uint4>(input);
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct intptr {  // NOLINT
    ssize value;

    constexpr intptr() = default;

    constexpr intptr(intptr const& input) {
        this->value = input.value;
    }

    constexpr intptr(intptr&& input) {
        this->value = cat::move(input).value;
    }

    constexpr intptr(meta::Integral auto const& input) {
        this->value = input;
    }

    template <meta::Integral T>
    constexpr intptr(T&& input) {  // NOLINT
        this->value = meta::forward<T>(input);
    }

    constexpr intptr(auto* p_input) {
        this->value = meta::bit_cast<ssize>(p_input);
    }

    template <meta::Integral T>
    constexpr operator T() {
        return static_cast<T>(this->value);
    }

    constexpr auto operator=(intptr const& from) -> intptr& = default;
    constexpr auto operator=(intptr&& from) -> intptr& = default;

    constexpr auto operator=(meta::Integral auto from) -> intptr& {
        this->value = static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator==(meta::Integral auto from) const -> bool1 {
        return this->value == static_cast<ssize>(from);
    }

    constexpr auto operator>(meta::Integral auto from) const -> bool1 {
        return this->value > static_cast<ssize>(from);
    }
    constexpr auto operator>=(meta::Integral auto from) -> bool1 {
        return this->value >= static_cast<ssize>(from);
    }

    constexpr auto operator<(meta::Integral auto from) const -> bool1 {
        return this->value < static_cast<ssize>(from);
    }
    constexpr auto operator<=(meta::Integral auto from) -> bool1 {
        return this->value <= static_cast<ssize>(from);
    }

    constexpr auto operator+(meta::Integral auto from) const -> intptr {
        return this->value + static_cast<ssize>(from);
    }
    constexpr auto operator+=(meta::Integral auto from) -> intptr& {
        this->value = this->value + static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator++() -> intptr {
        return ++this->value;
    }
    constexpr auto operator++(int) -> intptr {
        return this->value++;
    }

    constexpr auto operator-(meta::Integral auto from) const -> intptr {
        return this->value - static_cast<ssize>(from);
    }
    constexpr auto operator-=(meta::Integral auto from) -> intptr& {
        this->value = this->value - static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator--() -> intptr {
        return --value;
    }
    constexpr auto operator--(int) -> intptr {
        return value--;
    }

    constexpr auto operator*(meta::Integral auto from) const -> intptr {
        return this->value * static_cast<ssize>(from);
    }
    constexpr auto operator*=(meta::Integral auto from) -> intptr& {
        this->value = this->value * static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator/(meta::Integral auto from) const -> intptr {
        return this->value / static_cast<ssize>(from);
    }
    constexpr auto operator/=(meta::Integral auto from) -> intptr& {
        this->value = this->value / static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator%(meta::Integral auto from) const -> intptr {
        return this->value % static_cast<ssize>(from);
    }
    constexpr auto operator%=(meta::Integral auto from) -> intptr& {
        this->value = this->value % static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator&(meta::Integral auto from) const -> intptr {
        return this->value & static_cast<ssize>(from);
    }
    constexpr auto operator&=(meta::Integral auto from) -> intptr& {
        this->value = this->value & static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator|(meta::Integral auto from) const -> intptr {
        return this->value | static_cast<ssize>(from);
    }
    constexpr auto operator|=(meta::Integral auto from) -> intptr& {
        this->value = this->value | static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto from) const -> intptr {
        return this->value << static_cast<ssize>(from);
    }
    constexpr auto operator<<=(meta::Integral auto from) -> intptr& {
        this->value = this->value << static_cast<ssize>(from);
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto from) const -> intptr {
        return this->value >> static_cast<ssize>(from);
    }
    constexpr auto operator>>=(meta::Integral auto from) -> intptr& {
        this->value = this->value >> static_cast<ssize>(from);
        return *this;
    }

    template <typename T>
    constexpr operator T*() {
        return meta::bit_cast<T*>(this->value);
    }

    template <typename T>
    constexpr operator T*() const {
        return meta::bit_cast<T*>(this->value);
    }
};
