// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

template <typename T>
concept CatNumeral = meta::is_cat_numeral<T>;

namespace cat::detail {

template <typename T, typename U>
consteval auto is_safe_conversion() -> bool {
    // clang-format off
    return (sizeof(T) >= sizeof(U))
		   && (meta::is_signed<T> == meta::is_signed<U>)
	       && (meta::is_floating_point<T> == meta::is_floating_point<U>);
    // clang-format on
}

template <CatNumeral T, typename U>
consteval auto is_safe_conversion() -> bool {
    using UnderlyingT = typename T::Type;
    // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(U))
		   && (meta::is_signed<UnderlyingT> == meta::is_signed<U>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<U>);
    // clang-format on
}

template <typename T, CatNumeral U>
consteval auto is_safe_conversion() -> bool {
    using UnderlyingU = typename U::Type;
    // clang-format off
    return (sizeof(T) >= sizeof(UnderlyingU))
		   && (meta::is_signed<T> == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<T>
               == meta::is_floating_point<UnderlyingU>);
    // clang-format on
}

template <CatNumeral T, CatNumeral U>
consteval auto is_safe_conversion() -> bool {
    using UnderlyingT = typename T::Type;
    using UnderlyingU = typename U::Type;
    // clang-format off
    return (sizeof(UnderlyingT) >= sizeof(UnderlyingU))
		   && (meta::is_signed<UnderlyingT>
               == meta::is_signed<UnderlyingU>)
	       && (meta::is_floating_point<UnderlyingT>
               == meta::is_floating_point<UnderlyingU>);
    // clang-format on
}

// `Numeral` is a container for numeric data types which prevents unsafe or
// pessimizing implicit casts, such as loss of precision, change in
// signed-ness, or `float4` to `float8` conversion.
//
// All of its conversion operators, arithmetic operators and constructors are
// generic with constraints. Because these methods are constrained, it is
// possible that the compiler will fail to resolve any satisfying overloads for
// an invocation of an arithmetic operator, constructor, or conversion operator,
// and thus prevent compilation.
//
// Constraints such as "the operand's size must be less than or equal to my own
// size" guarantee that the an unwanted overload cannot be resolved. This
// solution is concise, because any constraint broadly applies to all possible
// type conversions.
template <typename T>
struct Numeral {
    // `Type` allows SIMD specializations to easily get the underlying numeric
    // data type of a `Numeral`.
    using Type = T;
    T storage;

    constexpr Numeral() = default;

    // constexpr Numeral(T value) : storage(value){};

    template <typename U>
    constexpr Numeral(U const from) requires(is_safe_conversion<T, U>())
        : storage(static_cast<T>(from)){};

    template <typename U>
    constexpr explicit operator U() const {
        if constexpr (meta::IsSpecializationTrait<U, Numeral>::value) {
            // If `U` is a `Numeral`, cast into `U`'s underlying type.
            return static_cast<typename U::Type>(this->storage);
        } else {
            // If `U` is not a `Numeral`, cast into `U`.
            return static_cast<U>(this->storage);
        }
    }

    // Get the underlying C API type.
    constexpr auto c() const -> T {
        return this->storage;
    }

    template <typename U>
    constexpr auto operator=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>(U const from) const
        -> bool requires(is_safe_conversion<T, U>()) {
        return this->storage > static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator>=(U const from) const
        -> bool requires(is_safe_conversion<T, U>()) {
        return this->storage >= static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator<(U const from) const
        -> bool requires(is_safe_conversion<T, U>()) {
        return this->storage < static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator<=(U const from) const
        -> bool requires(is_safe_conversion<T, U>()) {
        return this->storage <= static_cast<T const>(from);
    }

    template <typename U>
    constexpr auto operator+=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage + static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator++() -> Numeral& {
        ++storage;
        return *this;
    }

    constexpr auto operator++(int) -> Numeral& {
        storage++;
        return *this;
    }

    template <typename U>
    constexpr auto operator-=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage - static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator--() -> Numeral<T> {
        return --storage;
    }

    constexpr auto operator--(int) -> Numeral<T> {
        return storage--;
    }

    template <typename U>
    constexpr auto operator*=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage * static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator/(U const from) const -> Numeral<T>
    requires(is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage / static_cast<T const>(from));
    }

    template <typename U>
    constexpr auto operator/=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage / static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator%(U const from) const -> Numeral<T>
    requires(is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage % static_cast<T const>(from));
    }

    template <typename U>
    constexpr auto operator%=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage % static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator&=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage & static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator|=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage | static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator<<(U const from) const -> Numeral<T>
    requires(is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage << static_cast<T>(from));
    }

    template <typename U>
    constexpr auto operator<<=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage << static_cast<T const>(from);
        return *this;
    }

    template <typename U>
    constexpr auto operator>>(U const from) const -> Numeral<T>
    requires(is_safe_conversion<T, U>()) {
        return static_cast<T const>(this->storage >> static_cast<T>(from));
    }

    template <typename U>
    constexpr auto operator>>=(U const from)
        -> Numeral& requires(is_safe_conversion<T, U>()) {
        this->storage = this->storage >> static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator~() -> Numeral& {
        this->storage = ~(this->storage);
        return *this;
    }
};

template <typename T>
Numeral(T) -> Numeral<T>;

// Compare primitive numerals to `Numeral`s.
// TODO: Return a `Numeral` that is the larger size of either operand.
template <typename T, typename U>
constexpr auto operator>(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs > rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>=(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs >= rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs < rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<=(T const lhs, Numeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, Numeral>::value) {
    return lhs <= rhs.storage;
}

// Order-independant operators for `Numeral` and primitive numerals.
template <typename T, typename U>
constexpr auto operator==(Numeral<T> const lhs, U const rhs)
    -> bool requires(meta::is_signed<T> == meta::is_signed<U> &&
                     meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return lhs.storage == static_cast<T const>(rhs);
}

template <typename T, typename U>
constexpr auto operator+(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage + static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator-(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage - static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator*(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage * static_cast<T const>(rhs)};
}

template <typename T, typename U>
constexpr auto operator&(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage & static_cast<T const>(rhs)};
}

template <typename T, meta::Integral U>
constexpr auto operator|(Numeral<T> const lhs, U const rhs) requires(
    meta::is_signed<T> == meta::is_signed<U> &&
    meta::is_floating_point<T> == meta::is_floating_point<U>) {
    return Numeral{lhs.storage | static_cast<T>(rhs)};
}

// Pointer arithmetic operators for `Numeral`s.
template <typename T, typename U>
constexpr auto operator+(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs + rhs.storage;
}

template <typename T, typename U>
constexpr auto operator+=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs += rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator-(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs - rhs.storage;
}

template <typename T, typename U>
constexpr auto operator-=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs -= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator*(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs * rhs.storage;
}

template <typename T, typename U>
constexpr auto operator*=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs *= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator/(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs / rhs.storage;
}

template <typename T, typename U>
constexpr auto operator/=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs /= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator<<(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs << rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<<=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs <<= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator>>(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs >> rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>>=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs >>= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator%(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs % rhs.storage;
}

template <typename T, typename U>
constexpr auto operator%=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs %= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator&(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs & rhs.storage;
}

template <typename T, typename U>
constexpr auto operator&=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs &= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator|(T* const p_lhs, Numeral<U> const rhs) -> T* {
    return p_lhs | rhs.storage;
}

template <typename T, typename U>
constexpr auto operator|=(T*& p_lhs, Numeral<U> const rhs) -> T*& {
    p_lhs |= rhs.storage;
    return p_lhs;
}

}  // namespace cat::detail

// These macros are defined by the GCC compiler.
using int1 = cat::detail::Numeral<__INT8_TYPE__>;
using uint1 = cat::detail::Numeral<__UINT8_TYPE__>;
using int2 = cat::detail::Numeral<__INT16_TYPE__>;
using uint2 = cat::detail::Numeral<__UINT16_TYPE__>;
using int4 = cat::detail::Numeral<__INT32_TYPE__>;
using uint4 = cat::detail::Numeral<__UINT32_TYPE__>;
using int8 = cat::detail::Numeral<__INT64_TYPE__>;
using uint8 = cat::detail::Numeral<__UINT64_TYPE__>;
// using i128 = cat::detail::Numeral<int128_t>;
// using u128 = cat::detail::Numeral<uint128_t>;

using float4 = cat::detail::Numeral<float>;
using float8 = cat::detail::Numeral<double>;

// TODO: `__SIZE_TYPE__`.
using usize = uint8;
using ssize = int8;

// TODO: Document `bool1`.
struct bool1 {  // NOLINT
    using Type = uint1;
    uint1 value;
    constexpr bool1() = default;
    constexpr bool1(bool const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool2 {  // NOLINT
    using Type = uint2;
    uint2 value;
    constexpr bool2() = default;
    constexpr bool2(bool const input) {
        this->value = input;
    }
    constexpr bool2(bool1 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool4 {  // NOLINT
    using Type = uint4;
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool const input) {
        this->value = input;
    }
    constexpr bool4(bool1 const input) {
        this->value = input;
    }
    constexpr bool4(bool2 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct intptr {  // NOLINT
    // This macro is a GCC builtin.
    using Type = __INTPTR_TYPE__;
    Type storage;

    constexpr intptr() = default;

    constexpr intptr(intptr const& input) = default;

    constexpr intptr(intptr&& input) : storage(cat::move(input).storage){};

    constexpr intptr(meta::Integral auto const& input) : storage(input){};

    template <typename T>
    constexpr intptr(T* const p_input) {
        this->storage = reinterpret_cast<Type>(p_input);
    }

    template <meta::Integral T>
    constexpr operator T() {
        return static_cast<T>(this->storage);
    }

    template <meta::Integral T>
    constexpr operator T() const {
        return static_cast<T>(this->storage);
    }

    template <typename T>
    constexpr operator T*() {
        return reinterpret_cast<T*>(this->storage);
    }

    template <typename T>
    constexpr operator T*() const {
        return static_cast<T const*>(static_cast<void const*>(this));
    }

    constexpr auto operator=(intptr const& from) -> intptr& = default;
    constexpr auto operator=(intptr&& from) -> intptr& = default;

    constexpr auto operator=(meta::Integral auto const from) -> intptr& {
        this->storage = from;
        return *this;
    }

    constexpr auto operator>(meta::Integral auto const from) const -> bool1 {
        return this->storage > static_cast<Type>(from);
    }

    constexpr auto operator>=(meta::Integral auto const from) -> bool1 {
        return this->storage >= static_cast<Type>(from);
    }

    constexpr auto operator<(meta::Integral auto const from) const -> bool1 {
        return this->storage < static_cast<Type>(from);
    }

    constexpr auto operator<=(meta::Integral auto const from) -> bool1 {
        return this->storage <= static_cast<Type>(from);
    }

    constexpr auto operator+=(meta::Integral auto const from) -> intptr& {
        this->storage += static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator++() -> intptr {
        return ++(this->storage);
    }

    constexpr auto operator++(int) -> intptr {
        return (this->storage)++;
    }

    constexpr auto operator-=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage - static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator--() -> intptr {
        return --(this->storage);
    }

    constexpr auto operator--(int) -> intptr {
        return (this->storage)--;
    }

    constexpr auto operator*=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage * static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator/(meta::Integral auto const from) const -> intptr {
        return this->storage / static_cast<Type>(from);
    }

    constexpr auto operator/=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage / static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator%(meta::Integral auto const from) const -> intptr {
        return this->storage % static_cast<Type>(from);
    }

    constexpr auto operator%=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage % static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator&=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage & static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator|(meta::Integral auto const from) const -> intptr {
        return this->storage | static_cast<Type>(from);
    }

    constexpr auto operator|=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage | static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto const from) const -> intptr {
        return this->storage << static_cast<Type>(from);
    }

    constexpr auto operator<<=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage << static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto const from) const -> intptr {
        return this->storage >> static_cast<Type>(from);
    }

    constexpr auto operator>>=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage >> static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator~() -> intptr& {
        this->storage = ~(this->storage);
        return *this;
    }
};

// Order-independant operators between an `intptr` and a pointer.
template <typename T>
constexpr auto operator==(intptr const lhs, T* const p_rhs) -> bool {
    return lhs.storage == intptr{p_rhs}.storage;
}

template <typename T>
constexpr auto operator+(intptr const lhs, T* const p_rhs) -> intptr {
    return lhs.storage + intptr{p_rhs}.storage;
}

template <typename T>
constexpr auto operator-(intptr const lhs, T* const p_rhs) -> intptr {
    return lhs.storage - intptr{p_rhs}.storage;
}

template <typename T>
constexpr auto operator*(intptr const lhs, T* const p_rhs) -> intptr {
    return lhs.storage * intptr{p_rhs}.storage;
}

template <typename T>
constexpr auto operator&(intptr const lhs, T* const p_rhs) -> intptr {
    return lhs.storage & intptr{p_rhs}.storage;
}

template <typename T>
constexpr auto operator|(intptr const lhs, T* const p_rhs) -> intptr {
    return lhs.storage | intptr{p_rhs}.storage;
}

// Order-independant operators between an `intptr` and an integer.
template <meta::Integral T>
constexpr auto operator==(intptr const lhs, T const rhs) -> bool {
    return lhs.storage == intptr{rhs}.storage;
}

constexpr auto operator+(intptr const lhs, meta::Integral auto const rhs)
    -> intptr {
    return lhs.storage + intptr{rhs}.storage;
}

constexpr auto operator-(intptr const lhs, meta::Integral auto const rhs)
    -> intptr {
    return lhs.storage - intptr{rhs}.storage;
}

constexpr auto operator*(intptr const lhs, meta::Integral auto const rhs)
    -> intptr {
    return lhs.storage * intptr{rhs}.storage;
}

constexpr auto operator&(intptr const lhs, meta::Integral auto const rhs)
    -> intptr {
    return lhs.storage & intptr{rhs}.storage;
}

constexpr auto operator|(intptr const lhs, meta::Integral auto const rhs)
    -> intptr {
    return lhs.storage | intptr{rhs}.storage;
}
