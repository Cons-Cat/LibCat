// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

namespace cat::detail {

// `SafeNumeral` is a container for numeric data types which prevents unsafe or
// pessimizing implicit casts, such as loss of precision, change in
// signed-ness, or `float4` to `float8` conversion.
//
// All of its conversion operators, arithmetic operators and constructors are
// generic with constraints. Because these methods are constrained, it is
// possible that the compiler will fail to resolve any satisfying overloads for
// an invocation of an arithmetic operator, constructor, or conversion operator,
// and thus prevent compilation.
//
// Constraints such as "the operand's size must be less than or equal to my own
// size" guarantee that the an unwanted overload cannot be resolved. This
// solution is concise, because any constraint broadly applies to all possible
// type conversions.
template <typename T>
struct SafeNumeral {
    // `Type` allows SIMD specializations to easily get the underlying numeric
    // data type of a `SafeNumeral`.
    using Type = T;
    T storage;

    constexpr SafeNumeral() = default;

    constexpr SafeNumeral(T value) : storage(value){};

    template <typename U>
    constexpr SafeNumeral(U const from) requires(
        // clang-format off
        // Any number that is smaller than this can safely cast into it.
        sizeof(T) >= sizeof(from)
		/* &&
            (meta::is_signed<T> ==
                 meta::is_signed<decltype(decay_numeral(from))> &&
             meta::is_floating_point<T> ==
                 meta::is_floating_point<decltype(decay_numeral(from))>) ||
        (meta::is_bool<U> && meta::is_integral<T>)
		*/
        // clang-format on
        )
        : storage(from){};

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->storage);
    }

    // Get the underlying C API type.
    constexpr auto c() const -> T {
        return this->storage;
    }

    // TODO: Putting concepts or constexpr functions in these `requires`
    // clauses doesn't work, for some reason.
#define REQUIRES_HELPER true

    /* cat::is_signed_v<T> == cat::is_signed_v<decltype(decay_numeral(from))> &&
       \
            sizeof(T) >= sizeof(decltype(decay_numeral(from))) && \
            cat::is_floating_point_v<T> == \
                cat::is_floating_point_v<decltype(decay_numeral(from))>
    */

    constexpr auto operator=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator==(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage == static_cast<T const>(from);
    }

    constexpr auto operator>(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage > static_cast<T const>(from);
    }

    constexpr auto operator>=(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage >= static_cast<T const>(from);
    }

    constexpr auto operator<(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage < static_cast<T const>(from);
    }

    constexpr auto operator<=(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage <= static_cast<T const>(from);
    }

    constexpr auto operator+(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage + static_cast<T const>(from));
    }

    constexpr auto operator+=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage + static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator++() -> SafeNumeral& {
        ++storage;
        return *this;
    }

    constexpr auto operator++(int) -> SafeNumeral& {
        storage++;
        return *this;
    }

    constexpr auto operator-(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage - static_cast<T const>(from));
    }

    constexpr auto operator-=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage - static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator--() -> SafeNumeral<T> {
        return --storage;
    }

    constexpr auto operator--(int) -> SafeNumeral<T> {
        return storage--;
    }

    constexpr auto operator*(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage * static_cast<T const>(from));
    }

    constexpr auto operator*=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage * static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator/(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage / static_cast<T const>(from));
    }

    constexpr auto operator/=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage / static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator%(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage % static_cast<T const>(from));
    }

    constexpr auto operator%=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage % static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator&(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage & static_cast<T const>(from));
    }

    constexpr auto operator&=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage & static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator|(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage | static_cast<T const>(from));
    }

    constexpr auto operator|=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage | static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator<<(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage << static_cast<T>(from));
    }

    constexpr auto operator<<=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage << static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator>>(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage >> static_cast<T>(from));
    }

    constexpr auto operator>>=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage >> static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator~() -> SafeNumeral& {
        this->storage = ~(this->storage);
        return *this;
    }
};

template <typename T>
SafeNumeral(T) -> SafeNumeral<T>;

}  // namespace cat::detail

// These macros are defined by the GCC compiler.
using int1 = cat::detail::SafeNumeral<__INT8_TYPE__>;
using uint1 = cat::detail::SafeNumeral<__UINT8_TYPE__>;
using int2 = cat::detail::SafeNumeral<__INT16_TYPE__>;
using uint2 = cat::detail::SafeNumeral<__UINT16_TYPE__>;
using int4 = cat::detail::SafeNumeral<__INT32_TYPE__>;
using uint4 = cat::detail::SafeNumeral<__UINT32_TYPE__>;
using int8 = cat::detail::SafeNumeral<__INT64_TYPE__>;
using uint8 = cat::detail::SafeNumeral<__UINT64_TYPE__>;
// using i128 = cat::detail::SafeNumeral<int128_t>;
// using u128 = cat::detail::SafeNumeral<uint128_t>;

using float4 = cat::detail::SafeNumeral<float>;
using float8 = cat::detail::SafeNumeral<double>;

using usize = uint8;
using ssize = int8;

// TODO: Document `bool1`.
struct bool1 {  // NOLINT
    using Type = uint1;
    uint1 value;
    constexpr bool1() = default;
    constexpr bool1(bool const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool2 {  // NOLINT
    using Type = uint2;
    uint2 value;
    constexpr bool2() = default;
    constexpr bool2(bool const input) {
        this->value = input;
    }
    constexpr bool2(bool1 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool4 {  // NOLINT
    using Type = uint4;
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool const input) {
        this->value = input;
    }
    constexpr bool4(bool1 const input) {
        this->value = input;
    }
    constexpr bool4(bool2 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

// using intptr = cat::detail::SafeNumeral<__INTPTR_TYPE__>;

struct intptr {  // NOLINT
    using Type = __INTPTR_TYPE__;
    // This macro is a GCC builtin.
    Type storage;

    constexpr intptr() = default;

    constexpr intptr(intptr const& input) = default;

    constexpr intptr(intptr&& input) : storage(cat::move(input).storage){};

    constexpr intptr(meta::Integral auto const& input) : storage(input){};

    // template <meta::Integral T>
    // constexpr intptr(T input) : storage(input){};

    template <typename T>
    constexpr intptr(T* const p_input) {
        this->storage = reinterpret_cast<Type>(p_input);
    }

    template <meta::Integral T>
    constexpr operator T() const {
        return static_cast<T>(this->storage);
    }

    constexpr auto operator=(intptr const& from) -> intptr& = default;
    constexpr auto operator=(intptr&& from) -> intptr& = default;

    constexpr auto operator=(meta::Integral auto const from) -> intptr& {
        this->storage = reintret_cast<char*>(from);
        return *this;
    }

    constexpr auto operator==(meta::Integral auto const from) const -> bool1 {
        return this->storage == static_cast<ssize const>(from);
    }

    constexpr auto operator>(meta::Integral auto const from) const -> bool1 {
        return this->storage > static_cast<Type>(from);
    }

    constexpr auto operator>=(meta::Integral auto const from) -> bool1 {
        return this->storage >= static_cast<Type>(from);
    }

    constexpr auto operator<(meta::Integral auto const from) const -> bool1 {
        return this->storage < static_cast<Type>(from);
    }

    constexpr auto operator<=(meta::Integral auto const from) -> bool1 {
        return this->storage <= static_cast<Type>(from);
    }

    constexpr auto operator+(meta::Integral auto const from) const -> intptr {
        return this->storage + static_cast<Type>(from);
    }

    constexpr auto operator+=(meta::Integral auto const from) -> intptr& {
        this->storage += static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator++() -> intptr {
        return ++(this->storage);
    }

    constexpr auto operator++(int) -> intptr {
        return (this->storage)++;
    }

    constexpr auto operator-(meta::Integral auto const from) const -> intptr {
        return this->storage - static_cast<Type>(from);
    }

    constexpr auto operator-=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage - static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator--() -> intptr {
        return --(this->storage);
    }

    constexpr auto operator--(int) -> intptr {
        return (this->storage)--;
    }

    constexpr auto operator*(meta::Integral auto const from) const -> intptr {
        return this->storage * static_cast<Type>(from);
    }

    constexpr auto operator*=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage * static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator/(meta::Integral auto const from) const -> intptr {
        return this->storage / static_cast<Type>(from);
    }

    constexpr auto operator/=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage / static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator%(meta::Integral auto const from) const -> intptr {
        return this->storage % static_cast<Type>(from);
    }

    constexpr auto operator%=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage % static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator&(meta::Integral auto const from) const -> intptr {
        return this->storage & static_cast<Type>(from);
    }

    constexpr auto operator&=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage & static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator|(meta::Integral auto const from) const -> intptr {
        return this->storage | static_cast<Type>(from);
    }

    constexpr auto operator|=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage | static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto const from) const -> intptr {
        return this->storage << static_cast<Type>(from);
    }

    constexpr auto operator<<=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage << static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto const from) const -> intptr {
        return this->storage >> static_cast<Type>(from);
    }

    constexpr auto operator>>=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage >> static_cast<Type>(from);
        return *this;
    }

    template <typename T>
    constexpr operator T*() {
        return static_cast<T*>(static_cast<void*>(this));
        // return meta::bit_cast<T*>(this->storage);
    }

    template <typename T>
    constexpr operator T*() const {
        return static_cast<T const*>(static_cast<void const*>(this));
        // return meta::bit_cast<T*>(this->storage);
    }
};
