// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

namespace cat::detail {

// `SafeNumeral` is a container for numeric data types which prevents unsafe or
// pessimizing implicit casts, such as loss of precision, change in
// signed-ness, or `float4` to `float8` conversion.
//
// All of its conversion operators, arithmetic operators and constructors are
// generic with constraints. Because these methods are constrained, it is
// possible that the compiler will fail to resolve any satisfying overloads for
// an invocation of an arithmetic operator, constructor, or conversion operator,
// and thus prevent compilation.
//
// Constraints such as "the operand's size must be less than or equal to my own
// size" guarantee that the an unwanted overload cannot be resolved. This
// solution is concise, because any constraint broadly applies to all possible
// type conversions.
template <typename T>
struct SafeNumeral {
    // `Type` allows SIMD specializations to easily get the underlying numeric
    // data type of a `SafeNumeral`.
    using Type = T;
    T storage;

    constexpr SafeNumeral() = default;

    constexpr SafeNumeral(T value) : storage(value){};

    template <typename U>
    constexpr SafeNumeral(U const from) requires(
        // clang-format off
        // Any number that is smaller than this can safely cast into it.
        sizeof(T) >= sizeof(from)
		/* &&
            (meta::is_signed<T> ==
                 meta::is_signed<decltype(decay_numeral(from))> &&
             meta::is_floating_point<T> ==
                 meta::is_floating_point<decltype(decay_numeral(from))>) ||
        (meta::is_bool<U> && meta::is_integral<T>)
		*/
        // clang-format on
        )
        : storage(from){};

    template <typename U>
    constexpr explicit operator U() const {
        return static_cast<U>(this->storage);
    }

    // Get the underlying C API type.
    constexpr auto c() const -> T {
        return this->storage;
    }

    // TODO: Putting concepts or constexpr functions in these `requires`
    // clauses doesn't work, for some reason.
#define REQUIRES_HELPER true

    /* cat::is_signed_v<T> == cat::is_signed_v<decltype(decay_numeral(from))> &&
       \
            sizeof(T) >= sizeof(decltype(decay_numeral(from))) && \
            cat::is_floating_point_v<T> == \
                cat::is_floating_point_v<decltype(decay_numeral(from))>
    */

    constexpr auto operator=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator>(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage > static_cast<T const>(from);
    }

    constexpr auto operator>=(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage >= static_cast<T const>(from);
    }

    constexpr auto operator<(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage < static_cast<T const>(from);
    }

    constexpr auto operator<=(auto const from) const
        -> bool requires(REQUIRES_HELPER) {
        return this->storage <= static_cast<T const>(from);
    }

    constexpr auto operator+=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage + static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator++() -> SafeNumeral& {
        ++storage;
        return *this;
    }

    constexpr auto operator++(int) -> SafeNumeral& {
        storage++;
        return *this;
    }

    constexpr auto operator-=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage - static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator--() -> SafeNumeral<T> {
        return --storage;
    }

    constexpr auto operator--(int) -> SafeNumeral<T> {
        return storage--;
    }

    constexpr auto operator*=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage * static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator/(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage / static_cast<T const>(from));
    }

    constexpr auto operator/=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage / static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator%(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage % static_cast<T const>(from));
    }

    constexpr auto operator%=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage % static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator&=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage & static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator|=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage | static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator<<(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage << static_cast<T>(from));
    }

    constexpr auto operator<<=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage << static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator>>(auto const from) const -> SafeNumeral<T>
    requires(REQUIRES_HELPER) {
        return static_cast<T const>(this->storage >> static_cast<T>(from));
    }

    constexpr auto operator>>=(auto const from)
        -> SafeNumeral& requires(REQUIRES_HELPER) {
        this->storage = this->storage >> static_cast<T const>(from);
        return *this;
    }

    constexpr auto operator~() -> SafeNumeral& {
        this->storage = ~(this->storage);
        return *this;
    }
};

template <typename T>
SafeNumeral(T) -> SafeNumeral<T>;

// Compare primitive numerals to `SafeNumeral`s.
template <typename T, typename U>
constexpr auto operator>(T const lhs, SafeNumeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, SafeNumeral>::value) {
    return lhs > rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>=(T const lhs, SafeNumeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, SafeNumeral>::value) {
    return lhs >= rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<(T const lhs, SafeNumeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, SafeNumeral>::value) {
    return lhs < rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<=(T const lhs, SafeNumeral<U> const rhs)
    -> bool requires(meta::is_convertible<U, T> &&
                     !meta::IsSpecializationTrait<T, SafeNumeral>::value) {
    return lhs <= rhs.storage;
}

// Order-independant operators for `SafeNumeral` and primitive numerals.
template <typename T>
constexpr auto operator==(SafeNumeral<T> const lhs, auto const rhs) -> bool {
    return lhs.storage == static_cast<T const>(rhs);
}

template <typename T>
constexpr auto operator+(SafeNumeral<T> const lhs, auto const rhs)
    -> SafeNumeral<T> {
    return lhs.storage + static_cast<T const>(rhs);
}

template <typename T>
constexpr auto operator-(SafeNumeral<T> const lhs, auto const rhs)
    -> SafeNumeral<T> {
    return lhs.storage - static_cast<T const>(rhs);
}

template <typename T>
constexpr auto operator*(SafeNumeral<T> const lhs, auto const rhs)
    -> SafeNumeral<T> {
    return lhs.storage * static_cast<T const>(rhs);
}

template <typename T>
constexpr auto operator&(SafeNumeral<T> const lhs, auto const rhs)
    -> SafeNumeral<T> {
    return lhs.storage & static_cast<T const>(rhs);
}

template <typename T>
constexpr auto operator|(SafeNumeral<T> const lhs,
                         meta::Integral auto const rhs) -> SafeNumeral<T> {
    return lhs.storage | static_cast<T>(rhs);
}

// Pointer arithmetic operators for `SafeNumeral`s.
template <typename T, typename U>
constexpr auto operator+(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs + rhs.storage;
}

template <typename T, typename U>
constexpr auto operator+=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs += rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator-(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs - rhs.storage;
}

template <typename T, typename U>
constexpr auto operator-=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs -= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator*(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs * rhs.storage;
}

template <typename T, typename U>
constexpr auto operator*=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs *= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator/(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs / rhs.storage;
}

template <typename T, typename U>
constexpr auto operator/=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs /= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator<<(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs << rhs.storage;
}

template <typename T, typename U>
constexpr auto operator<<=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs <<= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator>>(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs >> rhs.storage;
}

template <typename T, typename U>
constexpr auto operator>>=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs >>= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator%(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs % rhs.storage;
}

template <typename T, typename U>
constexpr auto operator%=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs %= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator&(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs & rhs.storage;
}

template <typename T, typename U>
constexpr auto operator&=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs &= rhs.storage;
    return p_lhs;
}

template <typename T, typename U>
constexpr auto operator|(T* const p_lhs, SafeNumeral<U> const rhs) -> T* {
    return p_lhs | rhs.storage;
}

template <typename T, typename U>
constexpr auto operator|=(T*& p_lhs, SafeNumeral<U> const rhs) -> T*& {
    p_lhs |= rhs.storage;
    return p_lhs;
}

}  // namespace cat::detail

// These macros are defined by the GCC compiler.
using int1 = cat::detail::SafeNumeral<__INT8_TYPE__>;
using uint1 = cat::detail::SafeNumeral<__UINT8_TYPE__>;
using int2 = cat::detail::SafeNumeral<__INT16_TYPE__>;
using uint2 = cat::detail::SafeNumeral<__UINT16_TYPE__>;
using int4 = cat::detail::SafeNumeral<__INT32_TYPE__>;
using uint4 = cat::detail::SafeNumeral<__UINT32_TYPE__>;
using int8 = cat::detail::SafeNumeral<__INT64_TYPE__>;
using uint8 = cat::detail::SafeNumeral<__UINT64_TYPE__>;
// using i128 = cat::detail::SafeNumeral<int128_t>;
// using u128 = cat::detail::SafeNumeral<uint128_t>;

using float4 = cat::detail::SafeNumeral<float>;
using float8 = cat::detail::SafeNumeral<double>;

using usize = uint8;
using ssize = int8;

// TODO: Document `bool1`.
struct bool1 {  // NOLINT
    using Type = uint1;
    uint1 value;
    constexpr bool1() = default;
    constexpr bool1(bool const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool2 {  // NOLINT
    using Type = uint2;
    uint2 value;
    constexpr bool2() = default;
    constexpr bool2(bool const input) {
        this->value = input;
    }
    constexpr bool2(bool1 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct bool4 {  // NOLINT
    using Type = uint4;
    uint4 value;
    constexpr bool4() = default;
    constexpr bool4(bool const input) {
        this->value = input;
    }
    constexpr bool4(bool1 const input) {
        this->value = input;
    }
    constexpr bool4(bool2 const input) {
        this->value = input;
    }
    constexpr operator auto() const {
        return static_cast<bool>(this->value);
    }
};

struct intptr {  // NOLINT
    // This macro is a GCC builtin.
    using Type = __INTPTR_TYPE__;
    Type storage;

    constexpr intptr() = default;

    constexpr intptr(intptr const& input) = default;

    constexpr intptr(intptr&& input) : storage(cat::move(input).storage){};

    constexpr intptr(meta::Integral auto const& input) : storage(input){};

    template <typename T>
    constexpr intptr(T* const p_input) {
        this->storage = reinterpret_cast<Type>(p_input);
    }

    template <meta::Integral T>
    constexpr operator T() {
        return static_cast<T>(this->storage);
    }

    template <meta::Integral T>
    constexpr operator T() const {
        return static_cast<T>(this->storage);
    }

    template <typename T>
    constexpr operator T*() {
        return static_cast<T*>(static_cast<void*>(this));
    }

    template <typename T>
    constexpr operator T*() const {
        return static_cast<T const*>(static_cast<void const*>(this));
    }

    constexpr auto operator=(intptr const& from) -> intptr& = default;
    constexpr auto operator=(intptr&& from) -> intptr& = default;

    constexpr auto operator=(meta::Integral auto const from) -> intptr& {
        // TODO: Lol, fix and test this:
        this->storage = reintret_cast<char*>(from);
        return *this;
    }

    constexpr auto operator>(meta::Integral auto const from) const -> bool1 {
        return this->storage > static_cast<Type>(from);
    }

    constexpr auto operator>=(meta::Integral auto const from) -> bool1 {
        return this->storage >= static_cast<Type>(from);
    }

    constexpr auto operator<(meta::Integral auto const from) const -> bool1 {
        return this->storage < static_cast<Type>(from);
    }

    constexpr auto operator<=(meta::Integral auto const from) -> bool1 {
        return this->storage <= static_cast<Type>(from);
    }

    constexpr auto operator+=(meta::Integral auto const from) -> intptr& {
        this->storage += static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator++() -> intptr {
        return ++(this->storage);
    }

    constexpr auto operator++(int) -> intptr {
        return (this->storage)++;
    }

    constexpr auto operator-=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage - static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator--() -> intptr {
        return --(this->storage);
    }

    constexpr auto operator--(int) -> intptr {
        return (this->storage)--;
    }

    constexpr auto operator*=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage * static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator/(meta::Integral auto const from) const -> intptr {
        return this->storage / static_cast<Type>(from);
    }

    constexpr auto operator/=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage / static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator%(meta::Integral auto const from) const -> intptr {
        return this->storage % static_cast<Type>(from);
    }

    constexpr auto operator%=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage % static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator&=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage & static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator|(meta::Integral auto const from) const -> intptr {
        return this->storage | static_cast<Type>(from);
    }

    constexpr auto operator|=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage | static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto const from) const -> intptr {
        return this->storage << static_cast<Type>(from);
    }

    constexpr auto operator<<=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage << static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto const from) const -> intptr {
        return this->storage >> static_cast<Type>(from);
    }

    constexpr auto operator>>=(meta::Integral auto const from) -> intptr& {
        this->storage = this->storage >> static_cast<Type>(from);
        return *this;
    }

    constexpr auto operator~() -> intptr& {
        this->storage = ~(this->storage);
        return *this;
    }
};

// Order independant.storage operators between an `intptr` and an integral or
// pointer.

constexpr auto operator==(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage == intptr{rhs}.storage;
}

constexpr auto operator+(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage + intptr{rhs}.storage;
}

constexpr auto operator-(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage - intptr{rhs}.storage;
}

constexpr auto operator*(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage * intptr{rhs}.storage;
}

constexpr auto operator&(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage & intptr{rhs}.storage;
}

constexpr auto operator|(intptr const lhs, auto rhs) -> intptr {
    return lhs.storage | intptr{rhs}.storage;
}
