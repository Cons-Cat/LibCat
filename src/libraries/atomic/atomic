// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// Every function in this file that is prefixed with `__` is a GCC built-in.
// TODO: Argument names that end with `1` or `2` should be improved.

namespace atom {

enum MemoryOrder : int
{
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst,
};

namespace detail {
    enum MemoryOrderModifier
    {
        mask = 0x0ffff,
        modifier_mask = 0xffff0000,
        hle_acquire = 0x10000,
        hle_release = 0x20000
    };
}  // namespace detail

constexpr auto operator|(MemoryOrder order,
                         detail::MemoryOrderModifier modifier) -> MemoryOrder {
    return MemoryOrder(order | modifier);
}

constexpr auto operator&(MemoryOrder order,
                         detail::MemoryOrderModifier modifier) -> MemoryOrder {
    return MemoryOrder(order & modifier);
}

namespace detail {
    constexpr auto cmpexch_failure_order2(MemoryOrder order) -> MemoryOrder {
        return order == MemoryOrder::acq_rel   ? MemoryOrder::acquire
               : order == MemoryOrder::release ? MemoryOrder::relaxed
                                               : order;
    }

    constexpr auto cmpexch_failure_order(MemoryOrder order) -> MemoryOrder {
        return MemoryOrder(
            cmpexch_failure_order2(order & detail::MemoryOrderModifier::mask) |
            detail::MemoryOrderModifier(
                order & detail::MemoryOrderModifier::modifier_mask));
    }
}  // namespace detail

void atomic_thread_fence(MemoryOrder&& order) {
    __atomic_thread_fence(order);
}

void atomic_signal_fence(MemoryOrder&& order) {
    __atomic_signal_fence(order);
}

// Ensure that the dependency tree started by an `atom::MemoryOrder::consume`
// atomic load operation does not extend past this return value. `expression`
// does not carry a dependency into the return value.
template <typename T>
auto kill_dependency(T expression) -> T {
    return result(expression);
}

}  // namespace atom

// `Atomic<T>` wraps a type that may be `2`, `4`, or `8` bytes large. If it
// wraps a `bool`, it does not have fetch methods or operators.
template <typename T>
struct Atomic {
    // using ValueType = T;
    static constexpr i4 alignment = sizeof(T) > alignof(T) ? sizeof(T)
                                                           : alignof(T);

    // It is advised against that you directly access this member.
    alignas(alignment) T value = 0;

    Atomic() = default;
    ~Atomic() = default;
    Atomic(Atomic const&) = delete;
    auto operator=(Atomic const&) -> Atomic& = delete;
    auto operator=(Atomic const&) volatile -> Atomic& = delete;
    constexpr Atomic(T initial_value) : value(initial_value) {
    }

    operator T() const {
        return load();
    }

    operator T() const volatile {
        return load();
    }

    auto operator=(T operand) -> T {
        store(operand);
        return operand;
    }

    auto operator=(T operand) volatile -> T {
        store(operand);
        return operand;
    }

    auto operator++(int) -> T requires(!meta::is_same_v<T, bool>) {
        return fetch_add(1);
    }

    auto operator++(int) volatile -> T requires(!meta::is_same_v<T, bool>) {
        return fetch_add(1);
    }

    auto operator--(int) -> T requires(!meta::is_same_v<T, bool>) {
        return fetch_sub(1);
    }

    auto operator--(int) volatile -> T requires(!meta::is_same_v<T, bool>) {
        return fetch_sub(1);
    }

    auto operator++() -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_add_fetch(&value, 1, atom::MemoryOrder::seq_cst);
    }

    auto operator++() volatile -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_add_fetch(&value, 1, atom::MemoryOrder::seq_cst);
    }

    auto operator--() -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_sub_fetch(&value, 1, atom::MemoryOrder::seq_cst);
    }

    auto operator--() volatile -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_sub_fetch(&value, 1, atom::MemoryOrder::seq_cst);
    }

    auto operator+=(auto operand) -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_add_fetch(&value, operand, atom::MemoryOrder::seq_cst);
    }

    auto operator+=(auto operand) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_add_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator-=(auto operand) -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_sub_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator-=(auto operand) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_sub_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator&=(auto operand) -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_and_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator&=(auto operand) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_and_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator|=(auto operand) -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_or_fetch(&value, operand,
                                 i4(atom::MemoryOrder::seq_cst));
    }

    auto operator|=(auto operand) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_or_fetch(&value, operand,
                                 i4(atom::MemoryOrder::seq_cst));
    }

    auto operator^=(auto operand) -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_xor_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto operator^=(auto operand) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_xor_fetch(&value, operand,
                                  i4(atom::MemoryOrder::seq_cst));
    }

    auto is_lock_free() const -> bool {
        // Use a fake, minimally aligned pointer.
        return __atomic_is_lock_free(sizeof(value),
                                     // NOLINTNEXTLINE
                                     reinterpret_cast<void*>(-alignment));
    }

    auto is_lock_free() const volatile -> bool {
        // Use a fake, minimally aligned pointer.
        return __atomic_is_lock_free(sizeof(value),
                                     // NOLINTNEXTLINE
                                     reinterpret_cast<void*>(-alignment));
    }

    void store(auto storing,
               atom::MemoryOrder operand = atom::MemoryOrder::seq_cst) {
        atom::MemoryOrder test_value [[gnu::unused]] =
            operand & atom::detail::mask;

        Result(test_value != atom::MemoryOrder::acquire).or_panic_debug();
        Result(test_value != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value != atom::MemoryOrder::consume).or_panic_debug();

        __atomic_store_n(&value, storing, operand);
    }

    void store(auto operand,
               atom::MemoryOrder order = atom::MemoryOrder::seq_cst) volatile {
        atom::MemoryOrder test_value [[gnu::unused]] =
            order & atom::detail::mask;

        Result(test_value != atom::MemoryOrder::acquire).or_panic_debug();
        Result(test_value != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value != atom::MemoryOrder::consume).or_panic_debug();

        __atomic_store_n(&value, operand, order);
    }

    auto load(atom::MemoryOrder order = atom::MemoryOrder::seq_cst) const -> T {
        atom::MemoryOrder test_value [[gnu::unused]] =
            order & atom::detail::mask;

        Result(test_value != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value != atom::MemoryOrder::acq_rel).or_panic_debug();

        return __atomic_load_n(&value, order);
    }

    auto load(atom::MemoryOrder order = atom::MemoryOrder::seq_cst) const
        volatile -> T {
        atom::MemoryOrder test_value [[gnu::unused]] =
            order & atom::detail::mask;

        Result(test_value != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value != atom::MemoryOrder::acq_rel).or_panic_debug();

        return __atomic_load_n(&value, order);
    }

    auto exchange(T operand,
                  atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T {
        return __atomic_exchange_n(&value, operand, order);
    }

    auto exchange(T operand,
                  atom::MemoryOrder order = atom::MemoryOrder::seq_cst) volatile
        -> T {
        return __atomic_exchange_n(&value, operand, order);
    }

    auto compare_exchange_weak(T& operand1, T operand2,
                               atom::MemoryOrder order1,
                               atom::MemoryOrder order2) -> bool {
        atom::MemoryOrder test_value2 [[gnu::unused]] =
            order2 & atom::detail::mask;
        atom::MemoryOrder test_value1 [[gnu::unused]] =
            order1 & atom::detail::mask;

        Result(test_value2 != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value2 != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value2 <= test_value1).or_panic_debug();

        return __atomic_compare_exchange_n(&value, &operand1, operand2, 1,
                                           order1, order2);
    }

    auto compare_exchange_weak(T& operand1, T operand2,
                               atom::MemoryOrder order1,
                               atom::MemoryOrder order2) volatile -> bool {
        atom::MemoryOrder test_value2 [[gnu::unused]] =
            order2 & atom::detail::mask;
        atom::MemoryOrder test_value1 [[gnu::unused]] =
            order1 & atom::detail::mask;

        Result(test_value2 != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value2 != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value2 <= test_value1).or_panic_debug();

        return __atomic_compare_exchange_n(&value, &operand1, operand2, 1,
                                           order1, order2);
    }

    auto compare_exchange_weak(
        T& operand1, T operand2,
        atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> bool {
        return compare_exchange_weak(
            operand1, operand2, order,
            atom::detail::cmpexch_failure_order(order));
    }

    auto compare_exchange_weak(
        T& operand1, T operand2,
        atom::MemoryOrder order = atom::MemoryOrder::seq_cst) volatile -> bool {
        return compare_exchange_weak(
            operand1, operand2, order,
            atom::detail::cmpexch_failure_order(order));
    }

    auto compare_exchange_strong(T& operand1, T operand2,
                                 atom::MemoryOrder order1,
                                 atom::MemoryOrder order2) -> bool {
        atom::MemoryOrder test_value2 [[gnu::unused]] =
            order2 & atom::detail::mask;
        atom::MemoryOrder test_value1 [[gnu::unused]] =
            order1 & atom::detail::mask;

        Result(test_value2 != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value2 != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value2 <= test_value1).or_panic_debug();

        return __atomic_compare_exchange_n(&value, &operand1, operand2, 0,
                                           order1, order2);
    }

    auto compare_exchange_strong(T& operand1, T operand2,
                                 atom::MemoryOrder order1,
                                 atom::MemoryOrder order2) volatile -> bool {
        atom::MemoryOrder test_value2 [[gnu::unused]] =
            order2 & atom::detail::mask;
        atom::MemoryOrder test_value1 [[gnu::unused]] =
            order1 & atom::detail::mask;

        Result(test_value2 != atom::MemoryOrder::release).or_panic_debug();
        Result(test_value2 != atom::MemoryOrder::acq_rel).or_panic_debug();
        Result(test_value2 <= test_value1).or_panic_debug();

        return __atomic_compare_exchange_n(&value, &operand1, operand2, 0,
                                           order1, order2);
    }

    auto compare_exchange_strong(
        T& operand1, T operand2,
        atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> bool {
        return compare_exchange_strong(
            operand1, operand2, order,
            atom::detail::cmpexch_failure_order(order));
    }

    auto compare_exchange_strong(
        T& operand1, T operand2,
        atom::MemoryOrder order = atom::MemoryOrder::seq_cst) volatile -> bool {
        return compare_exchange_strong(
            operand1, operand2, order,
            atom::detail::cmpexch_failure_order(order));
    }

    auto fetch_add(auto operand,
                   atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_add(&value, operand, order);
    }

    auto fetch_add(auto operand, atom::MemoryOrder order =
                                     atom::MemoryOrder::seq_cst) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_add(&value, operand, order);
    }

    auto fetch_sub(auto operand,
                   atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_sub(&value, operand, order);
    }

    auto fetch_sub(auto operand, atom::MemoryOrder order =
                                     atom::MemoryOrder::seq_cst) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_sub(&value, operand, order);
    }

    auto fetch_and(auto operand,
                   atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_and(&value, operand, order);
    }

    auto fetch_and(auto operand, atom::MemoryOrder order =
                                     atom::MemoryOrder::seq_cst) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_and(&value, operand, order);
    }

    auto fetch_or(auto operand,
                  atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_or(&value, operand, order);
    }

    auto fetch_or(auto operand,
                  atom::MemoryOrder order = atom::MemoryOrder::seq_cst) volatile
        -> T requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_or(&value, operand, order);
    }

    auto fetch_xor(auto operand,
                   atom::MemoryOrder order = atom::MemoryOrder::seq_cst) -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_xor(&value, operand, order);
    }

    auto fetch_xor(auto operand, atom::MemoryOrder order =
                                     atom::MemoryOrder::seq_cst) volatile -> T
        requires(!meta::is_same_v<T, bool>) {
        return __atomic_fetch_xor(&value, operand, order);
    }

    // TODO: Add C++20 atomic wait operations.
};

// TODO: Add atomic flags
// TODO: Add atomic ref
