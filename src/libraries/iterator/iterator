// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <memory>
#include <type_traits>

// TODO: Support `single_pass` iterators.

namespace cat::detail {

enum class IteratorDirection {
    backwards = -1,
    forwards = 1
};

// https://quuxplusone.github.io/blog/2019/02/06/arrow-proxy/
// TODO: Move this into somewhere generally useful.
template <class Reference>
struct ArrowProxy {
    Reference r;
    auto operator->() -> Reference* {
        return &r;
    }
};

template <typename T>
concept HasIncrement = requires(T it) {
    it.increment();
};

template <typename T>
concept HasDecrement = requires(T it) {
    it.decrement();
};

template <typename T>
concept HasDistanceTo = requires(T const t) {
    t.distance_to(t);
};

template <typename T>
concept HasEqualTo = requires(T const it) {
    { it.equal_to(it) } -> meta::convertible_to<bool>;  // -> boolean;
};

template <typename>
struct InferDifferenceType {
    using type = ssize;
};

// Case when `T` provides a `distance_to`
template <detail::HasDistanceTo T>
struct InferDifferenceType<T> {
    static T const& it;
    using type = decltype(it.distance_to(it));
};

template <typename...>
struct InferValueType {};

template <typename T>
struct InferValueType<T> {
    static const T& it;
    using type = meta::remove_cvref_t<decltype(*it)>;
};

template <typename T>
requires requires {
    typename T::value_type;
}
struct InferValueType<T> {
    using type = typename T::value_type;
};

template <typename T>
concept HasAdvance = requires(T it, InferDifferenceType<T> const offset) {
    it.advance(offset);
};

template <typename T>
concept HasRandomAccess = HasAdvance<T> && HasDistanceTo<T>;

template <typename T>
concept HasBidirectional = HasRandomAccess<T> || HasDecrement<T>;

template <typename T>
concept HasSinglePass = bool(T::single_pass_iterator);

template <typename Iter, typename T>
concept HasSentinel = meta::same_as<T, typename T::sentinel_type>;

}  // namespace cat::detail

template <typename T>
using InferDifferenceType = typename cat::detail::InferDifferenceType<T>::type;

template <typename Arg, typename Iter>
concept DifferenceTypeArg =
    meta::convertible_to<Arg, InferDifferenceType<Iter>>;

template <typename T>
using InferValueType = typename cat::detail::InferValueType<T>::type;

// https://vector-of-bool.github.io/2020/06/13/cpp20-iter-facade.html
// Every `IteratorFacade` is `indirectly_readable` and is a `forward_iterator`.
template <typename Derived, cat::detail::IteratorDirection direction =
                                cat::detail::IteratorDirection::forwards>
struct IteratorFacade {
    // `Type` is needed for reversing.
    using Type = Derived;

    consteval static auto get_direction() {
        return direction;
    }

    consteval static auto get_reverse_direction() {
        return static_cast<cat::detail::IteratorDirection>(
            static_cast<int>(direction) * -1);
    }

    auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    auto self() const -> Derived const& {
        return static_cast<Derived const&>(*this);
    }

    auto operator*() const -> decltype(auto) {
        return this->self().dereference();
    }

    auto operator->() const {
        decltype(auto) reference = **this;
        if constexpr (meta::is_reference_v<decltype(reference)>) {
            // `ref` is a true reference, and we're safe to take its address
            return cat::address_of(reference);
        } else {
            // `ref` is *not* a reference. Returning its address would be
            // the address of a local. Return that thing wrapped in an
            // arrow_proxy.
            return arrow_proxy(meta::move(reference));
        }
    }

    friend auto operator==(Derived const& left, Derived const& right) -> bool {
        if constexpr (cat::detail::HasEqualTo<Derived>) {
            return left.equal_to(right);
        } else {
            return left.distance_to(right) == 0;
        }
    }

    friend auto operator==(Derived const& self,
                           cat::detail::HasSentinel<Derived> auto) -> bool {
        return self.at_end();
    }

    friend auto operator+(Derived left, DifferenceTypeArg<Derived> auto offset)
        -> Derived requires cat::detail::HasAdvance<Derived> {
        return left += offset * static_cast<int>(direction);
    }

    friend auto operator+(DifferenceTypeArg<Derived> auto offset, Derived right)
        -> Derived requires cat::detail::HasAdvance<Derived> {
        return right += offset * static_cast<int>(direction);
    }

    friend auto operator+=(Derived& self,
                           DifferenceTypeArg<Derived> auto offset)
        -> Derived& requires cat::detail::HasAdvance<Derived> {
        self.advance(static_cast<int>(offset));
        return self;
    }

    // Increment or advance forwards with prefix notation.
    auto operator++() -> Derived& {
        if constexpr (cat::detail::HasIncrement<Derived>) {
            this->self().increment();
        } else {
            this->self().advance(1 * static_cast<int>(direction));
        }
        return this->self();
    }

    // Increment or advance forwards with postfix notation.
    auto operator++(int) -> Derived {
        auto copy = this->self();
        ++(*this);
        return copy;
    }

    friend auto operator-(const Derived& left, const Derived& right)
        -> Derived& requires cat::detail::HasAdvance<Derived> {
        return right.distance_to(left);
    }

    friend auto operator-(Derived left, DifferenceTypeArg<Derived> auto offset)
        -> Derived requires cat::detail::HasAdvance<Derived> {
        return left - offset * static_cast<int>(direction);
    }

    friend auto operator-=(Derived& left,
                           DifferenceTypeArg<Derived> auto offset)
        -> Derived& requires cat::detail::HasAdvance<Derived> {
        return left -= offset * static_cast<int>(direction);
    }

    // Decrement or advance backwards with prefix notation.
    auto operator--() -> Derived& {
        if constexpr (cat::detail::HasDecrement<Derived>) {
            this->self().decrement();
        } else {
            this->self().advance(-1 * static_cast<int>(direction));
        }
        return this->self();
    }

    // Decrement or advance backwards with postfix notation.
    auto operator--(int)
        -> Derived& requires cat::detail::HasDecrement<Derived> {
        auto copy = *this;
        --(*this);
        return copy;
    }

    // Random-access.
    auto operator[](DifferenceTypeArg<Derived> auto offset)
        -> decltype(auto) requires cat::detail::HasAdvance<Derived> {
        return *(this->self() + offset);
    }

    // TODO: Support `<=>` operator.
};

namespace cat {

struct RandomAccessIteratorTag {};
struct BidirectionalIteratorTag {};
struct InputIteratorTag {};
struct ForwardIteratorTag {};

template <typename T>
requires meta::is_base_of_v<IteratorFacade<T>, T>
struct iterator_traits {
    static T const& it;
    using Value = InferValueType<T>;
    using Reference = decltype(*it);
    using Pointer = decltype(it.operator->());
    using Difference = InferDifferenceType<T>;
    using Category = meta::conditional_t<
        // If this can be a random access iterator, it always will be.
        cat::detail::HasRandomAccess<T>, RandomAccessIteratorTag,
        meta::conditional_t<
            // If this has a `++` and a `--` operator, this is a bidirectional
            // iterator.
            cat::detail::HasBidirectional<T>, BidirectionalIteratorTag,
            meta::conditional_t<cat::detail::HasSinglePass<T>,
                                // If it is single-pass, this is a forward
                                // iterator.
                                InputIteratorTag,
                                // Default to a forward iterator.
                                ForwardIteratorTag>>>;
    // using IteratorConcept = Category;
};

template <typename T>
struct ReversedIterator : IteratorFacade<ReversedIterator<T>> {
    T iterator;

    // Forward any constructor to `iterator`.
    template <typename... Args>
    ReversedIterator(Args&&... args) : iterator(meta::forward<Args>(args)...){};

    auto dereference() const {
        return this->iterator.dereference();
    }

    void advance(int offset) {
        this->iterator.advance(-offset);
    }

    auto distance_to(ReversedIterator<T> other) const -> int {
        return this->iterator.distance_to(other.iterator);
    }
};

template <typename T>
class Reverse {
  private:
    T& iterable;
  public:
    explicit Reverse(T& iterable) : iterable{iterable} {
    }

    auto begin() const {
        return iterable.rbegin();
    }

    auto end() const {
        return iterable.rend();
    }
};

}  // namespace cat
