// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/math>
#include <cat/meta>
#include <cat/optional>

namespace cat {
template <typename T>
class Span;
}

namespace meta {

template <typename Derived, typename T>
class CollectionFacade {
    // clang-format off
	
    // If a `.p_data()` and either a `.size()` or `.capacity()` method are
    // provided, then this collection is assumed to be contiguous in memory.
    constexpr static bool is_contiguous = requires {
        Derived{}.p_data();
    } && (requires { Derived{}.size(); } || requires { Derived{}.capacity(); });

    // If `.size()` is provided and can be constant-evaluated, and `.capacity()`
    // is not provided, then the length of this collection is assumed to be
    // constant.
    constexpr static bool has_const_length = requires {
		meta::constant_evaluate(Derived{}.size());
    } && !requires {
        Derived{}.capacity();
    };

    // clang-format on

    constexpr auto self_mut() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    constexpr auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    constexpr auto self() const -> Derived const& {
        return static_cast<Derived const&>(*this);
    }

  protected:
    // If the collection does not define an iterator, then one should be
    // generated. This function only exists for the purpose of deducing the type
    // of an iterator as `decltype(make_iterator())`.

    // Contiguous collections can produce non-`const` bidirectional iterators.
    constexpr auto make_iterator() requires(is_contiguous) {
        struct Iterator : cat::IteratorFacade<Iterator> {
            ssize current_index;
            T* const p_array;

            constexpr Iterator(Iterator const&) = default;
            constexpr Iterator(ssize const index, T* const p_in_array)
                : current_index(index), p_array(p_in_array){};
            constexpr auto dereference() -> T& {
                return unconst(this->p_array[current_index.c()]);
            }
            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.c()];
            }
            constexpr void advance(ssize const offset) {
                this->current_index += offset;
            }
            constexpr auto distance(Iterator const& other) const -> ssize {
                return other.current_index - current_index;
            }
        };

        // Produce an iterator to have its type deduced later.
        return Iterator{0, nullptr};
    }

    // Contiguous collections can produce `const` bidirectional iterators.
    constexpr auto make_iterator() const requires(is_contiguous) {
        struct Iterator : cat::IteratorFacade<Iterator> {
            ssize current_index;
            T const* const p_array;
            constexpr Iterator(Iterator const&) = default;
            constexpr Iterator(ssize const index, T const* const p_in_array)
                : current_index(index), p_array(p_in_array){};
            constexpr auto dereference() const -> T const& {
                return this->p_array[current_index.c()];
            }
            constexpr void advance(ssize const offset) {
                this->current_index += offset;
            }
            constexpr auto distance(Iterator const& other) const -> ssize {
                return other.current_index - current_index;
            }
        };

        // Produce an iterator to have its type deduced later.
        return Iterator{0, nullptr};
    }

    // If `Derived` is not contiguous, use a provided iterator.
    static constexpr auto make_iterator() {
        // Produce an iterator to have its type deduced later.
        return typename Derived::Iterator{};
    }

  public:
    // If `.size()` is provided and `.capacity()` is not, generate
    // `.capacity()`.
    [[nodiscard]] constexpr auto capacity() const -> ssize {
        return this->self().size();
    }

    // This evaluates true if there are one or more elements currently in this
    // collection.
    [[nodiscard]] constexpr auto is_empty() const
        -> bool requires(Derived::size()) {
        return this->self().size() > 0;
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize const index) -> cat::Optional<T&>
    requires(is_contiguous) {
        Result{index >= 0}.assert();
        if (index < this->self().capacity()) {
            return this->self_mut().p_data()[index.c()];
        }
        return nullopt;
    }

    // Index into this collection with bounds-checking.
    [[nodiscard]] constexpr auto at(ssize const index) const
        -> cat::Optional<T&> {
        // `unconst()` allows `.at()` to be safely called in a `const` context.
        return unconst(this)->at(index);
    }

    [[nodiscard]] constexpr auto front() -> T& requires(is_contiguous) {
        return this->self_mut().p_data()[0];
    }

    [[nodiscard]] constexpr auto front() const -> T const& {
        return unconst(this)->front();
    }

    [[nodiscard]] constexpr auto back() -> T& requires(is_contiguous) {
        return this->self_mut().p_data()[this->self().size().c() - 1];
    }

    [[nodiscard]] constexpr auto back() const -> T const& {
        return unconst(this)->back();
    }

    [[nodiscard]] constexpr auto slice(ssize const start_index,
                                       ssize const end_index) -> cat::Span<T>
    requires(is_contiguous) {
        Result{start_index >= 0}.assert();
        Result{end_index <= this->self().capacity()}.assert();
        return cat::Span<T>(this->self().p_data() + start_index,
                            end_index - start_index);
    }

    [[nodiscard]] constexpr auto slice(ssize const start_index,
                                       ssize const end_index) const
        -> cat::Span<T const>
    requires(is_contiguous) {
        Result{start_index >= 0}.assert();
        Result{end_index <= this->self().capacity()}.assert();
        return cat::Span<T const>(this->self().p_data() + start_index,
                                  end_index - start_index);
    }

    [[nodiscard]] constexpr auto first(ssize const count) -> cat::Span<T>
    requires(is_contiguous) {
        return this->slice(0, count);
    }

    [[nodiscard]] constexpr auto first(ssize const count) const
        -> cat::Span<T const>
    requires(is_contiguous) {
        return this->slice(0, count);
    }

    [[nodiscard]] constexpr auto last(ssize const count) -> cat::Span<T>
    requires(is_contiguous) {
        return this->slice(this->self().size() - count, this->self().size());
    }

    [[nodiscard]] constexpr auto last(ssize const count) const
        -> cat::Span<T const>
    requires(is_contiguous) {
        return this->slice(this->self().size() - count, this->self().size());
    }

    [[nodiscard]] constexpr auto operator[](ssize const index)
        -> T& requires(is_contiguous) {
        Result{index >= 0}.assert();
        Result{index < this->self().size()}.assert();

        return this->self_mut().p_data()[index.c()];
    }

    [[nodiscard]] constexpr auto operator[](ssize const index) const
        -> T const& requires(is_contiguous) {
        Result{index >= 0}.assert();
        Result{index < this->self().size()}.assert();

        return this->self().p_data()[index.c()];
    }

    [[nodiscard]] constexpr auto begin() requires(is_contiguous) {
        return meta::RemoveConst<decltype(unconst(this)->make_iterator())>{
            0, this->self_mut().p_data()};
    }

    [[nodiscard]] constexpr auto end() requires(is_contiguous) {
        return meta::RemoveConst<decltype(unconst(this)->make_iterator())>{
            this->self_mut().size(), this->self().p_data()};
    }

    // If this collection is not contiguous, get a non-`const` `.begin()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto begin() {
        return this->self_mut().begin();
    }

    // If this collection is not contiguous, get a non-`const` `.end()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto end() {
        return this->self_mut().end();
    }

    [[nodiscard]] constexpr auto begin() const {
        return unconst(this)->begin();
    }

    [[nodiscard]] constexpr auto end() const {
        return unconst(this)->end();
    }

    [[nodiscard]] constexpr auto cbegin() const {
        return this->begin();
    }

    [[nodiscard]] constexpr auto cend() const {
        return this->end();
    }

    [[nodiscard]] constexpr auto rbegin() requires(is_contiguous) {
        return cat::ReversedIterator<decltype(this->begin())>{
            this->self().size() - 1, this->self().p_data()};
    }

    [[nodiscard]] constexpr auto rend() requires(is_contiguous) {
        return cat::ReversedIterator<decltype(this->end())>(
            -1, this->self().p_data());
    }

    // If this collection is not contiguous, get a non-`const` `.rbegin()`
    // method from `Derived`.
    [[nodiscard]] constexpr auto rbegin() requires(!is_contiguous) {
        return this->self_mut().rbegin();
    }

    // If this collection is not contiguous, get a non-`const` `.rend()` method
    // from `Derived`.
    [[nodiscard]] constexpr auto rend() requires(!is_contiguous) {
        return this->self_mut().rbegin();
    }

    [[nodiscard]] constexpr auto rbegin() const {
        return unconst(this)->rbegin();
    }

    [[nodiscard]] constexpr auto rend() const {
        return unconst(this)->rend();
    }

    [[nodiscard]] constexpr auto crbegin() const {
        return this->rbegin();
    }

    [[nodiscard]] constexpr auto crend() const {
        return this->rend();
    }
};

}  // namespace meta
