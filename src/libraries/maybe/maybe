// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <memory>
#include <string>
#include <type_traits>
#include <utility>

// TODO: Support `Maybe<void>`.

namespace cat::detail {

// A `None` is consumed by a `Maybe` constructor to prevent initializing its
// `value` member.
struct None {};

// A `Monostate` represents a `Maybe` that holds no `value`.
struct Monostate {};

}  // namespace cat::detail

inline constexpr cat::detail::None none;

template <typename T, auto predicate, T sentinel>
struct Predicate {};

template <typename T, T sentinel>
using Sentinel = Predicate<T,
                           [](T const value) {
                               return value != sentinel;
                           },
                           sentinel>;

template <typename T>
struct MaybeValueStorage {
    struct Dummy {};
    union {
        // `Dummy` is required so that `MaybeValueStorage` can be initialized
        // in a `constexpr` context, because a member `union` must have at least
        // one initialized field, and it should not be `value`. `Dummy` can be
        // default-initialized, so this is well-formed.
        Dummy dummy;
        T value;
    };
    using ValueType = T;
    bool1 has_some = false;

    // `MaybeValueStorage`'s constructors, assignment operators, and
    // destructors are relatively complex. Consider paying special attention to
    // them.
    constexpr MaybeValueStorage(cat::detail::None){};

    // Enable copy and move constructors iff `Maybevaluestorage` supports them.
    constexpr MaybeValueStorage(MaybeValueStorage const& maybe) requires(
        meta::is_copy_constructible_v<T>) = default;
    constexpr MaybeValueStorage(MaybeValueStorage const& maybe) = delete;
    constexpr MaybeValueStorage(MaybeValueStorage&& maybe) requires(
        meta::is_move_constructible_v<T>) = default;
    constexpr MaybeValueStorage(MaybeValueStorage&& maybe) = delete;

    // If other destructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    constexpr ~MaybeValueStorage() = default;

    // If `T` is not trivially copy constructible, then manually construct it
    // in-place.
    constexpr MaybeValueStorage(MaybeValueStorage const& maybe) requires(
        !meta::is_trivially_copy_constructible_v<T>) {
        if (maybe.has_value()) {
            this->construct(maybe.get_value());
        } else {
            this->has_some = false;
        }
    }

    // If `T` is not trivially move constructible, then manually invoke
    // `meta::move` on it.
    MaybeValueStorage(MaybeValueStorage&& maybe) requires(
        meta::is_move_constructible_v<T> &&
        !meta::is_trivially_move_constructible_v<T>) {
        if (maybe.has_value()) {
            this->construct(meta::move(maybe.get_value()));
        } else {
            this->has_some = false;
        }
    }

    // If `T` is not trivially destructible, then manually invoke its
    // destructor.
    constexpr ~MaybeValueStorage() requires(
        !meta::is_trivially_destructible_v<T>) {
        if (this->has_some) {
            this->value.~T();
        }
    }

    // TODO: Handle non-trivial `U`.
    // If a `MaybeValueStorage` consumes a `T` or a type that is convertible to
    // `T`, it should be constructed.
    template <typename U = T>
    constexpr MaybeValueStorage(U in_value) requires(
        meta::is_convertible_v<U, T>) {
        this->value = in_value;
        this->has_some = true;
    }

    // If other assignment operators are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    auto operator=(T const& in_value) -> MaybeValueStorage& requires(
        meta::is_trivially_copy_assignable_v<T>) {
        this->value = in_value;
        this->has_some = true;
        return *this;
    }
    auto operator=(T const& in_value) -> MaybeValueStorage& = delete;

    auto operator=(T&& in_value) -> MaybeValueStorage& requires(
        meta::is_trivially_move_assignable_v<T>) {
        this->value = meta::move(in_value);
        this->has_some = true;
        return *this;
    }
    auto operator=(T&& in_value) -> MaybeValueStorage& = delete;

    // If `T` is not trivially copy assignable, then manually construct it
    // in-place.
    auto operator=(T const& in_value) -> MaybeValueStorage& requires(
        meta::is_copy_assignable_v<T> &&
        !meta::is_trivially_copy_assignable_v<T>) {
        this->assign(in_value);
        return *this;
    }

    // If `T` is not trivially move assignable, then manually invoke
    // `meta::move()` on it.
    constexpr auto operator=(T&& in_value) -> MaybeValueStorage& requires(
        meta::is_move_assignable_v<T> &&
        !meta::is_trivially_move_assignable_v<T>) {
        this->assign(meta::move(in_value));
        return *this;
    }

    // Assigning `none` will destroy the held value.
    auto operator=(cat::detail::None) -> MaybeValueStorage& {
        if (this->has_some) {
            this->value.~T();
            this->has_some = false;
        }
        return *this;
    }

    // If `T`, or a type that is convertible to `T`, is assigned to this,
    // then replace a potentially held value.
    template <typename U = T>
    auto operator=(U&& in_value)
        -> MaybeValueStorage<T>& requires(meta::is_convertible_v<U, T>) {
        if (this->has_value()) {
            this->value = meta::forward<U>(in_value);
            this->has_some = true;
        } else {
            this->construct(meta::forward<U>(in_value));
        }
        return *this;
    }

    // If a `MaybeValueStorage` is assigned to this which wraps a type that can
    // be converted, then convert that `MaybeValueStorage` to this type
    // implicitly.
    template <typename U>
    auto operator=(MaybeValueStorage<U> const& maybe)
        -> MaybeValueStorage<T>& requires(meta::is_convertible_v<U, T>) {
        if (this->has_some) {
            if (maybe.has_value()) {
                this->value = *maybe;
            } else {
                this->value.~T();
                this->has_some = false;
            }
        }
        if (maybe.has_value()) {
            this->construct(*maybe);
        }
        return *this;
    }

    constexpr auto get_value() & -> T& {
        return this->value;
    }
    constexpr auto get_value() const& -> T const& {
        return this->value;
    }
    constexpr auto get_value() && -> T&& {
        return meta::move(this->value);
    }

    constexpr auto has_value() const -> bool1 {
        return has_some;
    }

    // Construct an object at the address of the held `value`.
    // TODO: Factor into `cat::construct_at()`.
    template <typename... Args>
    void construct(Args&&... args) {
        // TODO: Get this working.
        // new (cat::address_of(this->value)) T(meta::forward<Args>(args)...);
        this->value = T(meta::forward<Args>(args)...);
        this->has_some = true;
    }

    template <typename U>
    constexpr void assign(U&& maybe) {
        if (this->has_value()) {
            if (maybe.has_value()) {
                this->value = meta::forward<U>(maybe).get_value();
            } else {
                this->value.~T();
                this->has_some = false;
            }
        } else if (maybe.has_value()) {
            this->construct(meta::forward<U>(maybe).get_value());
        }
    }
};

template <typename T>
struct MaybeReferenceStorage {
    using ValueType = meta::remove_reference_t<T>;
    ValueType* p_value = nullptr;
  public:
    // TODO: Handle non-trivial constructors and assignment operators.

    constexpr MaybeReferenceStorage(ValueType& in_value) requires(
        meta::is_default_constructible<ValueType>::value)
        : p_value(cat::address_of(in_value)){};

    constexpr MaybeReferenceStorage(ValueType const& in_value)
        : p_value(cat::address_of(in_value)){};

    // template <typename U = ValueType>
    // constexpr MaybeReferenceStorage(U&& in_value)
    //     : p_value(cat::address_of(in_value)){};

    // constexpr MaybeReferenceStorage(ValueType& maybe) requires(
    //     meta::is_reference_v<ValueType>)
    //     : p_value(cat::address_of(maybe)){};

    constexpr MaybeReferenceStorage(cat::detail::None) : p_value(nullptr){};

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(ValueType& maybe) -> MaybeReferenceStorage<T>& {
        this->p_value = cat::address_of(maybe);
        return *this;
    }

    constexpr auto operator=(ValueType const& maybe)
        -> MaybeReferenceStorage<T>& {
        this->p_value = cat::address_of((maybe));
        return *this;
    };

    // Invalidate the reference if this is assigned `none`.
    constexpr auto operator=(cat::detail::None) -> MaybeReferenceStorage<T>& {
        this->p_value = nullptr;
        return *this;
    }

    constexpr auto get_value() & -> ValueType& {
        return this->p_value;
    }
    constexpr auto get_value() const& -> ValueType& {
        return this->p_value;
    }
    constexpr auto get_value() && -> ValueType&& {
        return meta::move(this->p_value);
    }
    constexpr auto get_value() const&& -> ValueType&& {
        return meta::move(this->p_value);
    }

    constexpr auto has_value() const -> bool1 {
        return this->p_value != nullptr;
    }
};

template <typename T>
class Maybe {
    using StorageType =
        meta::conditional_t<meta::is_reference_v<T>, MaybeReferenceStorage<T>,
                            MaybeValueStorage<T>>;
    StorageType storage;
  public:
    // Default-initialization is not supported.
    Maybe() = delete;

    // Forward all constructors to `storage`.

    // If this is a reference storage, allow consuming a non-`const` reference.
    Maybe(auto input) requires(
        meta::is_same_v<StorageType, MaybeReferenceStorage<T>>&& meta::
            is_default_constructible<typename StorageType::ValueType>::value)
        : storage(input){};

    // A reference type cannot be copy-constructed.
    Maybe(auto const& input) requires(
        !meta::is_same_v<StorageType, MaybeReferenceStorage<T>> &&
        meta::is_copy_constructible_v<typename StorageType::ValueType>)
        : storage(input){};

    template <typename U>
    Maybe(U&& input) requires(meta::is_move_constructible_v<StorageType>)
        : storage(meta::forward<U>(input)){};

    // Forward all assignment operators to `storage`.
    auto operator=(auto const& value) {
        this->storage = value;
        return *this;
    }

    auto operator=(auto const& value) const {
        this->storage = value;
        return *this;
    }

    auto operator=(auto&& value) && {
        this->storage = meta::move(value);
        return meta::move(*this);
    }

    auto operator=(auto&& value) const&& {
        this->storage = meta::move(value);
        return meta::move(*this);
    }

    constexpr auto has_value() const -> bool1 {
        return this->storage.has_value();
    }

    // TODO: Support move semantics.
    // Get the held `value` unconditionally. If `has_value()` is `false`, this
    // data is undefined. If this method is used in `-O0`, it will panic in that
    // case, unless used in a `constexpr` context.
    constexpr auto value() -> T const& {
        if (meta::is_constant_evaluated()) {
            return this->storage.get_value();
        }
#ifdef __OPTIMIZE__
        return this->storage.get_value();
#else
        if (this->storage.has_value()) {
            return this->storage.get_value();
        }
        cat::print(
            "`.has_value()` was illegally called on a `Maybe` which did not hold\
a value!\n")
            .assert();
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    constexpr auto value_or(
        typename StorageType::ValueType const fallback) & -> T {
        if (this->storage.has_value()) {
            return this->storage.get_value();
        }
        return fallback;
    }

    constexpr auto value_or(StorageType const fallback) const& -> T {
        if (this->storage.has_value()) {
            return this->storage.get_value();
        }
        return fallback;
    }

    constexpr auto value_or(StorageType&& fallback) && -> T&& {
        if (this->storage.has_value()) {
            return meta::forward<StorageType>(this->storage.get_value());
        }
        return meta::forward<StorageType>(fallback);
    }

    // Monadic methods:

    // TODO: Support callbacks for `.transform()` that return `void`.
    // TODO: Use a `meta::invocable` `concept`.

    // If this non-`const`-qualified `Maybe` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) & {
        if (this->storage.has_value()) {
            return Maybe<T>(
                meta::forward<Function>(callback)(this->storage.get_value()));
        }
        return *this;
    }

    // If this `const`-qualified `Maybe` holds a value, transform it by a
    // non-`void` function without side-effects. Otherwise, propagate an empty
    // `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const& {
        if (this->storage.has_value()) {
            return Maybe<T>(
                meta::forward<Function>(callback(this->storage.get_value())));
        }
        return *this;
    }

    // If this non-`const`-qualified `Maybe` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) && {
        if (this->storage.has_value()) {
            return Maybe<T>(meta::forward<Function>(
                callback(meta::move(this->storage.get_value()))));
        }
        return *this;
    }

    // If this `const`-qualified `Maybe` holds a value, transform it by a
    // non-`void` function without side-effects. Otherwise, propagate an empty
    // `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const&& {
        if (this->storage.has_value()) {
            return Maybe<T>(meta::forward<Function>(
                callback(meta::move(this->storage.get_value()))));
        }
        return *this;
    }

    // Invoke a callback on the value of a non-`const`-qualified `Maybe` that
    // potentially mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) & {
        return this->has_value() ? Maybe<T>(meta::forward<Function>(callback)(
                                       this->storage.get_value()))
                                 : *this;
    }

    // Invoke a callback on the value of a `const`-qualified `Maybe`, and
    // propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const& {
        return this->has_value() ? Maybe<T>(meta::forward<Function>(callback)(
                                       this->storage.get_value()))
                                 : *this;
    }

    // Invoke a callback on the value of a non-`const`-qualified `Maybe` that
    // potentially mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) && {
        return this->has_value() ? Maybe<T>(meta::forward<Function>(callback)(
                                       meta::move(this->storage.get_value())))
                                 : meta::move(*this);
    }

    template <typename Function>
    constexpr auto or_else(Function&& callback) & {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    template <typename Function>
    constexpr auto or_else(Function&& callback) const& {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    template <typename Function>
    constexpr auto or_else(Function&& callback) && {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return meta::move(*this);
    }

    // Construct the value in-place and destroy the held value iff it exists.
    template <typename... Args>
    auto emplace(Args&&... args) -> T& {
        *this = none;
        this->storage.construct(meta::forward<Args>(args)...);
        return this->storage.get_value();
    }
};

template <typename T, auto predicate, T sentinel>
class Maybe<Predicate<T, predicate, sentinel>> {
    T storage = sentinel;
  public:
    Maybe() = delete;
    ~Maybe() = default;

    template <typename U = T>
    constexpr Maybe(U& value) requires(!predicate(sentinel) &&
                                       (meta::is_same_v<U, T> ||
                                        meta::is_convertible_v<U, T>))
        : storage(value){};

    template <typename U = T>
    constexpr Maybe(U const& value) requires(!predicate(sentinel) &&
                                             (meta::is_same_v<U, T> ||
                                              meta::is_convertible_v<U, T>))
        : storage(value){};

    template <typename U = T>
    constexpr Maybe(U&& value) requires(!predicate(sentinel) &&
                                        (meta::is_same_v<U, T> ||
                                         meta::is_convertible_v<U, T>))
        : storage(meta::move(value)){};

    template <typename U = T>
    constexpr Maybe(U const&& value) requires(!predicate(sentinel) &&
                                              (meta::is_same_v<U, T> ||
                                               meta::is_convertible_v<U, T>))
        : storage(meta::move(value)){};

    constexpr Maybe(cat::detail::None) : storage(sentinel){};

    // Forward assignment operators to `storage`:
    constexpr auto operator=(auto& input) {
        this->storage = input;
        return *this;
    }

    constexpr auto operator=(auto const& input) {
        this->storage = input;
        return *this;
    }

    constexpr auto operator=(auto&& input) {
        this->storage = meta::move(input);
        return *this;
    }

    constexpr auto operator=(auto const&& input) {
        this->storage = meta::move(input);
        return *this;
    }

    // Specify the unusual `none` assignment operator.
    constexpr auto operator=(cat::detail::None) {
        this->storage = sentinel;
        return *this;
    }

    // TODO: Support move semantics.
    // Get the held `value` unconditionally. If `has_value()` is `false`, this
    // data is undefined. If this method is used in `-O0`, it will panic in that
    // case, unless used in a `constexpr` context.
    constexpr auto value() -> T const& {
        if (meta::is_constant_evaluated()) {
            return this->storage;
        }
#ifdef __OPTIMIZE__
        return this->storage;
#else
        if (this->has_value()) {
            return this->storage;
        }
        cat::print(
            "`.has_value()` was illegally called on a `Maybe` which did not hold\
a value!\n")
            .assert();
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    constexpr auto value_or(T const fallback) const& -> T& {
        if (this->has_value()) {
            return this->storage;
        }
        return fallback;
    }

    constexpr auto value_or(T const&& fallback) && -> T&& {
        if (this->has_value()) {
            return meta::move(this->storage);
        }
        return meta::move(fallback);
    }

    // Monadic methods:

    // TODO: Support callbacks for `.transform()` that return `void`.
    // TODO: Use a `meta::invocable` `concept`.

    // If this non-`const` `Maybe` holds a value, transform it by a non-`void`
    // function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) & {
        if (this->has_value()) {
            return Maybe<Predicate<T, predicate, sentinel>>(callback(
                meta::forward<Maybe<Predicate<T, predicate, sentinel>>>(*this)
                    .storage));
        }
        return Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // If this `const` `Maybe` holds a value, transform it by a non-`void`
    // function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const& {
        if (this->has_value()) {
            return Maybe<Predicate<T, predicate, sentinel>>(callback(
                meta::forward<Maybe<Predicate<T, predicate, sentinel>>>(*this)
                    .storage));
        }
        return Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // If this non-`const` `Maybe` holds a value, transform it by a
    // non -`void` function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) && {
        if (this->has_value()) {
            return Maybe<Predicate<T, predicate, sentinel>>(callback(meta::move(
                meta::forward<Maybe<Predicate<T, predicate, sentinel>>>(*this)
                    .storage)));
        }
        return Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // If this `const` `Maybe` holds a value, transform it by a non-`void`
    // function. Otherwise, propagate an empty `Maybe`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const&& {
        if (this->has_value()) {
            return Maybe<Predicate<T, predicate, sentinel>>(callback(meta::move(
                meta::forward<Maybe<Predicate<T, predicate, sentinel>>>(*this)
                    .storage)));
        }
        return Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // Invoke a callback on the value of a non-`const` `Maybe` that potentially
    // mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) & {
        return this->has_value()
                   ? Maybe<Predicate<T, predicate, sentinel>>(
                         callback(this->storage))
                   : Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // Invoke a callback on the value of a `const` `Maybe`, and propagate the
    // result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const& {
        return this->has_value()
                   ? Maybe<Predicate<T, predicate, sentinel>>(
                         callback(this->storage))
                   : Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // Invoke a callback on the value of a non-`const` `Maybe` that potentially
    // mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) && {
        return this->has_value()
                   ? Maybe<Predicate<T, predicate, sentinel>>(
                         callback(meta::move(this->storage)))
                   : Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    // Invoke a callback on the value of a `const` `Maybe`, and propagate the
    // result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const&& {
        return this->has_value()
                   ? Maybe<Predicate<T, predicate, sentinel>>(
                         callback(meta::move(this->storage)))
                   : Maybe<Predicate<T, predicate, sentinel>>(none);
    }

    template <typename Function>
    constexpr auto or_else(
        Function&& callback) & -> Maybe<Predicate<T, predicate, sentinel>> {
        if (!this->has_value()) {
            callback();
        }
        return *this;
    }

    template <typename Function>
    constexpr auto or_else(Function&& callback)
        const& -> Maybe<Predicate<T, predicate, sentinel>> {
        if (!this->has_value()) {
            callback();
        }
        return *this;
    }

    template <typename Function>
    constexpr auto or_else(
        Function&& callback) && -> Maybe<Predicate<T, predicate, sentinel>> {
        if (!this->has_value()) {
            callback();
        }
        return meta::move(*this);
    }

    template <typename Function>
    constexpr auto or_else(Function&& callback)
        const&& -> Maybe<Predicate<T, predicate, sentinel>> {
        if (!this->has_value()) {
            callback();
        }
        return meta::move(*this);
    }

    constexpr auto has_value() const -> bool1 {
        return predicate(this->storage);
    }
};
