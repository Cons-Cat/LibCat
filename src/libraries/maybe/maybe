// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <memory>
#include <string>
#include <type_traits>
#include <utility>

namespace std::detail {

// A `None` is consumed by a `Maybe` constructor to prevent initializing its
// `value` member.
struct None {};

// A `Monostate` represents a `Maybe` that holds no `value`.
struct Monostate {};

}  // namespace std::detail

inline constexpr std::detail::None none;

template <typename T, T sentinel>
struct Sentinel {};

template <typename T, auto predicate, T sentinel>
struct Predicate {};

// template <typename...>
// class Maybe;

template <typename T>
class Maybe {
    struct Dummy {};
    union {
        // `Dummy` is required so that `Maybe` can be initialized in a
        // `constexpr` context, because a member union must have at least
        // one initialized field, and it should not be `value`.
        Dummy dummy;
        T value;
    };
    bool1 has_some = false;

    // `Maybe`'s constructors, assignment operators, and destructors are
    // relatively complex. Consider paying special attention to them.
  public:
    // If constructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    // constexpr Maybe() requires(meta::is_default_constructible<T>::value)
    // =
    //     default;
    // constexpr Maybe() = delete;
    constexpr Maybe() = default;
    constexpr Maybe(std::detail::None){};

    constexpr Maybe(Maybe const& maybe) requires(
        meta::is_copy_constructible_v<T>) = default;
    constexpr Maybe(Maybe const& maybe) = delete;
    constexpr Maybe(Maybe&& maybe) requires(meta::is_move_constructible_v<T>) =
        default;
    constexpr Maybe(Maybe&& maybe) = default;

    // If other destructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    constexpr ~Maybe() = default;

    // If `T` is not trivially copy constructible, then manually construct it
    // in-place.
    constexpr Maybe(Maybe const& maybe) requires(
        meta::is_trivially_copy_constructible_v<T> &&
        !meta::is_trivially_copy_constructible_v<T>) {
        if (maybe.has_value()) {
            this->construct(maybe.get_value());
        } else {
            this->has_some = false;
        }
    }

    // If `T` is not trivially move constructible, then manually invoke
    // `meta::move` on it.
    Maybe(Maybe&& maybe) requires(meta::is_move_constructible_v<T> &&
                                  !meta::is_trivially_move_constructible_v<T>) {
        if (maybe.has_value()) {
            this->construct(meta::move(maybe.get_value()));
        } else {
            this->has_some = false;
        }
    }

    // If `T` is not trivially destructible, then manually invoke its
    // destructor.
    constexpr ~Maybe() requires(!meta::is_trivially_destructible_v<T>) {
        if (this->has_some) {
            this->value.~T();
        }
    }

    // TODO: Handle non-trivial `U`.
    // If a `Maybe` consumes a `T` or a type that is convertible to `T`, it
    // should be constructed.
    template <typename U = T>
    constexpr Maybe(U in_value) requires(meta::is_same_v<U, T> ||
                                         meta::is_convertible_v<U, T>) {
        this->value = in_value;
        this->has_some = true;
    }

    // If other assignment operators are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    auto operator=(Maybe const& maybe)
        -> Maybe& requires(meta::is_copy_assignable_v<T>) = default;
    auto operator=(Maybe const& maybe) -> Maybe& = delete;

    auto operator=(Maybe&& maybe)
        -> Maybe& requires(meta::is_move_assignable_v<T>) = default;
    auto operator=(Maybe&& maybe) -> Maybe& = delete;

    // If `T` is not trivially copy assignable, then manually construct it
    // in-place.
    auto operator=(Maybe const& maybe)
        -> Maybe& requires(meta::is_copy_assignable_v<T> &&
                           !meta::is_trivially_copy_assignable_v<T>) {
        this->assign(maybe);
        return *this;
    }

    // If `T` is not trivially move assignable, then manually invoke
    // `meta::move()` on it.
    constexpr auto operator=(Maybe&& maybe)
        -> Maybe& requires(meta::is_move_assignable_v<T> &&
                           !meta::is_trivially_move_assignable_v<T>) {
        this->assign(meta::move(maybe));
        return *this;
    }

    // Assigning `none` will destroy the held value.
    auto operator=(std::detail::None) -> Maybe& {
        if (this->has_some) {
            this->value.~T();
            this->has_some = false;
        }
        return *this;
    }

    // If `T`, or a type that is convertible to `T`, is assigned to this,
    // then replace a potentially held value.
    template <typename U = T>
    auto operator=(U&& in_value)
        -> Maybe<T>& requires(meta::is_same_v<U, T> ||
                              meta::is_convertible_v<U, T>) {
        if (this->has_value()) {
            this->value = meta::forward<U>(in_value);
        } else {
            this->construct(meta::forward<U>(in_value));
        }
        return *this;
    }

    // If a `Maybe` is assigned to this which wraps a type that can be
    // converted, then convert that `Maybe` to this type implicitly.
    template <typename U>
    auto operator=(Maybe<U> const& maybe)
        -> Maybe<T>& requires(meta::is_convertible_v<U, T>) {
        if (this->has_some) {
            if (maybe.has_value()) {
                this->value = *maybe;
            } else {
                this->value.~T();
                this->has_some = false;
            }
        }
        if (maybe.has_value()) {
            this->construct(*maybe);
        }
        return *this;
    }

    // Get the held `value` unconditionally. If `has_value()` is `false`, this
    // data is undefined. If this method is used in `-O0`, it will panic in that
    // case, unless used in a `constexpr` context.
    constexpr auto unwrap() -> T {
        if (meta::is_constant_evaluated()) {
            return this->get_value();
        }
#ifdef __OPTIMIZE__
        return this->get_value();
#else
        if (this->has_value()) {
            return this->get_value();
        }
        std::print(
            "`.unwrap()` was illegally called on a `Maybe` which did not hold a \
value!\n")
            .or_panic_debug();
        std::exit(1);
#endif
        __builtin_unreachable();
    }

    // Construct the value in-place and destroy the held value iff it exists.
    template <typename... Args>
    auto emplace(Args&&... args) -> T& {
        *this = none;
        this->construct(meta::forward<Args>(args)...);
        return this->value;
    }

    constexpr auto has_value() const -> bool1 {
        return this->has_some;
    }

    // Internal helper functions:
  protected:
    // Construct an object at the address of the held `value`.
    // TODO: Factor into `std::construct_at()`.
    template <typename... Args>
    void construct(Args&&... args) {
        // TODO: Get this working.
        // new (std::address_of(this->value)) T(meta::forward<Args>(args)...);
        this->value = T(meta::forward<Args>(args)...);
        this->has_some = true;
    }

    constexpr auto get_value() & -> T& {
        return this->value;
    }
    constexpr auto get_value() const& -> T const& {
        return this->value;
    }
    constexpr auto get_value() && -> T&& {
        return meta::move(this->value);
    }
    constexpr auto get_value() const&& -> T&& {
        return meta::move(this->value);
    }

    template <typename U>
    constexpr void assign(U&& maybe) {
        if (this->has_value()) {
            if (maybe.has_value()) {
                this->value = meta::forward<U>(maybe).get_value();
            } else {
                this->value.~T();
                this->has_some = false;
            }
        } else if (maybe.has_value()) {
            this->construct(meta::forward<U>(maybe).get_value());
        }
    }
};

// The only way to support a maybe-reference in C++20 is with a partial
// template specialization.
template <typename T>
class Maybe<T&> {
    T* p_value = nullptr;
  public:
    Maybe() = default;
    ~Maybe() = default;

    template <typename U = T>
    constexpr Maybe(U&& in_value) : p_value(std::address_of(in_value)){};

    template <typename U>
    constexpr explicit Maybe(Maybe<U> const& maybe)
        : p_value(maybe.get_value()){};

    constexpr Maybe(T& maybe) requires(meta::is_reference_v<T>)
        : p_value(std::address_of(maybe)){};

    constexpr Maybe(std::detail::None) : p_value(nullptr){};

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(T& maybe) -> T& {
        this->value = std::address_of(maybe);
        return *this;
    }

    constexpr auto operator=(Maybe const& maybe) -> Maybe<T&>& = default;

    // Invalidate the reference if this is assigned `none`.
    constexpr auto operator=(std::detail::None) -> Maybe<T&>& {
        this->p_value = nullptr;
        return *this;
    }

    constexpr auto unwrap() -> T& {
        if (meta::is_constant_evaluated()) {
            return *(this->p_value);
        }
#ifdef __OPTIMIZE__
        return *(this->p_value);
#else
        if (this->has_value()) {
            return *(this->p_value);
        }
        std::print(
            "`.unwrap()` was illegally called on a `Maybe` which did not hold a \
value!\n")
            .or_panic_debug();
        std::exit(1);
#endif
    }

    constexpr auto has_value() const -> bool1 {
        return this->p_value != nullptr;
    }
};

template <typename T, T sentinel>
class Maybe<Sentinel<T, sentinel>> {
    T value = sentinel;
  public:
    Maybe() = default;
    ~Maybe() = default;

    template <typename U = T>
    constexpr Maybe(U&& in_value) requires(meta::is_same_v<U, T> ||
                                           meta::is_convertible_v<U, T>)
        : value(in_value){};

    template <typename U>
    constexpr explicit Maybe(Maybe<Sentinel<U, sentinel>> const& maybe)
        : value(maybe.get_value()){};

    constexpr Maybe(T& maybe) requires(meta::is_reference_v<T>)
        : value(std::address_of(maybe)){};

    constexpr Maybe(std::detail::None) : value(sentinel){};

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(T& maybe) -> T& {
        this->value = std::address_of(maybe);
        return *this;
    }

    constexpr auto operator=(Maybe const& maybe)
        -> Maybe<Sentinel<T, sentinel>>& = default;

    // Invalidate the reference if this is assigned `none`.
    constexpr auto operator=(std::detail::None)
        -> Maybe<Sentinel<T, sentinel>>& {
        this->value = sentinel;
        return *this;
    }

    constexpr auto unwrap() -> T& {
        if (meta::is_constant_evaluated()) {
            return *(this->value);
        }
#ifdef __OPTIMIZE__
        return *(this->value);
#else
        if (this->has_value()) {
            return *(this->value);
        }
        std::print(
            "`.unwrap()` was illegally called on a `Maybe` which did not hold a \
value!\n")
            .or_panic_debug();
        std::exit(1);
#endif
    }

    constexpr auto has_value() const -> bool1 {
        return this->value != sentinel;
    }
};

template <typename T, auto predicate, T sentinel>
class Maybe<Predicate<T, predicate, sentinel>> {
    T value = sentinel;
  public:
    Maybe() requires(!predicate(sentinel)) = default;
    ~Maybe() = default;

    template <typename U = T>
    constexpr Maybe(U&& in_value) requires(!predicate(sentinel) &&
                                           (meta::is_same_v<U, T> ||
                                            meta::is_convertible_v<U, T>))
        : value(in_value){};

    template <typename U>
    constexpr explicit Maybe(Maybe<Predicate<U, predicate, sentinel>> const&
                                 maybe) requires(!predicate(sentinel))
        : value(maybe.get_value()){};

    constexpr Maybe(T& maybe) requires(!predicate(sentinel) &&
                                       meta::is_reference_v<T>)
        : value(std::address_of(maybe)){};

    constexpr Maybe(std::detail::None) requires(!predicate(sentinel))
        : value(sentinel){};

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(T& maybe) -> T& {
        this->value = std::address_of(maybe);
        return *this;
    }

    constexpr auto operator=(Maybe const& maybe)
        -> Maybe<Predicate<T, predicate, sentinel>>& = default;

    // Invalidate the reference if this is assigned `none`.
    constexpr auto operator=(std::detail::None)
        -> Maybe<Predicate<T, predicate, sentinel>>& {
        this->value = sentinel;
        return *this;
    }

    constexpr auto unwrap() -> T& {
        if (meta::is_constant_evaluated()) {
            return *(this->value);
        }
#ifdef __OPTIMIZE__
        return *(this->value);
#else
        if (this->has_value()) {
            return *(this->value);
        }
        std::print(
            "`.unwrap()` was illegally called on a `Maybe` which did not hold a \
value!\n")
            .or_panic_debug();
        std::exit(1);
#endif
    }

    constexpr auto has_value() const -> bool1 {
        return predicate(this->value);
    }
};
