// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/allocators>
#include <cat/linux>

namespace cat {

class PageAllocator : public AllocatorFacade<PageAllocator> {
    friend AllocatorFacade<PageAllocator>;
    static constexpr bool has_pointer_stability = true;

    template <typename T>
    struct PageMemoryHandle : BaseMemoryHandle<T> {
        // This inherits:
        // `T* p_storage;`
        ssize allocation_size;
    };

    // Allocate memory in multiples of a page-size. A page is `4_ki` large
    // on x86-64. If fewer than 4096 bytes are allocated, that amount will
    // be rounded up to 4096.
    template <typename T>
    auto allocate(ssize allocation_size) -> OptionalPtr<T> {
        Scaredy result = nix::sys_mmap(
            0u, allocation_size,
            // TODO: Fix bit flags operators.
            static_cast<nix::MemoryProtectionFlags>(
                static_cast<unsigned int>(nix::MemoryProtectionFlags::read) |
                static_cast<unsigned int>(nix::MemoryProtectionFlags::write)),
            static_cast<nix::MemoryFlags>(
                static_cast<unsigned int>(nix::MemoryFlags::privately) |
                static_cast<unsigned int>(nix::MemoryFlags::populate) |
                static_cast<unsigned int>(nix::MemoryFlags::anonymous)),
            // Anonymous pages (non-files) must have `-1`.
            nix::FileDescriptor{-1},
            // Anonymous pages (non-files) must have `0`.
            0);
        if (result.has_value()) {
            return reinterpret_cast<T*>(static_cast<void*>(result.value()));
        }
        return nullptr;
    }

    // TODO: Use a `MemoryHandle` `concept`.
    // Unmap an opaque handle to page(s) of virtual memory.
    void deallocate(auto const& memory) {
        // There are some cases where `munmap` might fail even with private
        // anonymous pages. These currently cannot be handled, because `.free()`
        // does not propagate errors.
        _ = nix::sys_munmap(memory.p_storage, memory.allocation_size);
    };

    // Unmap a pointer handle to page(s) of virtual memory.
    template <typename T>
    void deallocate(T* p_memory) {
        // There are some cases where `munmap` might fail even with private
        // anonymous pages. These currently cannot be handled, because `.free()`
        // does not propagate errors.
        _ = nix::sys_munmap(p_memory, ssizeof<T>());
    };

    // Allocate a page(s) of virtual memory that is guaranteed to align to
    // any power of two, less than `4_ki`.
    template <typename T>
    auto aligned_allocate(usize alignment, ssize allocation_size)
        -> OptionalPtr<T> {
        Result(alignment <= 4_uki).assert();
        // A normal page allocation already has these semantics.
        return this->allocate<T>(allocation_size);
    }

    // TODO: Why `auto`?
    // Produce a handle to allocated memory.
    template <typename T>
    auto make_handle(auto data, ssize size) -> PageMemoryHandle<T> {
        return PageMemoryHandle<T>{{data}, size};
    }

    // Access a page(s) of virtual memory.
    template <typename T>
    auto access(PageMemoryHandle<T> const& memory) -> T* {
        return memory.p_storage;
    }
};

}  // namespace cat
