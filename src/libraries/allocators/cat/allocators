// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/bit>
#include <cat/span>
#include <cat/tuple>

namespace cat {

template <typename T>
concept MemoryHandle = requires(T handle) {
    handle.is_inline_handle;
    handle.is_multi_handle;
    handle.size();
    handle.raw_size();
    handle.is_inline();
};

namespace detail {
    // `BaseMemoryHandle` is an opaque memory handle. Allocators are to define
    // and produce a memory handle type which derives from this. These handles
    // contain absolutely arbitrary storage (such as a `T*`, or an `ssize`
    // address offset). Handles must provide a `.get()` method to return
    // whatever that storage is.
    template <typename T>
    struct BaseMemoryHandle {
        static constexpr bool is_inline_handle = false;
        static constexpr bool is_multi_handle = false;
        using Type = T;

        // Number of `T`s allocated. This is always 1 if the call is not
        // intercepted by a `MultiMemoryHandle`.
        constexpr auto size() const -> ssize {
            return 1;
        }

        // Number of bytes allocated. This is always the size of `T` if the call
        // is not intercepted by a `MultiMemoryHandle`.
        constexpr auto raw_size() const -> ssize {
            return ssizeof<T>();
        }

        // `is_inline()` always holds false if the call is not intercepted by an
        // `InlineMemoryHandle`.
        constexpr auto is_inline() const -> bool {
            return false;
        }
    };

    // A `MultiMemoryHandle` wraps another memory handle for `*_multi`
    // allocations. It effectively overrides `Handle`'s `.size()` and
    // `.raw_size()` methods with the length of an allocated array.
    template <typename Handle>
    struct MultiMemoryHandle {
        static constexpr bool is_inline_handle = Handle::is_inline_handle;
        static constexpr bool is_multi_handle = true;
        using Type = typename Handle::Type;
        Handle handle;

        // How large this allocation was, in terms of `Type`.
        ssize array_length;

        MultiMemoryHandle() = default;

        MultiMemoryHandle(Handle input_handle) : handle(input_handle){};

        // TODO: Variadic emplace.
        void set_inline_storage(Type value) {
            this->handle.set_inline_storage(value);
        }

        void set_on_stack(bool inlined) {
            this->handle.set_on_stack(inlined);
        }

        // Intercept a propagating call to `.set_count()`.
        void set_count(ssize count) {
            this->array_length = count;
        }

        // Intercept a propagating call to `.size()`.
        auto size() const -> ssize {
            return this->array_length;
        }

        // Intercept a propagating call to `.raw_size()`.
        auto raw_size() const -> ssize {
            return this->array_length * ssizeof<Type>();
        }

        constexpr auto is_inline() const -> bool {
            return this->handle.is_inline();
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        auto get_inline() & -> Type& {
            return this->handle.get_inline();
        }

        auto get_inline() const& -> Type const& {
            return this->handle.get_inline();
        }
    };

    constexpr ssize inline_buffer_size = 256;

    // An `InlineMemoryHandle` wraps another memory handle for `inline_*`
    // allocations. It extends the storage of this handle to at least 256 bytes,
    // and if the memory allocated is smaller than that, it is stored inside the
    // handle instead of inside an allocator. It effectively overrides the
    // `.is_inline()` method of the handle that it wraps.
    template <typename Handle>
    struct InlineMemoryHandle {
        static constexpr bool is_inline_handle = true;
        static constexpr bool is_multi_handle = Handle::is_multi_handle;
        using Type = typename Handle::Type;

        union {
            Handle handle;
            Type inline_storage;
            // Reserve `inline_buffer_size` bytes to make the size
            // of this handle predictible.
            Byte empty[inline_buffer_size.raw];
        };
        bool is_on_stack;

        // The default constructor must not initialize data.
        InlineMemoryHandle(){};

        InlineMemoryHandle(Handle input_handle)
            : handle(input_handle), is_on_stack(false){};

        ~InlineMemoryHandle() {
            if (this->is_on_stack) {
                this->inline_storage.~Type();
            }
        }

        // Intercept a propagating call to `.set_inline_storage()`.
        // TODO: Variadic emplace.
        void set_inline_storage(Type value) {
            this->inline_storage = value;
        }

        // Intercept a propagating call to `.set_on_stack()`.
        void set_on_stack(bool inlined) {
            this->is_on_stack = inlined;
        }

        void set_count(ssize count) {
            this->handle.set_count(count);
        }

        auto size() const -> ssize {
            return handle.size();
        }

        auto raw_size() const -> ssize {
            return handle.raw_size();
        }

        constexpr auto is_inline() const -> bool {
            return this->is_on_stack;
        }

        // Get the allocator-specific handle type.
        auto get() & -> decltype(auto) {
            return this->handle.get();
        }

        // Get the allocator-specific handle type.
        auto get() const& -> decltype(auto) {
            return this->handle.get();
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() & -> Type& {
            return this->inline_storage;
        }

        // Intercept calls to `.get_inline()`.
        auto get_inline() const& -> Type const& {
            return this->inline_storage;
        }
    };
}  // namespace detail

template <typename AllocatorT, typename AllocationU = void*>
concept Allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.alloc()` method.
    allocator.template alloc<AllocationU>();

    // TODO: It would be nice if these could make the concept more precise:
    // allocator.free(decltype(allocator.template make_handle<AllocationU>(
    //     AllocationU{}, sizeof(AllocationU))){});
    // allocator.get(decltype(allocator.template make_handle<AllocationU>(
    //     AllocationU{}, sizeof(AllocationU))){});
};

namespace detail {
    // `clangd` emits false-positive diagnostics if this constraint is used
    // anonymously without a `concept`.
    template <typename AllocatorT>
    concept StableDerivedAllocator = AllocatorT::has_pointer_stability == true;

    template <typename T>
    concept HasReset = requires(T allocator) {
        allocator.reset();
    };
}  // namespace detail

template <typename AllocatorT, typename AllocationU = void*>
concept StableAllocator = requires(AllocatorT it) {
    it.template p_alloc<AllocationU>();
};

template <typename Derived>
class AllocatorFacade {
    constexpr auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    // Take a pointer to another member function, then invoke it, and propagate
    // the address of memory that it allocated.
    template <typename T, typename... Args>
    auto p_wrap_allocation(auto function, Args&&... arguments)
        -> OptionalPtr<T> {
        return (this->*function)(forward<Args>(arguments)...);
    }

  public:
    template <typename T, bool is_inline, bool is_fail_safe, bool is_aligned,
              bool is_multiple, bool is_pointer, bool is_zeroed = false,
              typename... Args>
        requires(
            // Inline allocations cannot produce pointers.
            !(is_inline && is_pointer) &&
            // Multi-allocations cannot construct with arguments.
            (!is_multiple || (sizeof...(Args) == 0)) &&
            // Allocations can only be zeroed if `T` is trivial.
            (!is_trivial<T> || !is_zeroed) &&
            // Allocations can only be zeroed if they are default-constructed.
            !(is_zeroed && sizeof...(Args) > 0))
    auto meta_alloc(usize allocation_alignment, ssize allocation_count,
                    Args&&... constructor_arguments) {
        ssize const allocation_size = allocation_count * ssizeof<T>();

        // Produce a basic handle for this memory type.
        using UnderlyingHandle =
            decltype(this->self().template make_handle<T>(declval<T*>()));

        // Get the return value of a user-supplied `.allocate()`. This must be
        // some kind of `Optional`. It holds some data that can pass into a
        // `Handle`'s constructor.
        // TODO: Call `allocate_aligned(1)` if `.allocate()` is not supplied.
        using MaybeAllocation =
            decltype(this->self().allocate(allocation_size));

        // Produce an appropriate handle type for this allocation.
        using Handle = Conditional<
            is_multiple,
            detail::MultiMemoryHandle<Conditional<
                is_inline,
                // If this an array of small-size optimized `T`:
                detail::InlineMemoryHandle<UnderlyingHandle>,
                // If this is an array of not small-size optimized `T`:
                UnderlyingHandle>>,
            Conditional<is_inline,
                        // If this a small-size optimized `T`:
                        detail::InlineMemoryHandle<UnderlyingHandle>,
                        // If this is not a small-size optimized `T`:
                        UnderlyingHandle>>;

        if constexpr (is_inline) {
            if (allocation_size < detail::inline_buffer_size) {
                // TODO: Support and test `inline_alloc_multi` constructors.
                // Allocate memory on this stack frame.
                T stack_memory = {forward<Args>(constructor_arguments)...};

                if constexpr (is_zeroed) {
                    zero_memory(addressof(stack_memory), allocation_size);
                }

                Handle stack_handle;
                stack_handle.set_on_stack(true);
                stack_handle.set_inline_storage(stack_memory);

                // Return here to skip error handling, because an on-stack
                // allocation cannot fail.
                if constexpr (is_fail_safe) {
                    return Optional<Handle>{stack_handle};
                } else {
                    return stack_handle;
                }
            }
        }

        // If this allocation is not small-size optimized, or is larger than
        // `inline_buffer_size`:

        // Make an allocation.
        MaybeAllocation maybe_memory;
        if constexpr (is_aligned) {
            maybe_memory = this->self().aligned_allocate(allocation_alignment,
                                                         allocation_size);
        } else {
            maybe_memory = this->self().allocate(allocation_size);
        }

        if constexpr (is_fail_safe) {
            if (!maybe_memory.has_value()) {
                // Return an empty optional if this failed to allocate.
                if constexpr (is_pointer) {
                    return OptionalPtr<T>{nullptr};
                } else {
                    return Optional<Handle>{nullopt};
                }
            }
        }

        T* const p_allocation = static_cast<T*>(maybe_memory.value());

        if constexpr (is_zeroed) {
            zero_memory(p_allocation, allocation_size);
        } else {
            // Construct the `T`s inside the allocator.
            for (ssize i = 0; i < allocation_count; ++i) {
                new (p_allocation + i)
                    T(forward<Args>(constructor_arguments)...);
            }
        }

        if constexpr (is_pointer) {
            return OptionalPtr<T>{p_allocation};
        } else {
            UnderlyingHandle const raw_handle =
                this->self().template make_handle<T>(p_allocation);

            Handle handle{raw_handle};
            if constexpr (is_inline) {
                handle.set_on_stack(false);
            }

            if constexpr (is_multiple) {
                handle.set_count(allocation_count);
            }

            if constexpr (is_fail_safe) {
                return Optional<Handle>{handle};
            } else {
                return handle;
            }
        }
    }

    // Try to allocate a `T`.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto alloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc<T, is_pointer, is_zeroed>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_alloc<T, is_pointer, is_zeroed>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a `T`.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto xalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc<T, is_pointer, is_zeroed>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this->unalign_xalloc<T, is_pointer, is_zeroed>(
                forward<Args>(constructor_arguments)...);
        }
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_alloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::alloc<T, true, is_zeroed, Args...>,
            forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xalloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::xalloc<T, true, is_zeroed, Args...>,
            forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T`.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_alloc_multi<T, is_pointer, is_zeroed>(alignof(T),
                                                                     count);
        } else {
            return this->unalign_alloc_multi<T, is_pointer, is_zeroed>(count);
        }
    }

    // Allocate an array of `T`.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->align_xalloc_multi<T, is_pointer, is_zeroed>(
                alignof(T), count);
        } else {
            return this->unalign_xalloc_multi<T, is_pointer, is_zeroed>(count);
        }
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and provide a pointer handle.
    template <typename T, bool is_zeroed = false>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_alloc_multi(ssize count) -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::alloc_multi<T, true, is_zeroed>, count);
    }

    // If this allocator has pointer stability, allocate an array of `T`, and
    // provide a pointer handle.
    template <typename T, bool is_zeroed = false>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xalloc_multi(ssize count) -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::xalloc_multi<T, true, is_zeroed>, count);
    }

    // Try to allocate a `T` with an alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto align_alloc(usize alignment,
                                   Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, true, false, is_pointer, is_zeroed>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // Allocate a `T` with an alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto align_xalloc(usize alignment,
                                    Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, true, false, is_pointer, is_zeroed>(
                alignment, 1, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_alloc(usize alignment,
                                     Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::align_alloc<T, true, is_zeroed, Args...>,
            alignment, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xalloc(usize alignment,
                                      Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::align_xalloc<T, true, is_zeroed,
                                                    Args...>,
            alignment, forward<Args>(constructor_arguments)...);
        // TODO: `assert` the alignment is correct.
    }

    // Try to allocate a `T` with no alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto unalign_alloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, true, false, false, is_pointer, is_zeroed>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a `T` with no alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto unalign_xalloc(Args&&... constructor_arguments) {
        return this
            ->meta_alloc<T, false, false, false, false, is_pointer, is_zeroed>(
                1u, 1, forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_alloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::unalign_alloc<T, true, is_zeroed,
                                                     Args...>,
            forward<Args>(constructor_arguments)...);
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xalloc(Args&&... constructor_arguments)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::unalign_xalloc<T, true, is_zeroed,
                                                      Args...>,
            forward<Args>(constructor_arguments)...);
    }

    // Try to allocate an array of `T` with alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto align_alloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, true, true, true, is_pointer, is_zeroed>(
                alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // Allocate an array of `T` with an alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto align_xalloc_multi(usize alignment, ssize count) {
        return this
            ->meta_alloc<T, false, false, true, true, is_pointer, is_zeroed>(
                alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_alloc_multi(usize alignment, ssize count)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::align_alloc_multi<T, true, is_zeroed>,
            alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with an alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xalloc_multi(usize alignment, ssize count)
        -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::align_xalloc_multi<T, true, is_zeroed>,
            alignment, count);
        // TODO: `assert` the alignment is correct.
    }

    // Try to allocate an array of `T` with no alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto unalign_alloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, true, false, true, is_pointer, is_zeroed>(
                1u, count);
    }

    // Allocate an array of `T` with no alignment guarantee.
    template <typename T, bool is_pointer = false, bool is_zeroed = false>
    [[nodiscard]] auto unalign_xalloc_multi(ssize count) {
        return this
            ->meta_alloc<T, false, false, false, true, is_pointer, is_zeroed>(
                1u, count);
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_alloc_multi(ssize count) -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::unalign_alloc_multi<T, true, is_zeroed>,
            count);
    }

    // If this allocator has pointer stability, allocate an array of `T`
    // with no alignment guarantee, and provide a pointer handle.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xalloc_multi(ssize count) -> OptionalPtr<T> {
        return this->p_wrap_allocation<T>(
            &AllocatorFacade<Derived>::unalign_xalloc_multi<T, true, is_zeroed>,
            count);
    }

    // Try to allocate a small-size optimized `T`.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_alloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc<T, is_zeroed>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this
                ->meta_alloc<T, true, true, false, false, false, is_zeroed>(
                    1u, 1, forward<Args>(constructor_arguments)...);
        }
    }

    // Allocate a small-size optimized `T`.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_xalloc(Args&&... constructor_arguments) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc<T, is_zeroed>(
                alignof(T), forward<Args>(constructor_arguments)...);
        } else {
            return this
                ->meta_alloc<T, true, false, false, false, false, is_zeroed>(
                    1u, 1, forward<Args>(constructor_arguments)...);
        }
    }

    // Try to allocate a small-size optimized array of `T`.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_alloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_alloc_multi<T, is_zeroed>(alignof(T),
                                                                count);
        } else {
            return this
                ->meta_alloc<T, true, true, false, true, false, is_zeroed>(
                    1u, count);
        }
    }

    // Allocate a small-size optimized array of `T`.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_xalloc_multi(ssize count) {
        if constexpr (alignof(T) > 1) {
            // If the alignment of `T` is greater than 1, it should have
            // implied strong alignment guarantees.
            return this->inline_align_xalloc_multi<T, is_zeroed>(alignof(T),
                                                                 count);
        } else {
            return this
                ->meta_alloc<T, true, false, false, true, false, is_zeroed>(
                    1u, count);
        }
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_alloc(usize alignment,
                                          Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, true, false, false, is_zeroed>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with an alignment guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_xalloc(usize alignment,
                                           Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, false, true, false, false, is_zeroed>(
            alignment, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_alloc(Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, true, false, false, false, is_zeroed>(
            1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Allocate a small-size optimized `T` with no alignment guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_xalloc(Args&&... constructor_arguments) {
        return this->meta_alloc<T, true, false, false, false, false, is_zeroed>(
            1u, 1, forward<Args>(constructor_arguments)...);
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_alloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, true, true, true, true, false, is_zeroed>(
            alignment, count);
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_xalloc_multi(usize alignment, ssize count) {
        return this->meta_alloc<T, true, false, true, true, false, is_zeroed>(
            alignment, count);
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_alloc_multi(ssize count) {
        return this->meta_alloc<T, true, true, false, true, false, is_zeroed>(
            1u, count);
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_xalloc_multi(ssize count) {
        return this->meta_alloc<T, true, false, false, true, false, is_zeroed>(
            1u, count);
    }

    // Try to get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] auto nalloc() -> OptionalNonZero<ssize> {
        return this->align_nalloc<T>(alignof(T));
    }

    // Get the number of bytes that allocating a `T` would reserve.
    template <typename T>
    [[nodiscard]] auto xnalloc() -> ssize {
        return this->align_xnalloc<T>(alignof(T)).value();
    }

    // Try to get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] auto nalloc_multi(ssize count) -> OptionalNonZero<ssize> {
        return this->align_nalloc_multi<T>(alignof(T), count);
    }

    // Get the number of bytes that allocating an array of `T` would
    // reserve.
    template <typename T>
    [[nodiscard]] auto xnalloc_multi(ssize count) -> ssize {
        return this->align_nalloc_multi<T>(alignof(T), count).value();
    }

    // Try to get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_nalloc(usize alignment) -> OptionalNonZero<ssize> {
        return this->self().allocation_size(alignment, ssizeof<T>());
    }

    // Get the number of bytes that allocating a `T` with an alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_xnalloc(usize alignment) -> ssize {
        return this->self().allocation_size(alignment, ssizeof<T>()).value();
    }

    // Try to get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_nalloc() -> OptionalNonZero<ssize> {
        return this->self().allocation_size(1u, ssizeof<T>());
    }

    // Get the number of bytes that allocating a `T` with no alignment
    // guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_xnalloc() -> ssize {
        return this->self().allocation_size(1u, ssizeof<T>()).value();
    }

    // Try to get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_nalloc_multi(usize alignment, ssize count)
        -> OptionalNonZero<ssize> {
        return this->self().allocation_size(alignment, ssizeof<T>() * count);
    }

    // Get the number of bytes that allocating an array of `T` with an
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto align_xnalloc_multi(usize alignment, ssize count)
        -> ssize {
        return this->self()
            .allocation_size(alignment, ssizeof<T>() * count)
            .value();
    }

    // Try to get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        return this->self().allocation_size(1u, ssizeof<T>() * count);
    }

    // Get the number of bytes that allocating an array of `T` with no
    // alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto unalign_xnalloc_multi(ssize count) -> ssize {
        return this->self().allocation_size(1u, ssizeof<T>() * count).value();
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] auto inline_nalloc() -> OptionalNonZero<ssize> {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->inline_align_nalloc<T>(alignof(T));
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T`
    // would reserve.
    template <typename T>
    [[nodiscard]] auto inline_xnalloc() -> ssize {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->inline_align_xnalloc<T>(alignof(T)).value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` would reserve.
    template <typename T>
    [[nodiscard]] auto inline_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->inline_align_nalloc_multi<T>(alignof(T), count);
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized array of
    // `T` would reserve.
    template <typename T>
    [[nodiscard]] auto inline_xnalloc_multi(ssize count) -> ssize {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->inline_align_xnalloc_multi<T>(alignof(T), count)
                .value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_nalloc(usize alignment)
        -> OptionalNonZero<ssize> {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->self().allocation_size(alignment, ssizeof<T>());
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_xnalloc(usize alignment) -> ssize {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->self()
                .allocation_size(alignment, ssizeof<T>())
                .value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to get the number of bytes that allocating a small-size optimized `T`
    // with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_nalloc() -> OptionalNonZero<ssize> {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->self().allocation_size(1u, ssizeof<T>());
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized `T` with
    // no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xnalloc() -> ssize {
        if constexpr (ssizeof<T>() > detail::inline_buffer_size) {
            return this->self().allocation_size(1u, ssizeof<T>()).value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_nalloc_multi(usize alignment, ssize count)
        -> OptionalNonZero<ssize> {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->self().allocation_size(alignment,
                                                ssizeof<T>() * count);
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with an alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_align_xnalloc_multi(usize alignment, ssize count)
        -> ssize {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->self()
                .allocation_size(alignment, ssizeof<T>() * count)
                .value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_nalloc_multi(ssize count)
        -> OptionalNonZero<ssize> {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->self().allocation_size(1u, ssizeof<T>() * count);
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Get the number of bytes that allocating a small-size optimized
    // array of `T` with no alignment guarantee would reserve.
    template <typename T>
    [[nodiscard]] auto inline_unalign_xnalloc_multi(ssize count) -> ssize {
        if (ssizeof<T>() * count > detail::inline_buffer_size) {
            return this->self()
                .allocation_size(1u, ssizeof<T>() * count)
                .value();
        } else {
            return detail::inline_buffer_size;
        }
    }

    // Try to allocate a `T`, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto salloc(Args&&... constructor_arguments) {
        ssize size = this->nalloc<T>().value();
        auto allocation =
            this->alloc<T, is_zeroed>(forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a `T`, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto xsalloc(Args&&... constructor_arguments) {
        ssize size = this->xnalloc<T>();
        auto allocation =
            this->xalloc<T, is_zeroed>(forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate a `T`, and
    // return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_salloc(Args&&... constructor_arguments) {
        ssize size = this->nalloc<T>().value();
        Optional p_allocation = this->p_alloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate a `T`, and
    // return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xsalloc(Args&&... constructor_arguments) {
        ssize size = this->xnalloc<T>();
        T* p_allocation = this->p_xalloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate an array of `T`, and return the number of bytes that was
    // allocated.
    template <typename T, bool is_pointer, bool is_zeroed = false>
    [[nodiscard]] auto salloc_multi(ssize count) {
        ssize size = this->nalloc_multi<T>(count).value();
        auto allocation = this->alloc_multi<T, is_pointer, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Allocate an array of `T`, and return the number of bytes that was
    // allocated.
    template <typename T, bool is_pointer, bool is_zeroed>
    [[nodiscard]] auto xsalloc_multi(ssize count) {
        ssize size = this->xnalloc_multi<T>(count);
        auto allocation = this->xalloc_multi<T, is_pointer, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate an array of `T`,
    // and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_salloc_multi(ssize count,
                                      Args&&... constructor_arguments) {
        ssize size = this->nalloc_multi<T>(count).value();
        Optional p_allocation = this->p_alloc_multi<T, is_zeroed>(
            forward<Args>(count, constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate an array of `T`,
    // and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_xsalloc_multi(ssize count,
                                       Args&&... constructor_arguments) {
        ssize size = this->xnalloc_multi<T>(count);
        T* p_allocation = p_xalloc_multi<T, is_zeroed>(
            forward<Args>(count, constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate a `T` with an alignment guarantee, and return the number
    // of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto align_salloc(usize alignment,
                                    Args&&... constructor_arguments) {
        ssize size = this->align_nalloc<T>(alignment).value();
        auto allocation = this->align_alloc<T, is_pointer, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a `T` with an alignment guarantee, and return the number of
    // bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto align_xsalloc(usize alignment,
                                     Args&&... constructor_arguments) {
        ssize size = this->align_xnalloc<T>(alignment);
        auto allocation = this->align_xalloc<T, is_pointer, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate a `T` with an
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_salloc(usize alignment,
                                      Args&&... constructor_arguments) {
        ssize size = this->align_nalloc<T>(alignment).value();
        Optional p_allocation = this->p_align_alloc<T, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate a `T` with an
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xsalloc(usize alignment,
                                       Args&&... constructor_arguments) {
        ssize size = this->align_xnalloc<T>(alignment);
        T* p_allocation = this->p_align_xalloc<T, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate a `T` with no alignment guarantee, and return the number
    // of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto unalign_salloc(Args&&... constructor_arguments) {
        ssize size = this->unalign_nalloc<T>().value();
        auto allocation = this->unalign_alloc<T, is_pointer, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a `T` with no alignment guarantee, and return the number of
    // bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed = false,
              typename... Args>
    [[nodiscard]] auto unalign_xsalloc(Args&&... constructor_arguments) {
        ssize size = this->unalign_xnalloc<T>();
        auto allocation = this->unalign_xalloc<T, is_pointer, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate a `T` with no
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_salloc(Args&&... constructor_arguments) {
        ssize size = this->unalign_nalloc<T>().value();
        Optional p_allocation = this->p_unalign_alloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate a `T` with no
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xsalloc(Args&&... constructor_arguments) {
        ssize size = this->unalign_xnalloc<T>();
        T* p_allocation = this->p_unalign_xalloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed>
    [[nodiscard]] auto align_salloc_multi(usize alignment, ssize count) {
        ssize size = this->align_nalloc_multi<T>(alignment, count).value();
        auto allocation =
            this->align_alloc_multi<T, is_pointer, is_zeroed>(alignment, count);
        return Tuple{allocation, size};
    }

    // Allocate an array of `T` with an alignment guarantee, and return
    // the number of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed>
    [[nodiscard]] auto align_xsalloc_multi(usize alignment, ssize count) {
        ssize size = this->align_xnalloc_multi<T>(alignment, count);
        auto allocation = this->align_xalloc_multi<T, is_pointer, is_zeroed>(
            alignment, count);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with an alignment guarantee, and return the number of bytes that was
    // allocated.
    template <typename T, bool is_zeroed>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_salloc_multi(usize alignment, ssize count) {
        ssize size = this->align_nalloc_multi<T>(alignment, count).value();
        Optional p_allocation =
            this->p_align_alloc_multi<T, is_zeroed>(alignment, count);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate an array of `T` with an
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_align_xsalloc_multi(usize alignment, ssize count) {
        ssize size = this->align_xnalloc_multi<T>(alignment, count);
        T* p_allocation =
            this->p_align_xalloc_multi<T, is_zeroed>(alignment, count);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed>
    [[nodiscard]] auto unalign_salloc_multi(ssize count) {
        ssize size = this->unalign_nalloc_multi<T>(count).value();
        auto allocation =
            this->align_alloc_multi<T, is_pointer, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Allocate an array of `T` with no alignment guarantee, and return
    // the number of bytes that was allocated.
    template <typename T, bool is_pointer, bool is_zeroed>
    [[nodiscard]] auto unalign_xsalloc_multi(ssize count) {
        ssize size = this->unalign_xnalloc_multi<T>(count);
        auto allocation =
            this->unalign_xalloc_multi<T, is_pointer, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // If this allocator has pointer stability, try to allocate an array of `T`
    // with no alignment guarantee, and return the number of bytes that was
    // allocated.
    template <typename T, bool is_zeroed>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_salloc_multi(ssize count) {
        ssize size = this->unalign_nalloc_multi<T>(count).value();
        Optional p_allocation =
            this->p_unalign_alloc_multi<T, is_zeroed>(count);
        return Tuple{p_allocation, size.raw};
    }

    // If this allocator has pointer stability, allocate an array of `T` with no
    // alignment guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
        requires(detail::StableDerivedAllocator<Derived>)
    [[nodiscard]] auto p_unalign_xsalloc_multi(
        ssize count, Args&&... constructor_arguments) {
        ssize size = this->unalign_xnalloc_multi<T>(count);
        T* p_allocation = this->p_unalign_xalloc_multi<T, is_zeroed>(
            count, forward<Args>(constructor_arguments)...);
        return Tuple{p_allocation, size.raw};
    }

    // Try to allocate a small-size optimized `T`, and return the number of
    // bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_salloc(Args&&... constructor_arguments) {
        ssize size = this->inline_nalloc<T>().value();
        auto allocation = this->inline_alloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized `T`, and return the number of bytes that
    // was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_xsalloc(Args&&... constructor_arguments) {
        ssize size = this->inline_xnalloc<T>();
        auto allocation = this->inline_xalloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Try to allocate a small-size optimized array of `T`, and return the
    // number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_salloc_multi(ssize count) {
        ssize size = this->inline_nalloc_multi<T>(count).value();
        auto allocation = this->inline_alloc_multi<T, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized array of `T`, and return the number of
    // bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_xsalloc_multi(ssize count) {
        ssize size = this->inline_xnalloc_multi<T>(count);
        auto allocation = this->inline_xalloc_multi<T, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Try to allocate a small-size optimized `T` with an alignment guarantee,
    // and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_salloc(usize alignment,
                                           Args&&... constructor_arguments) {
        ssize size = this->inline_align_nalloc<T>(alignment).value();
        auto allocation = this->inline_align_alloc<T, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized `T` with an alignment guarantee, and
    // return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_align_xsalloc(usize alignment,
                                            Args&&... constructor_arguments) {
        ssize size = this->inline_align_xnalloc<T>(alignment);
        auto allocation = this->inline_align_xalloc<T, is_zeroed>(
            alignment, forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Try to allocate a small-size optimized `T` with no alignment guarantee,
    // and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_salloc(Args&&... constructor_arguments) {
        ssize size = this->inline_unalign_nalloc<T>().value();
        auto allocation = this->inline_unalign_alloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized `T` with no alignment guarantee, and
    // return the number of bytes that was allocated.
    template <typename T, bool is_zeroed = false, typename... Args>
    [[nodiscard]] auto inline_unalign_xsalloc(Args&&... constructor_arguments) {
        ssize size = this->inline_unalign_xnalloc<T>();
        auto allocation = this->inline_unalign_xalloc<T, is_zeroed>(
            forward<Args>(constructor_arguments)...);
        return Tuple{allocation, size};
    }

    // Try to allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed>
    [[nodiscard]] auto inline_align_salloc_multi(usize alignment, ssize count) {
        ssize size =
            this->inline_align_nalloc_multi<T>(alignment, count).value();
        auto allocation =
            this->inline_align_alloc_multi<T, is_zeroed>(alignment, count);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized array of `T` with an alignment
    // guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed>
    [[nodiscard]] auto inline_align_xsalloc_multi(usize alignment,
                                                  ssize count) {
        ssize size = this->inline_align_xnalloc_multi<T>(alignment, count);
        auto allocation =
            this->inline_align_xalloc_multi<T, is_zeroed>(alignment, count);
        return Tuple{allocation, size};
    }

    // Try to allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed>
    [[nodiscard]] auto inline_unalign_salloc_multi(ssize count) {
        ssize size = this->inline_unalign_nalloc_multi<T>(count).value();
        auto allocation = this->inline_unalign_alloc_multi<T, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Allocate a small-size optimized array of `T` with no alignment
    // guarantee, and return the number of bytes that was allocated.
    template <typename T, bool is_zeroed>
    [[nodiscard]] auto inline_unalign_xsalloc_multi(ssize count) {
        ssize size = this->inline_unalign_xnalloc_multi<T>(count);
        auto allocation =
            this->inline_unalign_xalloc_multi<T, is_zeroed>(count);
        return Tuple{allocation, size};
    }

    // Invalidate any memory handle, invoking its data's destructor.
    template <MemoryHandle T>
    void free(T const& handle) {
        using Type = typename T::Type const;

        // If this is not a small-size optimized handle:
        if (!handle.is_inline()) {
            Type const* p_memory;
            if constexpr (T::is_multi_handle) {
                // Get the pointer from a span produced by the
                // allocator.
                p_memory = this->get(handle).p_data();
            } else {
                // Get the pointer from the allocator.
                p_memory = addressof(this->get(handle));
            }

            // if constexpr (is_destructible<Type>) {
            for (ssize i = 0; i < handle.size(); ++i) {
                p_memory[i.raw].~Type();
            }
            // }
            this->self().deallocate(static_cast<void const*>(p_memory),
                                    handle.raw_size());
        }
        // If this is not small-size optimized, it will be freed at the
        // end of the stack frame, so this function call is no-op.
    };

    // TODO: This needs unit tests.
    // Invalidate a pointer handle to a `T`, and call its destructor.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    void free(T* p_memory) {
        // if constexpr (is_destructible<T>) {
        p_memory->~T();
        // }
        this->self().deallocate(static_cast<void const*>(p_memory),
                                ssizeof<T>());
    }

    // Invalidate a pointer handle to an array of `T`, and call its
    // destructors.
    template <typename T>
        requires(detail::StableDerivedAllocator<Derived>)
    void free_multi(T* p_memory, ssize count) {
        // if constexpr (is_destructible<T>) {
        for (ssize i = 0; i < count; ++i) {
            p_memory[i.raw].~T();
        }
        // }
        this->self().deallocate(static_cast<void const*>(p_memory),
                                ssizeof<T>() * count);
    }

    // Get a non-`const` reference to the data in any memory handle.
    template <MemoryHandle T>
    [[nodiscard]] auto get(T& handle) & -> decltype(auto) {
        using Type = typename T::Type;
        if constexpr (T::is_inline_handle) {
            // Get small-size optimized data:
            if (handle.is_inline()) {
                if constexpr (T::is_multi_handle) {
                    return Span<Type>{addressof(handle.get_inline()),
                                      handle.size()};
                } else {
                    return handle.get_inline();
                }
            }
        }

        // Get non-small-size optimized data:
        if constexpr (T::is_multi_handle) {
            return Span<Type>(this->self().template access<Type>(handle.get()),
                              handle.size());
        } else {
            return *(this->self().template access<Type>(handle.get()));
        }
    }

    // Get a `const` reference to the data in any memory handle.
    template <MemoryHandle T>
    [[nodiscard]] auto get(T const& memory) & -> decltype(auto) {
        return unconst(this)->get(unconst(memory));
    }

    // If the allocator does not provide a `.reset()` method, produce a
    // no-op.
    void reset() requires(!detail::HasReset<Derived>) {
    }
};

}  // namespace cat
