// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <memory>
#include <optional>
#include <type_traits>

// TODO: Some allocators should be iterable.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `cat::destructable` is not useful without exception handling. */

namespace cat {

struct BaseMemoryHandle {
    union {
        void* p_storage;
        ssize storage;
    };

    constexpr explicit operator void*() const {
        return this->p_storage;
    }
};

template <typename T>
struct BaseSmallMemoryHandle : T {
    bool1 is_on_stack;
    BaseSmallMemoryHandle(auto* p_memory, ssize size, bool1 stack)
        : T{{p_memory}, size}, is_on_stack(stack){};
    BaseSmallMemoryHandle(T, bool1 stack) : T(), is_on_stack(stack){};
};

namespace detail {
    template <typename T>
    struct PageMemoryHandle : public BaseMemoryHandle {
        ssize allocation_size;
    };
}  // namespace detail

}  // namespace cat

namespace meta {

template <typename AllocatorT, typename AllocationU = void*>
concept Allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.malloc()`, `.free()`, and `.get()` method.
    // TODO: Handle non-arbitrary allocation sizes.
    allocator.malloc(sizeof(AllocationU));
    allocator.template malloc<AllocationU>();
    allocator.free(typename AllocatorT::template Handle<AllocationU>{});
    allocator.get(typename AllocatorT::template Handle<AllocationU>{});
};

}  // namespace meta

namespace cat {

struct PageAllocator {
    template <typename T>
    using Handle = cat::detail::PageMemoryHandle<T>;
    template <typename T>
    using SmallHandle = BaseSmallMemoryHandle<Handle<T>>;

    /* Allocate memory in multiples of a page-size,
     * which is `4_ki` on x86-64. For instance, If fewer that `4096` bytes
     * are allocated, that amount will be rounded up to `4096`. There is
     * generally very little reason to allocate any smaller amount of bytes
     * using `PageAllocator`. */
    template <typename T = void*>
    auto malloc(ssize const allocation_size = sizeof(T))
        -> Optional<Handle<T>> {
        Result<void*> memory = nix::map_memory(
            0u, allocation_size,
            nix::MemoryProtectionFlags::read |
                nix::MemoryProtectionFlags::write,
            nix::MemoryFlags::privately | nix::MemoryFlags::populate |
                nix::MemoryFlags::anonymous,
            // Anonymous pages must have `-1`.
            -1,
            // Anonymous pages must have `0u`.
            0u);

        if (memory.is_okay) {
            return Handle<T>{{memory.value()}, allocation_size};
        }
        return none;
    }

    // Unmap a handle to page(s) of virtual memory.
    // TODO: Use an `Optional<void>`.
    template <typename T>
    auto free(T const& memory) -> Result<>
    // Taking a `Handle<T>` parameter accepts `SmallHandle<T>`, which is
    // incorrect.
    requires(meta::is_specialization<T, Handle>::value) {
        return nix::unmap_memory(memory.p_storage, memory.allocation_size);
    };

    template <typename T = void*>
    auto malloca(ssize const allocation_size = sizeof(T))
        -> Optional<SmallHandle<T>> {
        if (allocation_size > 256) {
            // TODO: Fix `.transform()`, and use it here.
            bool1 failed = false;
            Handle<T> handle = this->malloc<T>(allocation_size)
                                   .or_else([&]() {
                                       failed = true;
                                   })
                                   .value();
            if (failed) {
                return none;
            }
            return SmallHandle<T>{handle, false};
        }

        return SmallHandle<T>{
            static_cast<T*>(__builtin_alloca(allocation_size)), allocation_size,
            true};
    }

    // Unmap a handle to page(s) of virtual memory or stack-allocated memory.
    // TODO: Use an `Optional<void>`.
    template <typename T>
    auto freea(SmallHandle<T> const& memory) -> Result<> {
        if (memory.is_on_stack) {
            return okay;
        }
        // Small memory handles can only add members to the basic handle, so
        // bit-casting them is safe.
        return this->free(meta::bit_cast<Handle<T>>(memory));
    };

    // Acquire a reference to a page of memory.
    template <typename T>
    auto get(Handle<T> const& memory) -> T& {
        return *static_cast<T*>(memory.p_storage);
    }
};

struct FixedBufferAllocator {
    //
};

}  // namespace cat
