// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <memory>
#include <type_traits>

// TODO: Some allocators should be iterable.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `cat::destructable` is not useful without exception handling. */

namespace cat {

struct BaseMemoryHandle {
    union {
        void* p_storage;
        ssize storage;
    };

    constexpr explicit operator void*() const {
        return this->p_storage;
    }
};

namespace detail {

    template <typename T>
    struct PageMemoryHandle : public BaseMemoryHandle {
        ssize allocation_size;
    };

}  // namespace detail

}  // namespace cat

namespace meta {

template <typename AllocatorT, typename AllocationU = void*>
concept Allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.malloc()`, `.free()`, and `.get()` method.
    // TODO: Handle non-arbitrary allocation sizes.
    allocator.malloc(sizeof(AllocationU));
    allocator.template malloc<AllocationU>();
    allocator.free(typename AllocatorT::template Handle<AllocationU>{});
    allocator.get(typename AllocatorT::template Handle<AllocationU>{});
};

}  // namespace meta

namespace cat {

struct PageAllocator {
    template <typename T>
    using Handle = cat::detail::PageMemoryHandle<T>;

    /* Allocate memory in multiples of a page-size,
     * which is `4_ki` on x86-64. For instance, If fewer that `4096` bytes
     * are allocated, that amount will be rounded up to `4096`. There is
     * generally very little reason to allocate any smaller amount of bytes
     * using `PageAllocator`. */
    template <typename T = void*>
    auto malloc(ssize const allocation_size = sizeof(T)) -> Result<Handle<T>> {
        return nix::map_memory(0u, allocation_size,
                               nix::MemoryProtectionFlags::read |
                                   nix::MemoryProtectionFlags::write,
                               nix::MemoryFlags::privately |
                                   nix::MemoryFlags::populate |
                                   nix::MemoryFlags::anonymous,
                               // Anonymous pages must have `-1`.
                               -1,
                               // Anonymous pages must have `0u`.
                               0u)
            .transform<Handle<T>>([=](void* p_value) {
                return Handle<T>{{p_value}, allocation_size};
            });
    }

    template <typename T>
    auto free(Handle<T> const& memory) -> Result<> {
        return nix::unmap_memory(memory.p_storage, memory.allocation_size);
    };

    template <typename T>
    auto get(Handle<T> const& memory) -> T& {
        return *static_cast<T*>(memory.p_storage);
    }
};

}  // namespace cat
