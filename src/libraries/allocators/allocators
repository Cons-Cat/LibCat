// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <memory>
#include <type_traits>

// TODO: Some allocators should be iterable.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `cat::destructable` is not useful without exception handling. */

namespace cat {

struct BaseMemoryHandle {
    union {
        void* p_storage;
        ssize storage;
    };

    constexpr auto as_address() const -> void* {
        return this->p_storage;
    }

    constexpr auto as_index() const -> ssize {
        return storage;
    }

    constexpr explicit operator void*() const {
        return this->p_storage;
    }
};

namespace detail {

    template <typename T>
    struct PageMemoryHandle : public BaseMemoryHandle {
        ssize size;

        constexpr auto get() const -> T& {
            return *static_cast<T*>(p_storage);
        }
    };

}  // namespace detail

}  // namespace cat

namespace meta {

template <typename AllocatorT, typename AllocationU = void*>
concept Allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.malloc()` and `.free()` method.
    // TODO: Handle non-arbitrary allocation sizes.
    allocator.malloc(sizeof(AllocationU));
    allocator.template malloc<AllocationU>();
    allocator.free(typename AllocatorT::template Handle<AllocationU>{});
};

}  // namespace meta

namespace cat {

struct PageAllocator {
    template <typename T>
    using Handle = cat::detail::PageMemoryHandle<T>;

    /* Allocate memory in multiples of a page-size,
     * which is `4` KiB on x86-64. For instance, If fewer that `4096u` bytes are
     * allocated, that amount will be rounded up to `4096u`. There is generally
     * very little reason to allocate any smaller amount of bytes using
     * `PageAllocator`. */
    template <typename T = void*>
    auto malloc(ssize allocation_size = sizeof(T))
        -> Result<detail::PageMemoryHandle<T>> {
        return nix::map_memory(0u, allocation_size,
                               nix::MemoryProtectionFlags::read |
                                   nix::MemoryProtectionFlags::write,
                               nix::MemoryFlags::privately |
                                   nix::MemoryFlags::populate |
                                   nix::MemoryFlags::anonymous,
                               // Anonymous pages must have `-1`.
                               -1,
                               // Anonymous pages must have `0u`.
                               0u)
            .transform<detail::PageMemoryHandle<T>>([=](void* p_value) {
                return detail::PageMemoryHandle<T>{{p_value}, allocation_size};
            });
    }

    template <typename T>
    auto free(T memory) -> Result<>
    requires(meta::is_specialization<T, detail::PageMemoryHandle>::value) {
        return nix::unmap_memory(memory.as_address(), memory.size);
    };
};

}  // namespace cat
