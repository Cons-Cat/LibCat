// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <type_traits>

// TODO: This does not work correctly.
template <typename T>
concept allocator = requires(T allocator, isize input) {
    // Allocators hold an enum for failure codes named `failures`.
    meta::is_enum_v<typename T::failures>;
    allocator.failures;

    /* Allocators hold a `malloc()` method which takes a generic type and
     * returns a `Result<void*>` address to the allocated memory. */
    { allocator.template malloc() } -> meta::convertible_to<Result<void*>>;

    /* Allocators should have a `free()` method which takes no parameters, and
     * returns void. This shall be used to free all of its allocated memory. */
    { allocator.free() };

    // TODO: `delete_at()` should only be in `random_access_allocator`s.
    /* Allocators hold a `delete_at()` which takes an `isize` and returns a
     * `Result<void>`. */
    // { allocator.delete_at(input) } -> meta::convertible_to<Result<>>;
};

// TODO: Allocators should be iterables.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `std::destructable` is not useful without exception handling. */

struct PageAllocator {
    void* address = nullptr;

    enum failures
    {};

    /* Allocate memory in multiples of a page-size,
     * which is `4` KiB on x86-64. For instance, If fewer that `4096u` bytes are
     * allocated, that amount will be rounded up to `4096u`. There is generally
     * very little reason to allocate any other amount of bytes with
     * `PageAllocator`. */
    auto malloc(usize bytes) -> Result<void*> {
        this->address =
            nix::mmap(0u, bytes, ::PROT_READ | ::PROT_WRITE,
                      ::MAP_PRIVATE | ::MAP_POPULATE | ::MAP_ANONYMOUS,
                      // Anonymous pages must have `-1`.
                      -1,
                      // Anonymous pages must have `0u`.
                      0ull)
                .or_is(nullptr);
        // TODO: This is quite inefficient. Consider failure-propagation.
        if (this->address == nullptr) {
            return Failure(1);
        }
        return this->address;
    }

    // TODO: `munmap()` here.
    void free(){};

    // NOLINTNEXTLINE
    auto operator[](isize byte_index) -> uint8& {
        return reinterpret_cast<uint8*>(address)[byte_index];
    }
};
