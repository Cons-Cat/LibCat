// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <memory>
#include <type_traits>

#include "any"

// TODO: This does not work correctly.
template <typename T>
concept allocator = requires(T allocator, ssize input) {
    // Allocators hold an enum for failure codes named `failures`.
    meta::is_enum_v<typename T::failures>;
    allocator.failures;

    /* Allocators hold a `malloc()` method which takes a generic type and
     * returns a `Result<void*>` address to the allocated memory. */
    { allocator.template malloc() } -> meta::convertible_to<Result<void*>>;

    /* Allocators should have a `free()` method which takes no parameters, and
     * returns void. This shall be used to free all of its allocated memory. */
    {allocator.free()};

    // TODO: `delete_at()` should only be in `random_access_allocator`s.
    /* Allocators hold a `delete_at()` which takes an `isize` and returns a
     * `Result<void>`. */
    // { allocator.delete_at(input) } -> meta::convertible_to<Result<>>;
};

// TODO: Allocators should be iterables.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `cat::destructable` is not useful without exception handling. */

struct MemoryHandle {
    union {
        void* p_storage;
        ssize storage;
    } value;

    constexpr MemoryHandle() = default;

    constexpr MemoryHandle(decltype(nullptr)) {
        this->value.p_storage = nullptr;
    }

    template <typename T>
    constexpr MemoryHandle(T* p_value) {
        this->value.p_storage = meta::forward<T*>(p_value);
    }

    constexpr auto as_address() const -> void* {
        return this->value.p_storage;
    }

    constexpr auto as_index() const -> ssize {
        return value.storage;
    }

    constexpr explicit operator void*() const {
        return this->value.p_storage;
    }
};

struct PageAllocator {
    void* address = nullptr;

    // TODO: Think about this.
    enum failures {
    };

    /* Allocate memory in multiples of a page-size,
     * which is `4` KiB on x86-64. For instance, If fewer that `4096u` bytes are
     * allocated, that amount will be rounded up to `4096u`. There is generally
     * very little reason to allocate any smaller amount of bytes using
     * `PageAllocator`. */
    auto malloc(ssize allocation_size) -> Result<MemoryHandle> {
        this->address = nix::map_memory(0u, allocation_size,
                                        nix::MmapProtectionFlags::read |
                                            nix::MmapProtectionFlags::write,
                                        nix::MmapMemoryFlags::privately |
                                            nix::MmapMemoryFlags::populate |
                                            nix::MmapMemoryFlags::anonymous,
                                        // Anonymous pages must have `-1`.
                                        -1,
                                        // Anonymous pages must have `0u`.
                                        0u)
                            .value_or(nullptr);
        // TODO: This is quite inefficient. Consider failure-propagation.
        if (this->address == nullptr) {
            return Failure(1);
        }
        return MemoryHandle{this->address};
    }

    // TODO: `munmap()` here.
    void free(){};

    // NOLINTNEXTLINE TODO: Why no lint?
    auto operator[](ssize byte_index) -> uint8& {
        return reinterpret_cast<uint8*>(address)[byte_index];
    }
};
