// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <linux>
#include <memory>
#include <optional>
#include <type_traits>

// TODO: Some allocators should be iterable.
// TODO: Add a random_access concept and a random_access_allocator concept.

/* Some concepts from the STL are not supported, for various reasons.
 * `cat::destructable` is not useful without exception handling. */

namespace cat {

template <typename T>
struct BaseMemoryHandle {
    using Type = T;
    union {
        void* p_storage;
        ssize storage;
    };
};

template <typename T>
struct SmallMemoryHandle {
    using Handle = T;
    using Type = typename T::Type;
    union {
        T allocator_storage;
        typename T::Type stack_storage;
    };
    bool1 is_on_stack;

    SmallMemoryHandle(T const& handle)
        : allocator_storage(handle), is_on_stack(false){};

    SmallMemoryHandle(typename T::Type const& value)
        : stack_storage(value), is_on_stack(true){};

    // auto access() -> T& {
    //     return this->allocator_storage;
    // }

    // auto access() const -> T& {
    //     return this->allocator_storage;
    // }
};

namespace detail {
    template <typename T>
    struct PageMemoryHandle : BaseMemoryHandle<T> {
        using Type = typename BaseMemoryHandle<T>::Type;
        ssize allocation_size;
    };
}  // namespace detail

}  // namespace cat

namespace meta {

template <typename AllocatorT, typename AllocationU = void*>
concept Allocator = requires(AllocatorT allocator) {
    // Every allocator has a `.malloc()`, `.free()`, and `.get()` method.
    // TODO: Handle non-arbitrary allocation sizes.
    // allocator.malloc(sizeof(AllocationU));
    // allocator.template malloc<AllocationU>();
    // allocator.free(typename AllocatorT::template Handle<AllocationU>{});
    // allocator.get(typename AllocatorT::template Handle<AllocationU>{});
    true;
};

}  // namespace meta

namespace cat {

template <typename Derived>
struct AllocatorFacade {
    constexpr auto self() -> Derived& {
        return static_cast<Derived&>(*this);
    }

    template <typename T = void*>
    auto malloc(ssize const allocation_size = sizeof(T)) {
        auto maybe_memory = this->self().template allocate<T>(allocation_size);
        using Handle = decltype(this->self().template make_handle<T>(
            maybe_memory.value(), allocation_size));

        // `allocate()` returns either an `Optional` or a `Result`, both of
        // which have `.has_value()`.
        if (maybe_memory.has_value()) {
            // TODO: In-place construction.
            return Optional<Handle>(this->self().template make_handle<T>(
                maybe_memory.value(), allocation_size));
        }
        return Optional<Handle>(none);
    }

    template <typename T>
    auto free(T const& memory) -> Result<>
    // Taking a `Handle<T>` parameter accepts `SmallHandle<T>`, which is
    // incorrect.
    // requires(meta::is_specialization<T, Handle>::value)
    {
        // TODO: Invoke destructor.
        auto result = this->self().deallocate(memory);
        if (result.has_value()) {
            return okay;
        }
        return Failure(1);
    };

    // Allocate small-size optimized memory.
    template <typename T = void*>
    auto malloca(ssize const allocation_size = sizeof(T)) {
        using Handle = decltype(this->self().template make_handle<T>(
            T{}, allocation_size));
        using SmallHandle = SmallMemoryHandle<Handle>;

        // TODO: In-place construction.
        if (allocation_size > 256) {
            auto maybe_memory = this->malloc<T>(allocation_size);
            if (maybe_memory.has_value()) {
                return Optional<SmallHandle>(Handle{maybe_memory.value()});
            }
            return Optional<SmallHandle>(none);
        }

        return Optional<SmallHandle>(T{});
    }

    // Free small-size optimized memory.
    // TODO: Use an `Optional<void>`.
    // template <typename T>
    auto freea(/* SmallHandle<T>*/ auto const& memory) -> Result<> {
        // TODO: Invoke destructor.
        if (memory.is_on_stack) {
            return okay;
        }
        return this->free(memory.allocator_storage);
    };

    // Get a reference to the data in a memory handle.
    auto get(auto& memory) -> auto& {
        using T = typename meta::remove_cvref_t<decltype(memory)>;
        // using T = typeof(memory);
        using U = typename T::Type;
        if constexpr (requires { memory.is_on_stack; }) {
            if (memory.is_on_stack) {
                return memory.stack_storage;
            }
            return this->self().template access<U>(memory.allocator_storage);
        } else {
            return this->self().template access<U>(memory);
        }
    }
};

struct PageAllocator : AllocatorFacade<PageAllocator> {
    template <typename T>
    using MemoryHandle = cat::detail::PageMemoryHandle<T>;

    // Allocate memory in multiples of a page-size. A page is `4_ki` large on
    // x86-64. If fewer that `4096` bytes are allocated, that amount will be
    // rounded up to `4096`.
    template <typename T = void*>
    auto allocate(ssize const allocation_size = sizeof(T)) -> Result<void*> {
        return nix::map_memory(0u, allocation_size,
                               nix::MemoryProtectionFlags::read |
                                   nix::MemoryProtectionFlags::write,
                               nix::MemoryFlags::privately |
                                   nix::MemoryFlags::populate |
                                   nix::MemoryFlags::anonymous,
                               // Anonymous pages must have `-1`.
                               -1,
                               // Anonymous pages must have `0u`.
                               0u);
    }

    // Unmap a handle to page(s) of virtual memory.
    auto deallocate(auto const& memory) -> Result<> {
        return nix::unmap_memory(memory.p_storage, memory.allocation_size);
    };

    template <typename T>
    auto make_handle(auto data, ssize size) -> MemoryHandle<T> {
        return MemoryHandle<T>{{data}, size};
    }

    // Access a page(s) of virtual memory.
    template <typename T>
    auto access(MemoryHandle<T> const& memory) -> T& {
        return *static_cast<T*>(memory.p_storage);
    }
};

}  // namespace cat
