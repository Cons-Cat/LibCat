// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/collection>
#include <cat/meta>
#include <cat/string>
#include <cat/utility>

namespace cat {

// An `Array` represents an array of `T` with an immutable length. It stores its
// data points within itself, so this array can be constructed on the stack. It
// is random-access iterable.
template <typename T, ssize length>
class Array : public CollectionFacade<Array<T, length>, T> {
    T storage[length.raw];

  public:
    constexpr Array() = default;
    constexpr Array(Array<T, length> const& in_array) = default;
    constexpr Array(Array<T, length>&& in_array) = default;

    // Construct an `Array` from a variadic argument list.
    template <typename... U>
    constexpr Array(U&&... arguments) requires(sizeof...(arguments) ==
                                               length.raw)
        : storage(arguments...){};

    template <typename U, U... values>
    constexpr Array(ValueList<U, values...> const list) requires(
        is_convertible<U, T>&& list.size == length)
        : storage(static_cast<T>(values)...){};

    // If this is an `Array<char>`, it can be constructed from a string.
    constexpr Array(String const& string) requires(
        is_same<RemoveConst<T>, char>) {
        copy_memory(string.p_data(), this->storage, string.size());
    }

    constexpr auto operator=(Array<T, length> const&)
        -> Array<T, length>& = default;

    constexpr auto operator=(Array<T, length>&&) -> Array<T, length>& = default;

  private:
    template <ssize index, typename U, U value, U... values>
    constexpr void copy_list(ValueList<U, value, values...> const) {
        this->storage[index.raw] = value;

        if constexpr (index + 1 == length) {
            return;
        } else {
            // Recurse withn one fewer elements in the `ValueList`.
            this->copy_list<index + 1>(ValueList<U, values...>{});
        }
    }

  public:
    template <Integral U, U... values>
    constexpr auto operator=(ValueList<U, values...> const list) requires(
        is_convertible<U, T>&& list.size == length) {
        this->copy_list<0, U, values...>(list);
    };

    // If this is an `Array<char>`, it can be assigned a string.
    constexpr auto operator=(String const&& string) -> Array<T, length>
    requires(is_same<RemoveConst<T>, char>) {
        Array<T, length> array;
        copy_memory(string.p_data(), this->storage, string.size());
        return array;
    }

    // Get the non-`const` address of this `Array`'s internal array.
    [[nodiscard]] constexpr auto p_data() -> T* {
        return this->storage;
    }

    // Get the `const` address of this `Array`'s internal array.
    [[nodiscard]] constexpr auto p_data() const -> T const* {
        return this->storage;
    }

    // Get the number of elements contained in this `Array`.
    [[nodiscard]] constexpr auto size() const -> ssize {
        return length;
    }

    // If this is an `Array<char>`, it can be converted to a `String`.
    [[nodiscard]] constexpr auto to_string() -> String
        requires(is_same<RemoveConst<T>, char>) {
        return String(
            static_cast<char const*>(static_cast<void*>(&this->storage)),
            length);
    }
};

// Construct an `Array` as: `Array array = {0, 1, 2};`
template <typename T, typename... Args>
Array(T, Args...) -> Array<T, ssize{sizeof...(Args)} + 1>;

}  // namespace cat
