// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/collection>
#include <cat/meta>
#include <cat/string>
#include <cat/utility>

namespace cat {

// An `Array` represents an array of `T` with an immutable length. It stores its
// data points within itself, so this array can be constructed on the stack. It
// is random-access iterable.
template <typename T, ssize length>
class Array : public CollectionFacade<Array<T, length>, T> {
    T storage[length.c()];

  public:
    constexpr Array() = default;
    constexpr Array(Array<T, length> const& in_array) = default;
    constexpr Array(Array<T, length>&& in_array) = default;

    // Construct an `Array` from a variadic argument list.
    template <typename... U>
    constexpr Array(U&&... arguments) requires(sizeof...(arguments) ==
                                               length.c())
        : storage(arguments...){};

    template <Integral U, U... Is>
    constexpr Array(IntegerSequence<U, Is...> const values) requires(
        is_convertible<U, T>&& values.size == length)
        : storage(static_cast<T>(Is)...){};

    // If this is an `Array<char>`, it can be constructed from a string.
    constexpr Array(String const& string) requires(
        is_same<RemoveConst<T>, char>) {
        cat::copy_memory(string.p_data(), this->storage, string.size());
    }

    constexpr auto operator=(Array<T, length> const&)
        -> Array<T, length>& = default;

    constexpr auto operator=(Array<T, length>&&) -> Array<T, length>& = default;

  private:
    template <ssize index, typename U, U value, U... Us>
    constexpr void copy_sequence(IntegerSequence<U, value, Us...> const) {
        this->storage[index.c()] = value;

        if constexpr (index + 1 == length) {
            return;
        } else {
            // Recurse with one fewer elements in the `IntegerSequence`.
            this->copy_sequence<index + 1>(IntegerSequence<U, Us...>{});
        }
    }

  public:
    template <Integral U, U... Us>
    constexpr auto operator=(IntegerSequence<U, Us...> const values) requires(
        is_convertible<U, T>&& values.size == length) {
        this->copy_sequence<0, U, Us...>(values);
    };

    // If this is an `Array<char>`, it can be assigned a string.
    constexpr auto operator=(String const&& string) -> Array<T, length>
    requires(is_same<RemoveConst<T>, char>) {
        Array<T, length> array;
        cat::copy_memory(string.p_data(), this->storage, string.size());
        return array;
    }

    // Get the non-`const` address of this `Array`'s internal array.
    [[nodiscard]] constexpr auto p_data() -> T* {
        return this->storage;
    }

    // Get the `const` address of this `Array`'s internal array.
    [[nodiscard]] constexpr auto p_data() const -> T const* {
        return this->storage;
    }

    // Get the number of elements contained in this `Array`.
    [[nodiscard]] constexpr auto size() const -> ssize {
        return length;
    }

    // If this is an `Array<char>`, it can be converted to a `String`.
    [[nodiscard]] constexpr auto to_string() -> String
        requires(is_same<RemoveConst<T>, char>) {
        return String(
            static_cast<char const*>(static_cast<void*>(&this->storage)),
            length);
    }
};

// Construct an `Array` as: `cat::Array array = {0, 1, 2};`
template <typename T, typename... Args>
Array(T, Args...)
    -> Array<T, static_cast<signed int long>(sizeof...(Args)) + 1>;

}  // namespace cat
