// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/collection>
#include <cat/iterator>
#include <cat/meta>
#include <cat/optional>
#include <cat/string>
#include <cat/utility>

namespace cat {

template <typename T, ssize length>
class Array : public ::meta::CollectionFacade<Array<T, length>, T> {
    T storage[length.c()];
  public:
    constexpr Array() = default;
    constexpr Array(Array<T, length>&& in_array) = default;
    constexpr Array(Array<T, length> const& in_array) = default;
    constexpr Array(String const& string) requires(
        ::meta::is_same<::meta::RemoveConst<T>, char>) {
        cat::copy_memory(string.p_data(), this->storage, string.size());
    }

    template <typename... U>
    constexpr Array(U&&... arguments) requires(sizeof...(arguments) ==
                                               length.c())
        : storage(arguments...){};

    constexpr auto operator=(Array<T, length>&&) -> Array<T, length>& = default;

    constexpr auto operator=(String const&& string) -> Array<T, length>
    requires(::meta::is_same<T, char>) {
        Array<T, length> array;
        cat::copy_memory(string.p_data(), this->storage, string.size());
        return array;
    }

    [[nodiscard]] constexpr auto p_data() -> T* {
        return this->storage;
    }

    [[nodiscard]] constexpr auto p_data() const -> T const* {
        return this->storage;
    }

    [[nodiscard]] constexpr auto size() const -> ssize {
        return length;
    }

    [[nodiscard]] constexpr auto to_string() -> String
        requires(::meta::is_same<::meta::RemoveConst<T>, char>) {
        return String(
            static_cast<char const*>(static_cast<void*>(&this->storage)),
            length);
    }
};

template <typename T, typename... Args>
Array(T, Args...)
    -> Array<T, static_cast<signed int long>(sizeof...(Args)) + 1>;

}  // namespace cat
