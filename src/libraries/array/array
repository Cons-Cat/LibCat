// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <iterator>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <utility>

template <typename T, ssize length>
class Array {
    T storage[length];
  public:
    constexpr Array() = default;
    constexpr Array(Array<T, length>&& in_array) = default;
    constexpr Array(Array<T, length> const& in_array) = default;
    constexpr Array(String const& string) requires(
        meta::is_same_v<meta::remove_const_t<T>, char>) {
        cat::copy_memory(string.p_data(), &(this->storage), string.size());
    }

    template <typename... U>
    constexpr Array(U&&... arguments) requires(sizeof...(arguments) == length) {
        T unpacked_data[length] = {arguments...};
        for (int4 i = 0; i < length; i++) {
            this->storage[i] = unpacked_data[i];
        }
    }

    constexpr auto operator=(Array<T, length>&&) -> Array<T, length>& = default;
    constexpr auto operator=(String const&& string) -> Array<T, length>
    requires(meta::is_same_v<T, char>) {
        Array<T, length> array;
        cat::copy_memory(string.p_data(), &(this->storage), string.size());
        return array;
    }

    constexpr auto operator[](ssize index) -> T& {
        Result{index >= 0}.assert();
        Result{index < length}.assert();
        return this->storage[index];
    }

    constexpr auto at(ssize index) -> Optional<T&> {
        Result{index >= 0}.assert();
        if (index < length) {
            return Optional<T&>(this->storage[index]);
        }
        return none;
    }

    constexpr auto p_data() -> T const* {
        return &(this->storage[0]);
    }

    consteval auto size() -> ssize {
        return length;
    }

    constexpr auto front() -> T& {
        return this->storage[0];
    }

    constexpr auto back() -> T& {
        return this->storage[length - 1];
    }

    constexpr auto is_empty() -> bool1 {
        return length > 0;
    }

    constexpr auto to_string() -> String
        requires(meta::is_same_v<meta::remove_const_t<T>, char>) {
        return String(
            static_cast<char const*>(static_cast<void*>(&this->storage)),
            length);
    }

    struct Iterator : IteratorFacade<Iterator> {
        ssize current_index;
        T const* const p_array;

        constexpr Iterator() = default;
        constexpr explicit Iterator(ssize index, T const* const p_in_array)
            : current_index(index), p_array(p_in_array){};

        auto dereference() const -> T const& {
            return this->p_array[current_index];
        }

        void advance(ssize offset) {
            current_index += offset;
        }

        auto distance_to(Iterator other) const -> ssize {
            return other.current_index - current_index;
        }
    };

    constexpr auto begin() const {
        return Iterator(0, this->storage);
    }

    constexpr auto end() const {
        return Iterator(length, this->storage);
    }

    constexpr auto rbegin() const {
        return cat::ReversedIterator<Iterator>(length - 1, this->storage);
    }

    constexpr auto rend() const {
        return cat::ReversedIterator<Iterator>(-1, this->storage);
    }
};
