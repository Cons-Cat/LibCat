// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <memory>
#include <string>
#include <type_traits>
#include <utility>

template <typename T, ssize Size>
struct Array {
    static constexpr ssize length = Size;
    T value[Size];

    constexpr Array() = default;
    constexpr Array(Array<T, Size>&& in_array) = default;
    constexpr Array(Array<T, Size> const& in_array) = default;
    constexpr Array(StringView const& string) requires(
        meta::is_same_v<meta::remove_const_t<T>, char>) {
        std::copy_memory(string.p_data, &(this->value), string.length);
    }

    constexpr auto operator=(Array<T, Size>&&) -> Array<T, Size>& = default;
    constexpr auto operator=(StringView const&& string) -> Array<T, Size>
    requires(meta::is_same_v<T, char>) {
        Array<T, Size> array;
        std::copy_memory(string.p_data, &(this->value), string.length);
        return array;
    }

    template <typename... U>
    constexpr Array(U&&... arguments) requires(sizeof...(arguments) == Size) {
        T unpacked_data[Size] = {arguments...};
        for (int4 i = 0; i < Size; i++) {
            this->value[i] = unpacked_data[i];
        }
    }

    // TODO: Non-pessimize unsigned indices as well.
    constexpr auto operator[](ssize i) -> T& {
        return value[i];
    }

    constexpr auto to_string() -> StringView
        requires(meta::is_same_v<meta::remove_const_t<T>, char>) {
        return StringView(static_cast<char const*>(static_cast<void*>(&value)),
                          Size);
    }
};
