// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* RAII wrappers are trivially constructible types that cannot be copied. They
 * must be moved to pass into functions. Their destructor will call a free()
 * method on the type they wrap iff that types has a free() method. */

template <typename T>
struct Raii : T {
    Raii() = default;
    Raii(T const&) = delete;
    Raii(Raii<T>&&){};

    ~Raii() = default;
    // clangd gives a false-positive error due to this destructor:
    ~Raii() requires(T::free()) {
        this->free();
    }
};

namespace std {

void copy_memory(void const* p_source, void* p_destination, ssize bytes);

void copy_memory_small(void const* p_source, void* p_destination, ssize bytes);

auto is_aligned(void const volatile* p_pointer, ssize byte_alignment) -> bool1;

template <typename T>
constexpr auto address_of(T& value) -> T* {
    __builtin_addressof(value);
}

}  // namespace std
