// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// Raii wrappers are CRTP types that cannot be copy-constructed. They must be
// moved to pass into functions. Their destructor will call a `free()` method on
// the type they wrap iff that types has a `free()` method.

template <typename T>
struct Raii : T {
    Raii() = default;
    Raii(T const&) = delete;
    Raii(Raii<T>&&){};

    ~Raii() = default;
    ~Raii() requires(T::free()) {
        this->free();
    }
};

namespace cat {

void copy_memory(void const* p_source, void* p_destination, ssize bytes);

void copy_memory_small(void const* p_source, void* p_destination, ssize bytes);

auto is_aligned(void const volatile* p_pointer, ssize byte_alignment) -> bool1;

// `cat::address_of()` should be used instead of a `&` for containers that might
// hold a generic object, because this will produce correct results even if a
// `&` prefix operator has been overloaded.
template <typename T>
constexpr auto address_of(T& value) -> T* {
    return __builtin_addressof(value);
}

}  // namespace cat
