// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

namespace cat {

void copy_memory(void const* p_source, void* p_destination, ssize bytes);

void copy_memory_small(void const* p_source, void* p_destination, ssize bytes);

// `cat::address_of()` should be used instead of a `&` for containers that might
// hold a generic object, because this will produce correct results even if a
// `&` prefix operator has been overloaded.
template <typename T>
constexpr auto addressof(T& value) -> T* {
    return __builtin_addressof(value);
}

template <typename T>
constexpr auto addressof(T const& value) -> T const* {
    return __builtin_addressof(value);
}

// `cat::AlignedStorage` is a buffer of arbitrary memory with some guaranteed
// alignment.
template <ssize length, usize alignment>
requires(length > 0) struct AlignedStorage {
    struct Type {
        // TODO: Use `cat::Array` and `cat::Byte`.
        alignas(alignment.c()) unsigned char storage[length.c()];
    };
};

}  // namespace cat

using cat::addressof;
