// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <iterator>
#include <type_traits>
#include <utility>

namespace cat {

template <typename T>
auto min(T&& value) -> T&& {
    return meta::forward<T>(value);
}

// Implicit output type `min()`.
template <typename T, typename U, typename... Remaining>
auto min(T&& value_1, U&& value_2, Remaining&&... remaining) {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 < value_2)
               ? cat::min(value_1, meta::forward<Remaining>(remaining)...)
               : cat::min(value_2, meta::forward<Remaining>(remaining)...);
}

// Explicit output type `min()`.
template <typename Out, typename T, typename U, typename... Remaining>
auto min(T&& value_1, U&& value_2, Remaining&&... remaining) -> Out {
    return static_cast<Out>(
        (value_1 < value_2)
            // Invoke the implicit output `min()`.
            ? cat::min(value_1, meta::forward<Remaining>(remaining)...)
            : cat::min(value_2, meta::forward<Remaining>(remaining)...));
}

constexpr auto min(meta::iterable auto& iterable) {
    using T = meta::remove_reference_t<typename meta::remove_const_t<
        typename cat::iterator_traits<decltype(iterable.begin())>::Value>>;
    T minimum{};

    for (T const& it : iterable) {
        minimum = cat::min(it, minimum);
    }
    return minimum;
}

template <typename T>
constexpr auto max(T&& value) -> T&& {
    return meta::forward<T>(value);
}

// Implicit output type `max()`.
template <typename T, typename U, typename... Remaining>
constexpr auto max(T&& value_1, U&& value_2, Remaining&&... remaining) {
    // Recurse through the list of variadic arguments, discarding the larger
    // element each time.
    return (value_1 < value_2)
               ? cat::max(value_1, meta::forward<Remaining>(remaining)...)
               : cat::max(value_2, meta::forward<Remaining>(remaining)...);
}

// Explicit output type `max()`.
template <typename Out, typename T, typename U, typename... Remaining>
constexpr auto max(T&& value_1, U&& value_2, Remaining&&... remaining) -> Out {
    return static_cast<Out>(
        (value_1 < value_2)
            // Invoke the implicit output `max()`.
            ? cat::max(value_1, meta::forward<Remaining>(remaining)...)
            : cat::max(value_2, meta::forward<Remaining>(remaining)...));
}

constexpr auto max(meta::iterable auto& iterable) {
    using T = meta::remove_reference_t<typename meta::remove_const_t<
        typename cat::iterator_traits<decltype(iterable.begin())>::Value>>;
    T maximum{};

    for (T const& it : iterable) {
        maximum = cat::max(it, maximum);
    }
    return maximum;
}

}  // namespace cat
