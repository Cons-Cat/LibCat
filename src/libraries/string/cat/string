// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/bit>
#include <cat/collection>
#include <cat/iterator>
#include <cat/memory>
#include <cat/meta>
#include <cat/optional>
#include <cat/simd>
#include <cat/span>
#include <cat/utility>

// `__SIZE_TYPE__` is a GCC macro.
// Deprecated call to `memcpy()`. Consider using `copy_buffer()` instead.
// `memcpy()` exists to enable some GCC optimizations.
namespace std {
extern "C" auto memcpy(void* p_destination, void const* p_source,
                       __SIZE_TYPE__ bytes) -> void*;
}
using std::memcpy;

namespace cat {

constexpr auto string_length(char const* p_string) -> ssize;

template <signed long long length>
struct StaticString;

class String : public Span<char const> {
    // `String` inherits:
    //
    // `char const* p_storage;`
    // `ssize length;`
  public:
    constexpr String() : Span<char const>(){};

    constexpr String(char const* p_string, ssize in_length)
        : Span<char const>(p_string, in_length){};

    constexpr String(String const& string)
        : Span<char const>(string.p_storage, string.length){};

    constexpr String(String&& string)
        : Span<char const>(string.p_storage, string.length){};

    // This is `auto` to deduce lower than the array-literal constructor.
    template <typename T>
    constexpr String(T p_string) requires(is_pointer<T>)
        : Span<char const>(p_string, string_length(p_string)){};

    template <signed long long other_length>
    consteval String(char const (&string)[other_length]) {
        this->p_storage = string;
        this->length = static_cast<signed long long>(other_length);
    }

    template <signed long long other_length>
    constexpr String(StaticString<other_length> const& string) {
        this->p_storage = &(string.storage[0]);
        this->length = other_length;
    }

    // A `String` consuming `nullptr` would cause undefined behavior.
    constexpr String(decltype(nullptr)) = delete;

    constexpr auto operator=(String const& string) {
        this->p_storage = string.p_storage;
        this->length = string.length;
    }

    constexpr auto operator=(String&& string) {
        this->p_storage = string.p_storage;
        this->length = move(string).length;
    }

    [[nodiscard]] constexpr auto substring(ssize const position,
                                           ssize const count) -> String {
        return String{this->p_storage + position, count};
    }

    [[nodiscard]] constexpr auto remove_prefix(ssize const offset) -> String {
        return this->substring(offset, this->length - offset);
    }

    [[nodiscard]] constexpr auto remove_suffix(ssize const offset) -> String {
        return this->substring(0, this->length - offset);
    }

    constexpr auto find_small(char const character,
                              ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        for (ssize i = position; i < this->length; ++i) {
            if (this->p_storage[i.raw] == character) {
                return i;
            }
        }
        return nullopt;
    }

    // TODO: Optimize different length strings.
    // TODO: Tile this loop four or eight times.
    constexpr auto find(char const character, ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        ssize i = position;
        for (; i < this->length - char1x_::lanes; i += char1x_::lanes) {
            // TODO: Consider aligning this load?
            char1x_ const storage = char1x_::loaded(this->p_storage + i);
            SimdMask<Avx2Abi<char>, char> const compare =
                (storage == character);
            int4 const mask = move_mask(compare);
            if (mask != 0) {
                return i + mask.count_trailing_zeros();
            }
        }
        // The last chunk of this string, smaller than `char1x_::lanes`, is
        // stepped through one character at a time.
        return this->find_small(character, i);
    }
};

// This is `signed long long` because GCC cannot deduce a string literal's
// length from an `ssize`.
template <signed long long length>
struct StaticString : CollectionFacade<StaticString<length>, char> {
    // TODO: Use an `Array`.
    char storage[length];

    constexpr auto p_data() -> char* {
        return &(this->storage[0]);
    }

    constexpr auto p_data() const -> char const* {
        return &(this->storage[0]);
    }

    constexpr auto size() const -> ssize {
        return length;
    }

    constexpr StaticString() = default;

    template <signed long long in_length>
        requires(in_length <= length)
    constexpr StaticString(StaticString<length> const& string) {
        // TODO: `copy_memory` should be `constexpr`.
        // copy_memory(this->p_data(), this->p_data(), length);
        for (signed long long i = 0; i < length; ++i) {
            storage[i] = string[i];
        }
        for (signed long long i = length; i < length; ++i) {
            storage[i] = '\0';
        }
    }

    constexpr StaticString(char const (&in)[length]) {
        // TODO: `copy_memory` should be `constexpr`.
        // copy_memory(this->p_data(), this->p_data(), length);
        for (signed long long i = 0; i < length; ++i) {
            storage[i] = in[i];
        }
        for (signed long long i = length; i < length; ++i) {
            storage[i] = '\0';
        }
    }

    template <signed long long in_length>
        requires(in_length <= length)
    auto operator=(StaticString<in_length> const& string)
        -> StaticString<length>& {
        copy_memory(string.p_data(), this->p_data(), in_length);
        for (signed long long i = in_length; i < length; ++i) {
            this->storage[i] = '\0';
        }
        return *this;
    }

    template <signed long long in_length>
        requires(in_length <= length)
    auto operator=(char const (&in)[in_length]) -> StaticString<length>& {
        copy_memory(&in, this->p_data(), in_length);
        for (signed long long i = in_length; i < length; ++i) {
            this->storage[i] = '\0';
        }
        return *this;
    }
};

// Concatenate constant-evaluated strings.

// This is `signed long long` because GCC cannot deduce a string literal's
// length from an `ssize`.
template <signed long long length_1, signed long long length_2>
constexpr auto operator+(StaticString<length_1> const& string_1,
                         StaticString<length_2> const& string_2)
    -> StaticString<length_1 - 1 + length_2> {
    // TODO: Use an `Array`.
    char array[length_1 - 1 + length_2];

    for (int i = 0; i < length_1 - 1; ++i) {
        array[i] = string_1.storage[i];
    }

    for (int i = length_1 - 1; i < length_1 - 1 + length_2 - 1; ++i) {
        array[i] = string_2.storage[i - length_1 + 1];
    }

    // Make this string null-terminated.
    array[(length_1 - 1 + length_2 - 1)] = '\0';
    StaticString static_string = array;
    return static_string;
}

[[nodiscard]] auto compare_strings(String const string_1, String const string_2)
    -> bool1;

[[nodiscard]] auto print(String const string) -> Optional<ssize>;

[[nodiscard]] auto print_line(String const string) -> Optional<ssize>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

#include "../implementations/string_length.tpp"
