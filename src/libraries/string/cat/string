// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/bit>
#include <cat/collection>
#include <cat/iterator>
#include <cat/memory>
#include <cat/meta>
#include <cat/optional>
#include <cat/simd>
#include <cat/span>
#include <cat/utility>

#include "detail/itoa_jeaiii.hpp"

// `__SIZE_TYPE__` is a GCC macro.
// Deprecated call to `memcpy()`. Consider using `copy_buffer()` instead.
// `memcpy()` exists to enable some GCC optimizations.
namespace std {
extern "C" auto memcpy(void* p_destination, void const* p_source,
                       __SIZE_TYPE__ bytes) -> void*;
}
using std::memcpy;

namespace cat {

constexpr auto string_length(char const* p_string) -> ssize;

template <ssize length>
struct StaticString;

class String : public Span<char const> {
    // `String` inherits:
    //
    // `char const* p_storage;`
    // `ssize length;`
  public:
    constexpr String() : Span<char const>(){};

    constexpr String(char const* p_string, ssize in_length)
        : Span<char const>(p_string, in_length){};

    constexpr String(String const& string)
        : Span<char const>(string.p_storage, string.length){};

    constexpr String(String&& string)
        : Span<char const>(string.p_storage, string.length){};

    // This is `auto` to deduce lower than the array-literal constructor.
    template <typename T>
    constexpr String(T p_string) requires(is_pointer<T>)
        : Span<char const>(p_string, string_length(p_string)){};

    template <unsigned int long other_length>
    consteval String(char const (&string)[other_length]) {
        this->p_storage = string;
        this->length = static_cast<signed int long>(other_length);
    }

    // TODO: Make this `consteval`.
    template <unsigned int long other_length>
    constexpr String(
        StaticString<static_cast<signed int long>(other_length)> const&
            string) {
        this->p_storage = &(string.storage[0]);
        this->length = static_cast<signed int long>(other_length);
    }

    // A `String` consuming `nullptr` would cause undefined behavior.
    constexpr String(decltype(nullptr)) = delete;

    constexpr auto operator=(String const& string) {
        this->p_storage = string.p_storage;
        this->length = string.length;
    }

    constexpr auto operator=(String&& string) {
        this->p_storage = string.p_storage;
        this->length = move(string).length;
    }

    [[nodiscard]] constexpr auto substring(ssize const position,
                                           ssize const count) -> String {
        return String{this->p_storage + position, count};
    }

    [[nodiscard]] constexpr auto remove_prefix(ssize const offset) -> String {
        return this->substring(offset, this->length - offset);
    }

    [[nodiscard]] constexpr auto remove_suffix(ssize const offset) -> String {
        return this->substring(0, this->length - offset);
    }

    constexpr auto find_small(char const character,
                              ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        for (ssize i = position; i < this->length; ++i) {
            if (this->p_storage[i.raw] == character) {
                return i;
            }
        }
        return nullopt;
    }

    // TODO: Optimize different length strings.
    // TODO: Tile this loop four or eight times.
    constexpr auto find(char const character, ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        ssize i = position;
        for (; i < this->length - char1x_::lanes; i += char1x_::lanes) {
            // TODO: Consider aligning this load?
            char1x_ const storage = char1x_::loaded(this->p_storage + i);
            SimdMask<Avx2Abi<char>, char> const compare =
                (storage == character);
            int4 const mask = move_mask(compare);
            if (mask != 0) {
                return i + mask.count_trailing_zeros();
            }
        }
        // The last chunk of this string, smaller than `char1x_::lanes`, is
        // stepped through one character at a time.
        return this->find_small(character, i);
    }
};

// This could be `unsigned long` because the compiler cannot deduce a string
// literal's length as `ssize`.
// TODO: Try a deduction guide.
template <ssize length>
struct StaticString {
    // TODO: Use an `Array`.
    char storage[length.raw + 1];

    constexpr StaticString(char const (&in)[length.raw]) : storage{} {
        for (int i = 0; i < length - 1; ++i) {
            storage[i] = in[i];
        }
        storage[length] = '\0';
    }

    consteval StaticString(String const& in) : storage{} {
        for (int i = 0; i < in.size() - 1; ++i) {
            storage[i] = in.p_data()[i];
        }
        storage[length] = '\0';
    }

    constexpr auto get_string() const {
        return this->storage;
    }

    static consteval auto size() -> ssize {
        return length;
    }
};

// template <unsigned long length>
// StaticString(length) -> StaticString<ssize{length}>;

// Concatenate constant-evaluated strings.

// This could be `unsigned long` because the compiler cannot deduce a string
// literal's length as `ssize`.
// TODO: Try a deduction guide.
template <ssize length_1, ssize length_2>
consteval auto operator+(StaticString<length_1> const& string_1,
                         StaticString<length_2> const& string_2)
    -> StaticString<length_1 - 1 + length_2> {
    // TODO: Use an `Array`.
    char array[length_1.raw - 1 + length_2.raw];

    for (int i = 0; i < length_1 - 1; ++i) {
        array[i] = string_1.storage[i];
    }

    for (int i = length_1.raw - 1; i < length_1 - 1 + length_2 - 1; ++i) {
        array[i] = string_2.storage[i - length_1.raw + 1];
    }

    // Make this string null-terminated.
    array[(length_1.raw - 1 + length_2.raw - 1)] = '\0';
    StaticString static_string = array;
    return static_string;
}

auto compare_strings(String const& string_1, String const& string_2) -> bool1;

// Formatting
namespace detail {
    // TODO: Extract a `cat/allocators/detail/allocators_fwd.hpp` header.
    // `#include <cat/allocators>` introduces a circular dependency, so a
    // redundant allocator `concept` is specified here.
    template <typename AllocatorT, typename AllocationU = void*>
    concept FormatAllocator = requires(AllocatorT allocator) {
        // Every allocator has a `.malloc()` method.
        allocator.malloc(ssizeof<AllocationU>());
        allocator.template malloc<AllocationU>();
    };

    // This represents precisely 16 alternatives to fill 4 bits in
    // `FormatArgumentCompactIndex`.
    enum class FormatDiscriminant : unsigned char {
        automatic_type = 0,  // This type is deduced from a variadic argument.
        // These types are sorted for fast alternative checking.
        int1_type,
        uint1_type,
        int2_type,
        uint2_type,
        int4_type,
        uint4_type,
        int8_type,
        uint8_type,
        bool1_type,
        integer_sentinel = bool1_type,  // Types less than this are integers.
        float_type,
        double_type,
        float_sentinel = double_type,  // Types less than this are floats.
        raw_string_type,
        cat_string_type,
        pointer_type,
        other_type,
    };

    // Specializations of `TypeConstant` map a type to a
    // `FormatDiscriminant`.
    struct FormatTypeConstant {
        FormatDiscriminant discriminant;

        // Get the discriminant value that represents `T`.
        template <typename T>
        static consteval auto alternative() -> FormatDiscriminant {
            FormatTypeConstant type;
            type.template set_alternative<T>();
            return type.discriminant;
        }

        // Set this variant to represent `T`.
        template <typename T>
        constexpr void set_alternative() {
            using U = RemoveCvRef<T>;
            if constexpr (is_same<U, int1>) {
                this->discriminant = FormatDiscriminant::int1_type;
            } else if constexpr (is_same<U, int1::Raw>) {
                this->discriminant = FormatDiscriminant::int1_type;
            } else if constexpr (is_same<U, int2>) {
                this->discriminant = FormatDiscriminant::int2_type;
            } else if constexpr (is_same<U, int2::Raw>) {
                this->discriminant = FormatDiscriminant::int2_type;
            } else if constexpr (is_same<U, int4>) {
                this->discriminant = FormatDiscriminant::int4_type;
            } else if constexpr (is_same<U, int4::Raw>) {
                this->discriminant = FormatDiscriminant::int4_type;
            } else if constexpr (is_same<U, int8>) {
                this->discriminant = FormatDiscriminant::int8_type;
            } else if constexpr (is_same<U, int8::Raw>) {
                this->discriminant = FormatDiscriminant::int8_type;
            } else if constexpr (is_same<U, uint1>) {
                this->discriminant = FormatDiscriminant::uint1_type;
            } else if constexpr (is_same<U, uint1::Raw>) {
                this->discriminant = FormatDiscriminant::uint1_type;
            } else if constexpr (is_same<U, uint2>) {
                this->discriminant = FormatDiscriminant::uint2_type;
            } else if constexpr (is_same<U, uint2::Raw>) {
                this->discriminant = FormatDiscriminant::uint2_type;
            } else if constexpr (is_same<U, uint4>) {
                this->discriminant = FormatDiscriminant::uint4_type;
            } else if constexpr (is_same<U, uint4::Raw>) {
                this->discriminant = FormatDiscriminant::uint4_type;
            } else if constexpr (is_same<U, uint8>) {
                this->discriminant = FormatDiscriminant::uint8_type;
            } else if constexpr (is_same<U, uint8::Raw>) {
                this->discriminant = FormatDiscriminant::uint8_type;
            } else if constexpr (is_same<U, bool1>) {
                this->discriminant = FormatDiscriminant::bool1_type;
            } else if constexpr (is_same<U, float4>) {
                this->discriminant = FormatDiscriminant::float_type;
            } else if constexpr (is_same<U, float8>) {
                this->discriminant = FormatDiscriminant::double_type;
            } else if constexpr (is_same<U, char const*>) {
                this->discriminant = FormatDiscriminant::raw_string_type;
            } else if constexpr (is_same<U, String>) {
                this->discriminant = FormatDiscriminant::cat_string_type;
            } else if constexpr (is_pointer<U>) {
                this->discriminant = FormatDiscriminant::pointer_type;
            } else {
                this->discriminant = FormatDiscriminant::other_type;
            }
        }
    };
}  // namespace detail

// An index into the packed `FormatArgumentstorage`.
struct FormatArgumentCompactIndex {
    ssize::Raw byte_index                   : 60;
    detail::FormatDiscriminant discriminant : 4;
};

// This only exists to be passed into the constructor of `FormatArguments`.
template <typename... Ts>
struct FormatArgumentsCompactStorage {
    static constexpr ssize::Raw argument_count = sizeof...(Ts);
    FormatArgumentCompactIndex arguments_indices[argument_count];

    // TODO: This array length might need to be larger if the any arguments'
    // type is `FormatDiscriminant::other_type`.
    // Byte packed_arguments_storage[argument_count];
    Byte packed_arguments_storage[3];

  private:
    // For every type passed into the constructor, pack it into the arrays
    // in-order.
    template <typename T>
    void store_argument(ssize const argument_index, T&& value) {
        // Pack `value` into `packed_arguments_storage`.
        ssize const storage_index =
            this->arguments_indices[argument_index.raw].byte_index;
        copy_memory(addressof(value),
                    &(this->packed_arguments_storage) + storage_index,
                    ssizeof<T>());

        // Assign `T` to that storage.
        this->arguments_indices[argument_index.raw].discriminant =
            detail::FormatTypeConstant::alternative<T>();

        // Set the `raw_storage` byte offset for the next value, iff there
        // is another one.
        if (argument_index.raw + 1 <
            sizeof...(Ts)) {  // TODO: Explore whether `[[likely]]` improves
                              // performance here.
            this->arguments_indices[argument_index.raw + 1].byte_index =
                storage_index.raw + sizeof(T);
        }
    }

  public:
    FormatArgumentsCompactStorage(Ts&&... types) {
        this->packed_arguments_storage[0] = {};
        this->arguments_indices[0] = {};
        ssize argument_index = -1;
        // TODO: Erase the type of `Ts`.
        // `argument_index` increments per call to `.store()`.
        (this->store_argument(argument_index++, forward<Ts>(types)), ...);
    }
};

// Formatting arguments are packed into a small type-erased array to
// conserve storage.
struct FormatArguments {
    FormatArgumentCompactIndex const* p_arguments_indices;
    ssize const argument_count;

    template <typename... Ts>
    explicit constexpr FormatArguments(
        FormatArgumentsCompactStorage<Ts...> const& storage)
        : p_arguments_indices(&(storage.arguments_indices[0])),
          argument_count(storage.argument_count){};

    // Unpack a formatting argument from the type-erased storage.
    template <typename T>
    auto get(ssize const argument_index) const -> T {
        // Get the storage index out from the indices array.
        ssize const storage_index =
            (this->p_arguments_indices + argument_index)->byte_index;

        // TODO: Make this type punning with `bit_cast`, because this
        // `reinterpret_cast` is undefined behavior.
        // Offset the pointer to the array of indices by the length of that
        // array. That produces a pointer to the next struct member, which
        // happens to be the raw storage array.
        Byte const* const p_storage = reinterpret_cast<Byte const* const>(
            this->p_arguments_indices + argument_count);

        Byte const* p_data = p_storage + storage_index;
        return *bit_cast<T const*>(p_data);
    }
};

// To prevent redundant template specializations for a container's
// `BackInsertIterator`, it is wrapped by virtual function dispatch in this
// container.
template <detail::FormatAllocator Allocator>
struct FormatBufferBase
    : public CollectionFacade<FormatBufferBase<Allocator>, char> {
    char* p_string;
    ssize length;
    ssize max_length;

    auto p_data() const -> char* {
        return this->p_string;
    }

    auto size() const -> ssize {
        return this->length;
    }

    auto capacity() const -> ssize {
        return this->max_length;
    }

    virtual auto grow(ssize const new_size) -> Optional<void> = 0;

    void clear() {
        this->length = 0;
    }

    auto push_back(char const character) -> Optional<void> {
        if (this->length + 1 > max_length) {
            Optional<void> result = this->grow(this->length + 1);
            if (!result.has_value()) {
                return nullopt;
            }
        }

        this->p_string[this->length.raw] = character;
        ++(this->length);
        return monostate;
    }
};

// TODO: Should these be moved elsewhere?
auto to_chars(auto& allocator, int4 const value) -> String {
    char* p_string = allocator.template p_malloc<char>(11).value();
    detail::i32toa_jeaiii(value.raw, p_string);
    // TODO: Get the length of this integer faster.
    return String{p_string};
}

template <typename...>
struct FormatBufferIterator {};

template <detail::FormatAllocator Allocator, typename Outputter>
struct FormatBufferIterator<Allocator, Outputter>
    : FormatBufferBase<Allocator> {
    using Container = typename Outputter::Container;
    Allocator& allocator;
    Outputter& output_iterator;

    // To optimize common usage, `256` bytes of storage is reserved on
    // stack.
    char storage[256];

    FormatBufferIterator(Allocator& in_allocator, Outputter& iterator)
        : allocator(in_allocator), output_iterator(iterator){};

    auto flush() -> Optional<void> {
        ssize size = this->size();
        char const* p_end = storage + size;
        this->clear();

        if constexpr (CollectionTraits<Container>::is_array_like) {
            // TODO: Use a multiple `.push_back()` overload.
        } else {
            for (int i = 0; i < size; ++i) {
                Optional result =
                    this->output_iterator.insert(allocator, this->p_storage[i]);
                if (!result.has_value()) {
                    return nullopt;
                }
            }
        }
        return monostate;
    }

    auto grow(ssize const new_size) -> Optional<void> {
        if (this->size() == 256) {
            this->flush();
        }
        return monostate;
    }
};

template <detail::FormatAllocator Allocator, typename T>
struct FormatBufferIterator<Allocator, T*> : FormatBufferBase<Allocator> {
    // `.grow()` for a `T[]` is no-op.
    auto grow() -> Optional<void> {
        return monostate;
    }
};

namespace detail {
    // One back-insert iterator type should be used, to ensure type-erasure.
    // template <FormatAllocator Allocator>
    // using FormatContiguousOutputIterator =
    //     typename BackInsertIterator<FormatBufferBase<Allocator>>;
}  // namespace detail

// Holds the format string parsing state consisting of the string's range and a
// counter for which arguments have previously been parsed.
class FormatParseContext {
    String format;

    // Iff `argument_index` is less than `0`, the format string has
    // manually indexed an argument. Otherwise, all arguments are automatically
    // indexed.
    ssize argument_index = 0;

  public:
    ssize const arguments_count;

    using Iterator = decltype(format.begin());
    using ConstIterator = decltype(format.cbegin());

    constexpr FormatParseContext(String const in_format,
                                 ssize const in_arguments_count = 0)
        : format(in_format), arguments_count(in_arguments_count){};

    constexpr auto begin() const -> Iterator {
        return this->format.cbegin();
    }

    constexpr auto end() const -> Iterator {
        return this->format.cend();
    }

    constexpr void advance_to(Iterator const position) {
        this->format.begin().advance(position - this->format.begin());
    }

    constexpr auto next_argument_index() -> ssize {
        return ++(this->argument_index);
    }

    // Check if a manually indexed argument is within reasonable bounds, and
    // check that this context is not using automatic indexing.
    constexpr auto check_argument_index(ssize const index) -> Optional<void> {
        if (is_constant_evaluated()) {
            if (index >= this->arguments_count) {
                // This index is of range.
                return nullopt;
            }
        }

        if (this->argument_index > 0) {
            // This argument is manually indexed in a context where automatic
            // indexing has been used.
            return nullopt;
        }

        // Enable manual indexing in this context.
        this->argument_index = -1;
    }
};

// Stores callbacks for the default `Formatter`.
template <detail::FormatAllocator Allocator>
struct FormatHandler {
    Allocator& allocator;
    // detail::FormatContiguousOutputIterator<Allocator> output_iterator;
    BackInsertIterator<String> output_iterator;
    String const string;
    // TODO: A more complex contex object will be needed to support locale and
    // wide chars:
    FormatArguments const arguments;

    FormatHandler(Allocator& in_allocator,
                  // detail::FormatContiguousOutputIterator<Allocator> iterator,
                  BackInsertIterator<String> iterator, String const& in_string,
                  FormatArguments const& in_arguments)
        : allocator(in_allocator),
          output_iterator(iterator),
          string(in_string),
          arguments(in_arguments){};

    // void on_text(char const* p_start, char const* p_end) {
    // }

    void on_replacement_field() {
    }

    void on_format_specs() {
    }
};

template <detail::FormatAllocator Allocator>
constexpr void parse_format_string(String const format,
                                   FormatHandler<Allocator>&& handler) {
    // char const* p_first = format.p_data();
    // char const* p_last = format.p_data() + format.size();
    String remainder = format;
    ssize current_argument = 0;

    // Parse the entire string:
    while (true) {
        ssize const to_open_brace = remainder.find('{').value();
        // char const* p_open_curly = remainder.p_data() + to_open_brace;

        ssize const to_close_brace = remainder.find('}').value();
        // char const* p_close_curly = remainder.p_data() + to_close_brace;

        // This is true if both are `-1`, or in other words, neither braces
        // were found. This is the escape condition.
        if (to_open_brace == to_close_brace) {
            // Copy over the rest of the string.
            break;
        }

        // Parse an argument:
        for (ssize i = 0; i < handler.arguments.argument_count; ++i) {
            switch (handler.arguments.p_arguments_indices[current_argument.raw]
                        .discriminant) {
                case detail::FormatDiscriminant::int4_type:
                    print(to_chars(handler.allocator,
                                   handler.arguments.template get<int4>(
                                       current_argument)));
                    break;
                default:
                    __builtin_unreachable();
            };
        }

        // Slice the string past the text that's just been parsed.
        remainder = remainder.remove_prefix(to_close_brace + 1);
    }
}

namespace detail {
    // Format a collection of `char` and push it into some container.
    template <OutputIterator<String> Outputter,
              detail::FormatAllocator Allocator>
    auto vformat_to(Allocator& allocator, Outputter output_iterator,
                    String const format, FormatArguments const arguments)
        -> Outputter {
        // if constexpr (is_same<Outputter,
        //                       FormatContiguousOutputIterator<Allocator>>) {
        if constexpr (is_same<Outputter, BackInsertIterator<String>>) {
            // If the type-erased contiguous format buffer is used.
            FormatHandler<Allocator> handler = {allocator, output_iterator,
                                                format, arguments};
            parse_format_string(format, move(handler));
            return output_iterator;
        } else {
            // Otherwise, create a type-erased contiguous format buffer.
            FormatBufferIterator<Allocator, Outputter> buffer = {
                allocator, output_iterator};
            FormatHandler<Allocator> handler = {
                // FormatContiguousOutputIterator<Allocator>{buffer},
                BackInsertIterator<String>{buffer}, format, arguments};
            parse_format_string(format, handler);
            return buffer.output_iterator;
        }
    }

    template <detail::FormatAllocator Allocator>
    auto vformat(Allocator& allocator, String const format,
                 FormatArguments const arguments) -> String {
        // TODO: Estimate the size of the final formatted string, and allocate
        // that much up-front for `output`.
        char* const p_storage = allocator.template p_malloc<char>(11).value();
        String output{p_storage, 11};
        _ = vformat_to(allocator, BackInsertIterator{output}, format,
                       arguments);
        return output;
    }
}  // namespace detail

// Store `arguments` in a compacted variant object. Then format a collection of
// `char` with those arguments, and push the result into some container.
template <detail::FormatAllocator Allocator, OutputIterator<String> Outputter,
          typename... Args>
auto format_to(Allocator& allocator, Outputter output_iterator,
               String const format, Args&&... arguments) -> Outputter {
    return detail::vformat_to(allocator, output_iterator, format,
                              FormatArguments{FormatArgumentsCompactStorage{
                                  forward<Args>(arguments)...}});
}

template <detail::FormatAllocator Allocator, typename... Args>
auto format(Allocator& allocator, String const format, Args&&... arguments)
    -> String {
    return detail::vformat(allocator, format,
                           FormatArguments{FormatArgumentsCompactStorage{
                               forward<Args>(arguments)...}});
}

auto print(String const& string) -> Optional<ssize>;

auto print_line(String const& string) -> Optional<ssize>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

// #include "../implementations/jeaiii_to_chars.tpp"
#include "../implementations/string_length.tpp"
