// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/memory>
#include <cat/meta>
#include <cat/optional>
#include <cat/simd>
#include <cat/span>
#include <cat/utility>

// `__SIZE_TYPE__` is a GCC macro.
// Deprecated call to `memcpy()`. Consider using `copy_buffer()` instead.
// `memcpy()` exists to enable some GCC optimizations.
namespace std {
extern "C" auto memcpy(void* p_destination, void const* p_source,
                       __SIZE_TYPE__ bytes) -> void*;
}
using std::memcpy;

namespace cat {

constexpr auto string_length(char const* p_string) -> ssize;

template <ssize length>
struct StaticString;

class String : public Span<char const> {
    // `String` inherits:
    //
    // `char const* p_storage;`
    // `ssize length;`
  public:
    constexpr String() : Span<char const>(){};

    constexpr String(char const* p_string, ssize in_length)
        : Span<char const>(p_string, in_length){};

    constexpr String(String const& string)
        : Span<char const>(string.p_storage, string.length){};

    constexpr String(String&& string)
        : Span<char const>(string.p_storage, string.length){};

    // This is `auto` to deduce lower than the array-literal constructor.
    template <typename T>
    constexpr String(T p_string) requires(is_pointer<T>)
        : Span<char const>(p_string, string_length(p_string)){};

    template <unsigned int long other_length>
    consteval String(char const (&string)[other_length]) {
        this->p_storage = string;
        this->length = static_cast<signed int long>(other_length);
    }

    // TODO: Make this `consteval`.
    template <unsigned int long other_length>
    constexpr String(
        StaticString<static_cast<signed int long>(other_length)> const&
            string) {
        this->p_storage = &(string.storage[0]);
        this->length = static_cast<signed int long>(other_length);
    }

    // A `String` consuming `nullptr` would cause undefined behavior.
    constexpr String(decltype(nullptr)) = delete;

    constexpr auto operator=(String const& string) {
        this->p_storage = string.p_storage;
        this->length = string.length;
    }

    constexpr auto operator=(String&& string) {
        this->p_storage = string.p_storage;
        this->length = move(string).length;
    }

    constexpr auto find_small(char const character,
                              ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        for (ssize i = position; i < this->length; ++i) {
            if (this->p_storage[i.raw] == character) {
                return i;
            }
        }
        return nullopt;
    }

    // TODO: Optimize different length strings.
    // TODO: Tile this loop four or eight times.
    constexpr auto find(char const character, ssize const position = 0) const
        -> Optional<Sentinel<ssize, -1>> {
        ssize i = position;
        for (; i < this->length - char1x_::lanes; i += char1x_::lanes) {
            // TODO: Consider aligning this load?
            char1x_ const storage = char1x_::loaded(this->p_storage + i);
            SimdMask<Avx2Abi<char>, char> const compare =
                (storage == character);
            int4 const mask = move_mask(compare);
            if (mask != 0) {
                return i + mask.count_trailing_zeros();
            }
        }
        // The last chunk of this string, smaller than `char1x_::lanes`, is
        // stepped through one character at a time.
        return this->find_small(character, i);
    }
};

// This could be `unsigned long` because the compiler cannot deduce a string
// literal's length as `ssize`.
// TODO: Try a deduction guide.
template <ssize length>
struct StaticString {
    // TODO: Use an `Array`.
    char storage[length.raw + 1];

    constexpr StaticString(char const (&in)[length.raw]) : storage{} {
        for (int i = 0; i < length - 1; ++i) {
            storage[i] = in[i];
        }
        storage[length] = '\0';
    }

    consteval StaticString(String const& in) : storage{} {
        for (int i = 0; i < in.size() - 1; ++i) {
            storage[i] = in.p_data()[i];
        }
        storage[length] = '\0';
    }

    constexpr auto get_string() const {
        return this->storage;
    }

    static consteval auto size() -> ssize {
        return length;
    }
};

// template <unsigned long length>
// StaticString(length) -> StaticString<ssize{length}>;

// Concatenate constant-evaluated strings.

// This could be `unsigned long` because the compiler cannot deduce a string
// literal's length as `ssize`.
// TODO: Try a deduction guide.
template <ssize length_1, ssize length_2>
consteval auto operator+(StaticString<length_1> const& string_1,
                         StaticString<length_2> const& string_2)
    -> StaticString<length_1 - 1 + length_2> {
    // TODO: Use an `Array`.
    char array[length_1.raw - 1 + length_2.raw];

    for (int i = 0; i < length_1 - 1; ++i) {
        array[i] = string_1.storage[i];
    }

    for (int i = length_1.raw - 1; i < length_1 - 1 + length_2 - 1; ++i) {
        array[i] = string_2.storage[i - length_1.raw + 1];
    }

    // Make this string null-terminated.
    array[(length_1.raw - 1 + length_2.raw - 1)] = '\0';
    StaticString static_string = array;
    return static_string;
}

auto compare_strings(String const& string_1, String const& string_2) -> bool1;

auto print(String const& string) -> Optional<ssize>;

auto print_line(String const& string) -> Optional<ssize>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

#include "./implementations/string_length.tpp"
