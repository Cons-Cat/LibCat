// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <memory>
#include <type_traits>
#include <utility>

namespace cat {

template <typename T = ssize>
constexpr auto string_length(char const* p_string) -> T;

}  // namespace cat

// Deprecated call to `memcpy()`. Consider using `cat::copy_buffer()` instead.
auto memcpy(void* p_destination, void const* p_source, usize bytes) -> void*;

struct StringView {
    char const* p_data;
    ssize length;

    template <ssize Length>
    consteval StringView(char const (&str)[Length]) {
        this->p_data = str;
        this->length = Length;
    }

    constexpr StringView() = default;
    // TODO: Confirm that `cat::string_length()` can be constant-folded by GCC.
    constexpr StringView(char const* p_string)
        : p_data(p_string), length(cat::string_length(p_string)){};
    constexpr StringView(char const* p_string, ssize in_length)
        : p_data(p_string), length(in_length){};
    constexpr StringView(StringView const&& string)
        : p_data(string.p_data), length(string.length){};

    auto operator=(StringView string) {
        this->p_data = string.p_data;
        this->length = string.length;
    }
};

namespace cat {

auto compare_strings(StringView const& string_1, StringView const& string_2)
    -> bool1;

auto print(StringView const& string) -> Result<>;

// auto print_line(char const* p_string) -> Result<>;

// NOLINTNEXTLINE This is forward declared in `<result>`.
auto print_line(StringView const& string) -> Result<>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

#include "./implementations/string_length.tpp"
