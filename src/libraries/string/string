// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <memory>
// #include <span>
#include <type_traits>
#include <utility>

#include "libraries/span/span"

namespace cat {

template <typename T = ssize>
constexpr auto string_length(char const* p_string) -> T;

}  // namespace cat

// Deprecated call to `memcpy()`. Consider using `cat::copy_buffer()` instead.
auto memcpy(void* p_destination, void const* p_source, usize bytes) -> void*;

class String : public Span<char const> {
    // `String` inherits:
    //
    // `char const* p_storage;`
    // `ssize length;`
  public:
    constexpr String() : Span<char const>(){};

    // This is `auto` to deduce lower than the array-literal constructor.
    String(auto p_string)
        : Span<char const>(p_string, cat::string_length(p_string)){};

    constexpr String(char const* p_string, ssize in_length)
        : Span<char const>(p_string, in_length){};

    constexpr String(String&& string)
        : Span<char const>(string.p_storage, string.length){};

    template <ssize Length>
    consteval String(char const (&string)[Length]) {
        this->p_storage = string;
        this->length = Length;
    }

    auto operator=(String string) {
        this->p_storage = string.p_storage;
        this->length = string.length;
    }
};

namespace cat {

auto compare_strings(String const& string_1, String const& string_2) -> bool1;

auto print(String const& string) -> Result<>;

// NOLINTNEXTLINE This is forward declared in `<result>`.
auto print_line(String const& string) -> Result<>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

#include "./implementations/string_length.tpp"
