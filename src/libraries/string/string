// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <memory>
#include <span>
#include <type_traits>
#include <utility>

// Deprecated call to `memcpy()`. Consider using `cat::copy_buffer()` instead.
// `memcpy()` exists to enable some GCC optimizations.
extern "C" auto memcpy(void* p_destination, void const* p_source, usize bytes)
    -> void*;

namespace cat {

constexpr auto string_length(char const* p_string) -> ssize;

}  // namespace cat

#include "./implementations/string_length.tpp"

template <ssize length>
struct StaticString;

class String : public Span<char const> {
    // `String` inherits:
    //
    // `char const* p_storage;`
    // `ssize length;`
  public:
    constexpr String() : Span<char const>(){};

    // This is `auto` to deduce lower than the array-literal constructor.
    constexpr String(auto p_string)
        : Span<char const>(p_string, cat::string_length(p_string)){};

    constexpr String(char const* p_string, ssize in_length)
        : Span<char const>(p_string, in_length){};

    constexpr String(String const& string)
        : Span<char const>(string.p_storage, string.length){};

    constexpr String(String&& string)
        : Span<char const>(string.p_storage, string.length){};

    template <ssize other_length>
    consteval String(char const (&string)[other_length]) {
        this->p_storage = string;
        this->length = other_length;
    }

    // TODO: Make this `consteval`.
    template <ssize other_length>
    String(StaticString<other_length> const& string) {
        this->p_storage = &(string.storage[0]);
        this->length = other_length;
    }

    constexpr auto operator=(String const& string) {
        this->p_storage = string.p_storage;
        this->length = string.length;
    }

    constexpr auto operator=(String&& string) {
        this->p_storage = string.p_storage;
        this->length = cat::move(string).length;
    }
};

// TODO: Replace this with `Array`.
template <ssize length>
struct StaticString {
    char storage[length + 1];

    constexpr StaticString(char const (&in)[length]) : storage{} {
        for (int4 i = 0; i < length - 1; i++) {
            storage[i] = in[i];
        }
        storage[length] = '\0';
    }

    consteval StaticString(String const& in) : storage{} {
        for (int4 i = 0; i < in.size() - 1; i++) {
            storage[i] = in.p_data()[i];
        }
        storage[length] = '\0';
    }

    constexpr auto get_string() const {
        return this->storage;
    }

    constexpr auto size() const -> ssize {
        return length;
    }
};

// Concatenate constant-evaluated strings.
template <ssize length_1, ssize length_2>
consteval auto operator+(StaticString<length_1> const& string_1,
                         StaticString<length_2> const& string_2)
    -> StaticString<length_1 - 1 + length_2> {
    char array[length_1 - 1 + length_2];

    for (ssize i = 0; i < length_1 - 1; i++) {
        array[i] = string_1.storage[i];
    }

    for (ssize i = length_1 - 1; i < length_1 - 1 + length_2 - 1; i++) {
        array[i] = string_2.storage[i - length_1 + 1];
    }

    // Make this string null-terminated.
    array[length_1 - 1 + length_2 - 1] = '\0';
    StaticString static_string = array;
    return static_string;
}

namespace cat {

auto compare_strings(String const& string_1, String const& string_2) -> bool1;

auto print(String const& string) -> Result<>;

// NOLINTNEXTLINE This is forward declared in `<result>`.
auto print_line(String const& string) -> Result<>;

// TODO: Make a comparison function for null-terminated string pointers.

}  // namespace cat

#include "./implementations/string_length.tpp"
