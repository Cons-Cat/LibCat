// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* The Intel-style SIMD syntax is completely arbitrary in GCC. GNU implemented
 * it with wrapper libraries around their own more basic, arguably more
 * reasonable, compiler intrinsics which already understand arithmetic
 * operators, loads, sets, and many other common operations that Intel's wrap
 * inside a cumbersome interface. Then, authors of a SIMD wrapper library wrap
 * *those* wrappers with new ones to enhance their quality of life with features
 * that the basic compiler intrinsics largely already had. There are three
 * layers of technology to this for no reason!
 *
 * To streamline this, libCat uses the intrinsics which GNU already provides,
 * and wraps it in one thin layer of technology. */

// #include <string>
#include <type_traits>

namespace cat::detail {

// TODO: This comment is not currently accurate:
/* Vectors have weak alignment by default. It is up to users at call-site to
 * determine what alignment is appropriate for their use-case. All SIMD
 * functions are unaligned, which pays little, if any, penalty to aligned
 * vectors in modern implementations of SSE, AVX, and NEON architectures. */

template <typename T, ssize lanes>
struct alignas(4) Simd {
    static constexpr ssize width = lanes;
    using Scalar = T;
    /* `vector_size` is a GCC attribute that represents SIMD data-types.
     * `using` and `alignas` do not work on a builtin vector type. Generalized
     * attribute syntax also does not appear to work. */
    using Intrinsic [[gnu::vector_size(sizeof(T) * lanes), gnu::aligned(4)]] =
        T;
    Intrinsic value;

    constexpr Simd() = default;
    // TODO: Perfect forwarding.
    constexpr Simd(Intrinsic const& in_vector) {
        this->value = in_vector;
    }
    constexpr Simd(Simd<T, lanes> const& operand) {
        this->value = operand.value;
    }
    // TODO: It would be nice to get this to work:
    // template <typename... UList>
    // constexpr simd_vector(UList... values) {
    //     this->value((static_cast<T>(values))...);
    // }

    // TODO: `__builtin_convertvector()` wrapped by conversion operators.

    constexpr auto operator=(Simd<T, lanes> operand) -> Simd<T, lanes>& {
        this->value = operand.value;
        return *this;
    }

    constexpr auto operator==(Simd<T, lanes> const& operand) -> Simd<T, lanes> {
        return Simd<T, lanes>{.value = this->value == operand.value};
    }

    constexpr auto operator+(Simd<T, lanes> operand) -> Simd<T, lanes> {
        return Simd<T, lanes>{this->value + operand.value};
    }
    constexpr auto operator+=(Simd<T, lanes> const& operand)
        -> Simd<T, lanes>& {
        this->value = this->value + operand.value;
        return *this;
    }

    constexpr auto operator-(Simd<T, lanes> operand) -> Simd<T, lanes> {
        return Simd<T, lanes>{this->value - operand.value};
    }
    constexpr auto operator-=(Simd<T, lanes> const& operand)
        -> Simd<T, lanes>& {
        this->value = this->value - operand.value;
        return *this;
    }
};

}  // namespace cat::detail

// Vectors of up to 32 1-byte integers are supported by AVX2.
using int1x2 = cat::detail::Simd<int1, 2>;
using int1x4 = cat::detail::Simd<int1, 4>;
using int1x8 = cat::detail::Simd<int1, 8>;
using int1x16 = cat::detail::Simd<int1, 16>;
using int1x32 = cat::detail::Simd<int1, 32>;
using uint1x2 = cat::detail::Simd<uint1, 2>;
using uint1x4 = cat::detail::Simd<uint1, 4>;
using uint1x8 = cat::detail::Simd<uint1, 8>;
using uint1x16 = cat::detail::Simd<uint1, 16>;
using uint1x32 = cat::detail::Simd<uint1, 32>;

/* Strings need their own vectors because uint1 and int1 are incompatible with
 * some intrinsic functions.*/
using charx2 = cat::detail::Simd<char, 2>;
using charx4 = cat::detail::Simd<char, 4>;
using charx8 = cat::detail::Simd<char, 8>;
using char1x16 = cat::detail::Simd<char, 16>;
using charx32 = cat::detail::Simd<char, 32>;

// Vectors of up to 16 2-byte integers are supported by AVX2.
using int2x2 = cat::detail::Simd<int2, 2>;
using int2x4 = cat::detail::Simd<int2, 4>;
using int2x8 = cat::detail::Simd<int2, 8>;
using int2x16 = cat::detail::Simd<int2, 16>;
using uint2x2 = cat::detail::Simd<uint2, 2>;
using uint2x4 = cat::detail::Simd<uint2, 4>;
using uint2x8 = cat::detail::Simd<uint2, 8>;
using uint2x16 = cat::detail::Simd<uint2, 16>;

// Vectors of up to 8 4-byte integers are supported by AVX2.
using int4x2 = cat::detail::Simd<int4, 2>;
using int4x4 = cat::detail::Simd<int4, 4>;
using int4x8 = cat::detail::Simd<int4, 8>;
using uint4x2 = cat::detail::Simd<uint4, 2>;
using uint4x4 = cat::detail::Simd<uint4, 4>;
using uint4x8 = cat::detail::Simd<uint4, 8>;

// Vectors of up to 4 8-byte integers are supported by AVX2.
using int8x2 = cat::detail::Simd<int8, 2>;
using int8x4 = cat::detail::Simd<int8, 4>;
using uint8x2 = cat::detail::Simd<uint8, 2>;
using uint8x4 = cat::detail::Simd<uint8, 4>;

// Vectors of up to 8 4-byte floats are supported by AVX2.
using float4x2 = cat::detail::Simd<float4, 2>;
using float4x4 = cat::detail::Simd<float4, 4>;
using float4x8 = cat::detail::Simd<float4, 8>;

// TODO: Evaluate what support for 8-byte ints exists in x86-64.
//
// Vectors of up to 4 8-byte floats are supported by AVX2.
using float8x2 = cat::detail::Simd<float8, 2>;
using float8x4 = cat::detail::Simd<float8, 4>;

// Vectors of up to 32 1-byte bools are supported by AVX2.
using bool1x2 = cat::detail::Simd<bool1, 2>;
using bool1x4 = cat::detail::Simd<bool1, 4>;
using bool1x8 = cat::detail::Simd<bool1, 8>;
using bool1x16 = cat::detail::Simd<bool1, 16>;
using bool1x32 = cat::detail::Simd<bool1, 32>;

// Vectors of up to 16 2-byte bools are supported by AVX2.
using bool2x2 = cat::detail::Simd<bool2, 2>;
using bool2x4 = cat::detail::Simd<bool2, 4>;
using bool2x8 = cat::detail::Simd<bool2, 8>;
using bool2x16 = cat::detail::Simd<bool2, 16>;

// Vectors of up to 8 4-byte bools are supported by AVX2.
using bool4x2 = cat::detail::Simd<bool4, 2>;
using bool4x4 = cat::detail::Simd<bool4, 4>;
using bool4x8 = cat::detail::Simd<bool4, 8>;

namespace simd {

enum class StringControl : unsigned char {
    // Unsigned 1-byte characters.
    unsigned_byte = 0x00,
    // Unsigned 2-byte characters.
    unsigned_word = 0x01,
    // Signed 1-byte characters.
    signed_byte = 0x02,
    // Signed 2-byte characters.
    signed_word = 0x03,
    // Compare if any characters are equal.
    compare_equal_any = 0x00,
    // Compare ranges.
    compare_ranges = 0x04,
    // Compare if every character is equal.
    compare_equal_each = 0x08,
    // Compare equal ordered.
    compare_equal_ordered = 0x0c,
    // Polarity.
    positive_polarity = 0x00,
    // Negate the results.
    negative_polarity = 0x10,
    masked_positive_polarity = 0x20,
    // Negate the results only before the end of the string.
    masked_negative_polarity = 0x30,
    // Return the least significant bit.
    least_significant = 0x00,
    // Return the most significant bit.
    most_significant = 0x40,
    // Return a bit mask.
    bit_mask = 0x00,
    // Return a byte/word mask.
    unit_mask = 0x40,
};

// TODO: Generalize this.
constexpr auto operator|(StringControl flag_1, StringControl flag_2)
    -> StringControl {
    return static_cast<StringControl>(static_cast<unsigned char>(flag_1) |
                                      static_cast<unsigned char>(flag_2));
}

template <typename T>
consteval auto set_zeros() -> T;

// TODO: Use a vector concept.
auto shuffle(auto in_vector, auto mask);

// TODO: Make this const-correct.
template <uint4 Width>
constexpr auto p_string_to_p_vector(meta::string auto p_string) {
    using U = cat::detail::Simd<char, Width>;
    return meta::bit_cast<U*>(p_string);
}

template <StringControl control_mask>
constexpr auto compare_implicit_length_strings(auto const& vector_1,
                                               auto const& vector_2) -> bool1;

template <StringControl control_mask>
constexpr auto compare_implicit_length_strings_return_index(
    auto const& vector_1, auto const& vector_2) -> int4;

// TODO: Add `simd::mfence` and `simd::lfence`.
void sfence();
void zero_avx_registers();
void zero_upper_avx_registers();

// Constants for prefetch.
enum MM_HINT {
    // MM_HINT_ET is MM_HINT_T with set 3rd bit.
    MM_HINT_ET0 = 7,
    MM_HINT_ET1 = 6,
    MM_HINT_T0 = 3,
    MM_HINT_T1 = 2,
    MM_HINT_T2 = 1,
    MM_HINT_NTA = 0
};

// This will not compile as a function.
#define prefetch(p_source, hint) \
    { __builtin_prefetch((p_source), (hint)&0x4 >> 2, (hint)&0x3); }

template <typename T>
void stream_in(void* p_destination, T const* p_source);

template <typename T>
auto move_mask(T vector) -> int4 {
    if constexpr (sizeof(typename T::Scalar) == 1) {
        return __builtin_ia32_pmovmskb256(
            meta::bit_cast<cat::detail::Simd<char, vector.width>>(vector)
                .value);
    } else {
        // TODO: Support additional vector sizes.
        static_assert("BAD!");
    }
}

}  // namespace simd

/* TODO: __builtin_cpu_init()
 * must be called before these. */

auto is_mmx_supported() -> bool1;
auto is_sse1_supported() -> bool1;
auto is_sse2_supported() -> bool1;
auto is_sse3_supported() -> bool1;
auto is_ssse3_supported() -> bool1;
auto is_sse4_1_supported() -> bool1;
auto is_sse4_2_supported() -> bool1;
auto is_avx_supported() -> bool1;
auto is_avx2_supported() -> bool1;
auto is_avx512f_supported() -> bool1;
auto is_avx512vl_supported() -> bool1;

// clang-format off
#include "./implementations/compare_implicit_length_strings.tpp"
#include "./implementations/compare_implicit_length_strings_return_index.tpp"
#include "./implementations/set_zeros.tpp"
#include "./implementations/shuffle.tpp"
#include "./implementations/stream_in.tpp"
// clang-format on
