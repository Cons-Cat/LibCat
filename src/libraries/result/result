// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <concepts>
#include <type_traits>
#include <utility>

/* This file contains a general-purpose error-handling tool. Result<> is a
 * templated struct that either contains some data (unless it holds void) or an
 * error-code. The error-code is an 8-byte value that can be either an integer
 * or a pointer to a string that may be printed. To extract a value out of a
 * result, call one of its member functions.
 *
 * An error code or string pointer must be wrapped in a Failure, such as:
 ** return Failure(1);
 *
 * Otherwise, it is presumed that a Result holds a value rather than an error.
 * This is done to prevent monomorphizing the Result on its error types like
 * Rust, which provides type-safety at the cost of pessimized compiler-times and
 * runtime overhead. This Result is a zero-overhead abstraction over C-style
 * error handling.
 *
 * A Failure is implicitly convertible into a Result, and a T is implicitly
 * convertible into a Result<T>.
 *
 * Result types are marked [[nodiscard]]. With confidence that an invocation of
 * a function returning a Result will never fail, you may call .unsafe_value(),
 * which will skip error-handling when compiler optimizations are enabled. */

template <typename T = void>
struct Result;

struct [[nodiscard]] Failure {
    ssize code;

    // TODO: Rethink Error and Result constructors.
    Failure() = default;

    // This must be explicit to disambiguate returning an integer to a Result.
    explicit Failure(ssize in_code) {
        code = static_cast<ssize>(in_code);
    }

    template <typename T>
    operator Result<T>() const {
        return Result<T>(code);
    }

    template <typename T>
    constexpr operator T() const
        // TODO: Make is_bool<> traits.
        requires(meta::is_same_v<T, ssize>() || meta::is_same_v<T, bool>) {
        return code;
    }

    auto operator==(Failure operand) const -> bool {
        return this->code == operand.code;
    }
};

namespace std::detail {
struct Okay {};
}  // namespace std::detail

// `okay` may be returned in a function that returns `Result<void>`.
constexpr std::detail::Okay okay{};

// These forward declarations are necessary for `Result`.
template <typename T>
struct Result;
struct StringView;
namespace std {
auto print_line(StringView const&) -> Result<>;
}

// `Result<>` is a general-purpose failure-handling object.
template <typename T>
struct [[nodiscard]] Result {
    Failure failure_code;  // `Failure` is an 8-byte value.
    /* `char` should be a relatively unintrusive dummy data for when this holds
     * void. Reflection TS in future C++ will provide conditional-members, which
     * would be a better solution. TODO: Solve this with a partial template
     * specialization. */
    using ValueType = meta::conditional_t<meta::is_void_v<T>, char, T>;
    static constexpr bool is_void = meta::is_same_v<T, void>;

    /* It is unsafe to access `value`. You may prefer `or_panic_debug()` which
     * provides failure-handling in debug builds, and skips them in optimized
     * builds. */
    ValueType const value;

    bool const is_okay;

    constexpr Result(Failure in_code)
        : failure_code(in_code), value(), is_okay(false) {
    }
    constexpr Result(ValueType in_value) requires(!is_void)
        : failure_code(), value(in_value), is_okay(true) {
    }
    // Special-case consuming data when holding `void`. This includes `okay`.
    constexpr Result(auto) requires(is_void)
        : failure_code(), value(), is_okay(true) {
    }
    // TODO: Concept for `bool1`, `bool2`, and `bool4` as well.
    constexpr Result(bool const&& expression) requires(is_void)
        : value(), is_okay(expression) {
    }
    /* Implicity cast an inputted `Result` to this. This is useful for
     * `Result<Any>`. */
    template <typename U>
    constexpr Result(Result<U>&& in_result) requires(!is_void)
        : value(meta::bit_cast<T>(in_result.value)),
          is_okay(in_result.is_okay) {
    }

    // Return a specified value when `is_okay` is `false`.
    constexpr auto or_is(ValueType const& in_value) -> ValueType {
        if (!is_okay) {
            return in_value;
        }
        return this->value;
    }

    // `nullptr` must be special-cased.
    constexpr auto or_is(decltype(nullptr) in_value) -> ValueType
    /* requires(meta::is_pointer_v<ValueType>) */ {
        if (!is_okay) {
            return static_cast<ValueType>(in_value);
        }
        return this->value;
    }

    // TODO: Add a `meta::invokable` concept
    constexpr auto or_do(auto callback) -> T {
        if (!is_okay) {
            return callback();
        }
        if constexpr (!is_void) {
            return this->value;
        }
    }

    // This method does not yield `value`. It is useful for side-effectful
    // functions.
    constexpr void discard_result(){};

    // TODO: Pass in the exit code and error message with overloads.
    auto or_panic() -> T {
        if (is_okay) {
            if constexpr (!is_void) {
                return this->value;
            } else if constexpr (is_void) {
                return;
            }
        }
        std::exit(1);
        __builtin_unreachable();  // This prevents a build warning.
    }

    /* Because the error code is 8-bytes, it could contain a non-null
     * pointer to an error string. This prints that error message. */
    auto or_panic(StringView const& p_error_message) -> T {
        if (is_okay) {
            if constexpr (!is_void) {
                return this->value;
            } else if constexpr (is_void) {
                return;
            }
        }
        std::print_line(p_error_message).discard_result();
        std::exit(1);
    }

    /* If this object does not hold a value, the return of this function is
     * undefined. When building `-O0`, this function panics if a value is not
     * held. When optimizations are enabled, that safety check is elided. This
     * function cannot fail in a `constexpr` context. */
    constexpr void or_panic_debug() {
        if (!meta::is_constant_evaluated()) {
#ifndef __OPTIMIZE__
            if (is_okay) {
                if constexpr (!is_void) {
                    return this->value;
                } else if constexpr (is_void) {
                    return;
                }
            }
            std::exit(1);
#endif
        }
        // Unconditionally return `value`.
        if constexpr (!is_void) {
            return this->value;
        } else if constexpr (is_void) {
            return;
        }
    }

    /* If this object does not hold a value, the return of this function is
     * undefined. When building `-O0`, this function panics if a value is not
     * held. When optimizations are enabled, that safety check is elided. This
     * function cannot fail in a `constexpr` context. */
    constexpr auto or_panic_debug(StringView const& error_message) -> T {
        if (!meta::is_constant_evaluated()) {
#ifndef __OPTIMIZE__
            if (is_okay) {
                if constexpr (!is_void) {
                    return this->value;
                } else if constexpr (is_void) {
                    return;
                }
            }
            std::print_line(error_message).discard_result();
            std::exit(1);
#endif
        }
        // Unconditionally return `value`.
        if constexpr (!is_void) {
            return this->value;
        } else if constexpr (is_void) {
            return;
        }
    }
};
