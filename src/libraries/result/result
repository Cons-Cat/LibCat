// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <concepts>
#include <type_traits>
#include <utility>

/* This file contains a general-purpose error-handling tool. `Result<>` is a
 * templated struct that either contains some data (unless it holds `void`) or
 * a error code. The code is an 8-byte value that can be either an integer
 * or a pointer to a string that may be printed. To extract a value out of a
 * `Result`, call one of its member functions.
 *
 * An error code or string pointer must be wrapped by a `Failure`, such as:
 * `return Failure(1);`
 *
 * Otherwise, it is presumed that a `Result` holds a value rather than a
 * `Failure`. This is done to prevent monomorphizing the `Result` on its error
 * types like a variant type, which provides type-safety at the cost of
 * pessimized build-times and runtime overhead. This `Result` is a zero-overhead
 * abstraction over C-style error handling.
 *
 * A `Failure` is implicitly convertible into a `Result`, and a `T` is
 * implicitly convertible into a `Result<T>`. A `Result<T>` is implicitly
 * convertible into a `Result<>`, to aid some low-level routines.
 *
 * `Result` types are marked `[[nodiscard]]`. With confidence that an invocation
 * of a function returning a `Result` will never fail, you may call
 * `.assert()`, which will skip error-handling when compiler
 * optimizations are enabled. A `Result` cannot be consumed by the `_` global.
 */

template <typename T = void>
class Result;

struct [[nodiscard]] Failure {
    ssize code;

    // The default constructor should only be called by `Result`.
    Failure() = default;

    // This must be explicit to disambiguate returning an integer to a Result.
    explicit Failure(ssize const in_code) : code(in_code){};

    // `Failure` can consume any `enum class`.
    template <meta::enum_class T>
    constexpr Failure(T in_code)
        : code(static_cast<meta::underlying_type_t<T>>(in_code)){};

    template <typename T>
    constexpr operator T() const
        // TODO: Make an `is_bool<>` trait to support libCat's safe bools.
        requires(meta::is_same_v<T, ssize>() || meta::is_same_v<T, bool>) {
        return this->code;
    }

    auto operator==(Failure operand) const -> bool {
        return this->code == operand.code;
    }
};

namespace cat::detail {
struct Okay {};
}  // namespace cat::detail

// `okay` may be returned in a function that returns `Result<void>`.
inline constexpr cat::detail::Okay okay{};

// These forward declarations are necessary for `Result`.
template <typename T>
class Result;
struct StringView;

// Forward-declare a print function for panics.
namespace cat {
auto print_line(StringView const&) -> Result<>;
}

// `Result<>` is a general-purpose failure-handling object.
template <typename T>
class [[nodiscard]] Result {
  public:
    Failure failure_code;  // `Failure` is an 8-byte value.
    static_assert(sizeof(Failure) == 8);

    // `char` should be a relatively unintrusive dummy data for when this holds
    // `void`. Reflection TS in future C++ will provide conditional-members,
    // which would be a better solution.
    // TODO: Solve this with a partial template specialization.
    using ValueType = meta::conditional_t<meta::is_void_v<T>, char, T>;
    static constexpr bool is_void = meta::is_same_v<T, void>;

    ValueType storage;
    bool1 is_okay;
  public:
    constexpr Result(Failure const& failure)
        : failure_code(failure), is_okay(false){};

    constexpr Result(ValueType const value) requires(
        !is_void && meta::is_constructible_v<ValueType> &&
        !meta::is_same_v<ValueType, Any>)
        : storage(value), is_okay(true){};

    // If this holds `void`, any specialization of `Result<>` or an `okay` can
    // convert into this.
    template <typename U>
    constexpr Result(U const) requires(
        is_void && (meta::is_specialization<U, Result>::value ||
                    meta::is_same_v<U, cat::detail::Okay>))
        : is_okay(true){};

    // TODO: Trivially and non-trivially Copy and move construct `ValueType`.

    // constexpr Result(ValueType const& value) requires(
    //     !is_void && meta::is_trivially_copy_constructible_v<ValueType>)
    //     : storage(value), is_okay(true) {
    // }

    // constexpr Result(ValueType&& value) requires(
    //     !is_void && meta::is_trivially_move_constructible_v<ValueType> &&
    //     !meta::is_same_v<ValueType, Any>)
    //     : storage(value), is_okay(true){};

    // Implicity cast an inputted compatible `Result` to this.
    template <typename U>
    constexpr Result(Result<U> const result) requires(
        !is_void && meta::is_default_constructible<U>::value &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Implicity cast an inputted compatible `Result` to this.
    template <typename U>
    constexpr Result(Result<U> const& result) requires(
        !is_void && meta::is_trivially_copy_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Implicity cast an inputted compatible `Result` to this.
    template <typename U>
    constexpr Result(Result<U>&& result) requires(
        !is_void && meta::is_trivially_move_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    template <typename U>
    constexpr Result(Result<U> const&& result) requires(
        !is_void && meta::is_trivially_move_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Special-case consuming a `Result<void>`.
    constexpr Result(Result<void> const& result) requires(!is_void)
        : is_okay(result.is_okay){};

    // Special-case consuming a `Result<Any>`.
    constexpr Result(Result<Any> const& result) requires(!is_void)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Special-case consuming an `Any>`.
    constexpr Result(Any const result) requires(!is_void)
        : storage(static_cast<T>(result)), is_okay(true){};

    // TODO: Concept for `bool1`, `bool2`, and `bool4` as well.
    // Consume a `bool` temporary. This is useful for debugging with asserts.
    constexpr Result(bool const& expression) requires(is_void)
        : storage(), is_okay(expression){};

    constexpr Result(bool&& expression) requires(is_void)
        : storage(), is_okay(meta::move(expression)){};

    constexpr auto value() {
        if (meta::is_constant_evaluated()) {
            if constexpr (is_void) {
                return this->storage;
            }
            return;
        }
#ifdef __OPTIMIZE__
        return this->storage;
#else
        if (this->is_okay) [[likely]] {
            if constexpr (is_void) {
                return this->storage;
            }
            return;
        }
        // TODO: Print an error message.
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    // Return a specified value when `is_okay` is `false`.
    constexpr auto value_or(ValueType const& value) -> ValueType {
        if (!this->is_okay) {
            return value;
        }
        return this->storage;
    }

    // `nullptr` must be special-cased.
    constexpr auto value_or(decltype(nullptr) value) -> ValueType {
        if (!this->is_okay) {
            return static_cast<ValueType>(value);
        }
        return this->storage;
    }

    // If this non-`const`-qualified `Result` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Result`.
    template <typename Function>
    constexpr auto transform(Function&& callback) & {
        if (this->is_okay) {
            return Result<T>(meta::forward<Function>(callback)(this->storage));
        }
        return *this;
    }

    // If this `const`-qualified `Result` holds a value, transform it by a
    // non-`void` function without side-effects. Otherwise, propagate an empty
    // `Result`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const& {
        if (this->is_okay) {
            return Result<T>(meta::forward<Function>(callback(this->storage)));
        }
        return *this;
    }

    // Invoke a callback on the value of a non-`const`-qualified `Result` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) & {
        return this->is_okay
                   ? Result<T>(meta::forward<Function>(callback)(this->storage))
                   : *this;
    }

    // Invoke a callback on the value of a `const`-qualified `Result` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const& {
        return this->is_okay
                   ? Result<T>(meta::forward<Function>(callback)(this->storage))
                   : *this;
    }

    // TODO: Add a `meta::invokable` concept.
    // TODO: This does work with `void` and non-`void`.
    // Invoke a callback if a non-`const`-qualified `Result` holds no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) -> Result<T> {
        if (!this->is_okay) {
            return meta::forward<Function>(callback)();
        }
        if constexpr (!is_void) {
            return this->storage;
        }
    }

    // TODO: Add a `meta::invokable` concept.
    // TODO: This does work with `void` and non-`void`.
    // Invoke a callback if a `const`-qualified `Result` holds no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) const -> Result<T> {
        if (!this->is_okay) {
            return meta::forward<Function>(callback)();
        }
        if constexpr (!is_void) {
            return this->storage;
        }
    }

    // This method does not yield any value. It is useful for impure functions.
    constexpr void discard_result(){};

    // TODO: Pass in the exit code and error message with overloads.
    auto or_panic() -> T {
        if (is_okay) [[likely]] {
            if constexpr (!is_void) {
                return this->storage;
            } else if constexpr (is_void) {
                return;
            }
        }
        cat::exit(1);
        __builtin_unreachable();  // This prevents a build warning.
    }

    // TODO: Make this work.
    // Because the error code is 8-bytes, it could contain a non-null
    // pointer to an error string. This prints that error message.
    auto or_panic(StringView const& error_message) -> T {
        if (is_okay) [[likely]] {
            if constexpr (!is_void) {
                return this->storage;
            } else if constexpr (is_void) {
                return;
            }
        }
        cat::print_line(error_message).discard_result();
        cat::exit(1);
        __builtin_unreachable();  // This prevents a build warning.
    }

    // When building `-O0`, this function panics if a value is not
    // held. When optimizations are enabled, that safety check is elided.
    constexpr auto assert() const {
        if (meta::is_constant_evaluated()) {
            return;
        }
#ifndef __OPTIMIZE__
        if (!this->is_okay) [[unlikely]] {
            cat::exit(1);
        }
#endif
    }

    // TODO: Make this work.
    // When building `-O0`, this function panics if a value is not
    // held. When optimizations are enabled, that safety check is elided.
    constexpr auto assert(StringView const& error_message) {
        if (meta::is_constant_evaluated()) {
            return;
        }
#ifndef __OPTIMIZE__
        if (!this->is_okay) {
            cat::print_line(error_message).discard_result();
            cat::exit(1);
        }
#endif
    }
};
