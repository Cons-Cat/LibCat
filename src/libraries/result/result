// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <concepts>
#include <type_traits>
#include <utility>

/* This file contains a general-purpose error-handling tool. `Result<>` is a
 * templated struct that either contains some data (unless it holds `void`) or
 * a error code. The code is an 8-byte value that can be either an integer
 * or a pointer to a string that may be printed. To extract a value out of a
 * `Result`, call one of its member functions.
 *
 * An error code or string pointer must be wrapped by a `Failure`, such as:
 * `return Failure(1);`
 *
 * Otherwise, it is presumed that a `Result` holds a value rather than a
 * `Failure`. This is done to prevent monomorphizing the `Result` on its error
 * types like a variant type, which provides type-safety at the cost of
 * pessimized build-times and runtime overhead. This `Result` is a zero-overhead
 * abstraction over C-style error handling.
 *
 * A `Failure` is implicitly convertible into a `Result`, and a `T` is
 * implicitly convertible into a `Result<T>`. A `Result<T>` is implicitly
 * convertible into a `Result<>`, to aid some low-level routines.
 *
 * `Result` types are marked `[[nodiscard]]`. With confidence that an invocation
 * of a function returning a `Result` will never fail, you may call
 * `.or_panic_debug()`, which will skip error-handling when compiler
 * optimizations are enabled. A `Result` cannot be consumed by the `_` global.
 */

template <typename T = void>
struct Result;

struct [[nodiscard]] Failure {
    ssize code;

    // The default constructor should only be called by `Result`.
    Failure() = default;

    // This must be explicit to disambiguate returning an integer to a Result.
    explicit Failure(ssize const in_code) : code(in_code){};

    // `Failure` can consume any `enum class`.
    template <meta::enum_class T>
    constexpr Failure(T in_code)
        : code(static_cast<meta::underlying_type_t<T>>(in_code)){};

    template <typename T>
    constexpr operator T() const
        // TODO: Make an `is_bool<>` trait to support libCat's safe bools.
        requires(meta::is_same_v<T, ssize>() || meta::is_same_v<T, bool>) {
        return this->code;
    }

    auto operator==(Failure operand) const -> bool {
        return this->code == operand.code;
    }
};

namespace cat::detail {
struct Okay {};
}  // namespace cat::detail

// `okay` may be returned in a function that returns `Result<void>`.
inline constexpr cat::detail::Okay okay{};

// These forward declarations are necessary for `Result`.
template <typename T>
class Result;
struct StringView;

// Forward-declare a print function for panics.
namespace cat {
auto print_line(StringView const&) -> Result<>;
}

// `Result<>` is a general-purpose failure-handling object.
template <typename T>
class [[nodiscard]] Result {
  public:
    Failure failure_code;  // `Failure` is an 8-byte value.

    // `char` should be a relatively unintrusive dummy data for when this holds
    // `void`. Reflection TS in future C++ will provide conditional-members,
    // which would be a better solution.
    // TODO: Solve this with a partial template specialization.
    using ValueType = meta::conditional_t<meta::is_void_v<T>, char, T>;
    static constexpr bool is_void = meta::is_same_v<T, void>;

    ValueType storage;
    bool1 is_okay;
  public:
    constexpr Result(Failure const& failure)
        : failure_code(failure), is_okay(false){};

    constexpr Result(ValueType const value) requires(
        !is_void && meta::is_constructible_v<ValueType> &&
        !meta::is_same_v<ValueType, Any>)
        : storage(value), is_okay(true){};

    // constexpr Result(ValueType const& value) requires(
    //     !is_void && meta::is_trivially_copy_constructible_v<ValueType>)
    //     : storage(value), is_okay(true) {
    // }

    // constexpr Result(ValueType const&& value) requires(
    //     !is_void && meta::is_trivially_move_constructible_v<ValueType> &&
    //     !meta::is_same_v<ValueType, Any>)
    //     : storage(value), is_okay(true){};

    // Implicity cast an inputted `Result` to this. This is useful for
    // `Result<Any>`.
    template <typename U>
    constexpr Result(Result<U> const result) requires(
        !is_void && meta::is_default_constructible<U>::value &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Implicity cast an inputted `Result` to this. This is useful for
    // `Result<Any>`.
    template <typename U>
    constexpr Result(Result<U> const& result) requires(
        !is_void && meta::is_trivially_copy_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Implicity cast an inputted `Result` to this. This is useful for
    // `Result<Any>`.
    template <typename U>
    constexpr Result(Result<U>&& result) requires(
        !is_void && meta::is_trivially_move_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    template <typename U>
    constexpr Result(Result<U> const&& result) requires(
        !is_void && meta::is_trivially_move_constructible_v<U> &&
        meta::is_convertible_v<T, U> && !meta::is_same_v<U, Any>)
        : storage(static_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Special-case consuming a `Result<void>`.
    constexpr Result(Result<void> const& result) requires(!is_void)
        : is_okay(result.is_okay){};

    // Special-case consuming a `Result<Any>`.
    constexpr Result(Result<Any> const& result) requires(!is_void)
        : storage(meta::bit_cast<T>(result.storage)), is_okay(result.is_okay){};

    // Special-case consuming an `Any>`.
    constexpr Result(Any const result) requires(!is_void)
        : storage(meta::bit_cast<T>(result)), is_okay(true){};

    // TODO: Concept for `bool1`, `bool2`, and `bool4` as well.
    // Consume a `bool` temporary. This is useful for debugging with asserts.
    constexpr Result(bool const& expression) requires(is_void)
        : storage(), is_okay(expression){};

    // Special-case consuming `okay` when holding `void`.
    constexpr Result(auto) requires(is_void) : is_okay(true){};
    // constexpr Result(cat::detail::Okay) requires(is_void) : is_okay(true){};

    // Return a specified value when `is_okay` is `false`.
    constexpr auto or_is(ValueType const& in_value) -> ValueType {
        if (!is_okay) {
            return in_value;
        }
        return this->storage;
    }

    // `nullptr` must be special-cased.
    constexpr auto or_is(decltype(nullptr) in_value) -> ValueType
    /* requires(meta::is_pointer_v<ValueType>) */ {
        if (!is_okay) {
            return static_cast<ValueType>(in_value);
        }
        return this->storage;
    }

    // TODO: Add a `meta::invokable` concept
    constexpr auto or_do(auto callback) -> T {
        if (!is_okay) {
            return callback();
        }
        if constexpr (!is_void) {
            return this->storage;
        }
    }

    // This method does not yield `value`. It is useful for impure functions.
    constexpr void discard_result(){};

    // TODO: Pass in the exit code and error message with overloads.
    auto or_panic() -> T {
        if (is_okay) {
            if constexpr (!is_void) {
                return this->storage;
            } else if constexpr (is_void) {
                return;
            }
        }
        cat::exit(1);
        __builtin_unreachable();  // This prevents a build warning.
    }

    /* Because the error code is 8-bytes, it could contain a non-null
     * pointer to an error string. This prints that error message. */
    auto or_panic(StringView const& p_error_message) -> T {
        if (is_okay) {
            if constexpr (!is_void) {
                return this->storage;
            } else if constexpr (is_void) {
                return;
            }
        }
        cat::print_line(p_error_message).discard_result();
        cat::exit(1);
        __builtin_unreachable();  // This prevents a build warning.
    }

    /* If this object does not hold a value, the return of this function is
     * undefined. When building `-O0`, this function panics if a value is not
     * held. When optimizations are enabled, that safety check is elided. This
     * function cannot fail in a `constexpr` context. */
    constexpr void or_panic_debug() {
        if (!meta::is_constant_evaluated()) {
#ifndef __OPTIMIZE__
            if (is_okay) {
                if constexpr (!is_void) {
                    return this->storage;
                } else if constexpr (is_void) {
                    return;
                }
            }
            cat::exit(1);
#endif
        }
        // Unconditionally return `value`.
        if constexpr (!is_void) {
            return this->storage;
        } else if constexpr (is_void) {
            return;
        }
    }

    /* If this object does not hold a value, the return of this function
     * is undefined. When building `-O0`, this function panics if a
     * value is not held. When optimizations are enabled, that safety
     * check is elided. This function cannot fail in a `constexpr`
     * context. */
    constexpr auto or_panic_debug(StringView const& error_message) -> T {
        if (!meta::is_constant_evaluated()) {
#ifndef __OPTIMIZE__
            if (is_okay) {
                if constexpr (!is_void) {
                    return this->storage;
                } else if constexpr (is_void) {
                    return;
                }
            }
            cat::print_line(error_message).discard_result();
            cat::exit(1);
#endif
        }
        // Unconditionally return `value`.
        if constexpr (!is_void) {
            return this->storage;
        } else if constexpr (is_void) {
            return;
        }
    }
};
