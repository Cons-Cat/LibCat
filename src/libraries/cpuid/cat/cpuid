// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/arithmetic>
#include <cat/array>
#include <cat/bitset>
#include <cat/debug>

namespace x64 {

auto
cpuid(cat::uint4 leaf, cat::uint4 subleaf = 0u) -> cat::array<cat::uint4, 4> {
   cat::uint4 ebx;
   cat::uint4 edx;
   asm("cpuid"
       : "+a"(leaf), "+b"(ebx), "+c"(subleaf), "=d"(edx));
   return {leaf, ebx, subleaf, edx};
}

namespace detail {

enum class processor_features : unsigned char {
   cmov = 0,
   mmx,
   popcnt,
   sse,
   sse2,
   sse3,
   ssse3,
   sse4_1,
   sse4_2,
   avx,
   avx2,
   sse4_a,
   fma4,
   xop,
   fma,
   avx512_f,
   bmi,
   bmi2,
   aes,
   pclmul,
   avx512_vl,
   avx512_bw,
   avx512_dq,
   avx512_cd,
   avx512_er,
   avx512_pf,
   avx512_vbmi,
   avx512_ifma,
   avx5124_vnniw,
   avx5124_fmaps,
   avx512_vpopcntdq,
   avx512_vbmi2,
   gfni,
   vpclmulqdq,
   avx512_vnni,
   avx512_bitalg,
   avx512_bf16,
   avx512_vp2_intersect,
   adx = 40,
   cldemote = 42,
   clflushopt,
   clwb,
   clzero,
   cmpxchg16_b,
   enqcmd = 48,
   f16_c,
   fsgsbase,
   lahf_lm = 54,
   lm,
   lwp,
   lzcnt,
   movbe,
   movdir64_b,
   movdiri,
   mwaitx,
   pconfig = 63,
   pku,
   prefetchwt1,
   prfchw,
   ptwrite,
   rdpid,
   rdrnd,
   rdseed,
   rtm,
   serialize,
   sgx,
   sha,
   shstk,
   tbm,
   tsxldtrk,
   vaes,
   waitpkg,
   wbnoinvd,
   xsave,
   xsavec,
   xsaveopt,
   xsaves,
   amx_tile,
   amx_int8,
   amx_bf16,
   uintr,
   hreset,
   kl,
   feature_aeskle,
   widekl = 92,
   avxvnni,
   avx512_fp16,
   x86_64_baseline,
   x86_64_v2,
   x86_64_v3,
   x86_64_v4,
   avxifma,
   avxvnniint8,
   avxneconvert,
   cmpccxadd,
   amx_fp16,
   prefetchi,
   raoint,
   amx_complex,
   avxvnniint16,
   sm3,
   sha512,
   sm4,
   apxf,
   usermsr,
   avx10_1_256,
   avx10_1_512,
   avx10_2_256,
   avx10_2_512,
};

consteval auto
default_cpu_features() -> cat::bitset<32> {
   using enum processor_features;
   cat::bitset<32> features{};

   auto enable_feature = [&](processor_features const feature) {
      cat::idx const feature_index = cat::to_underlying(feature);
      features[feature_index].set();
   };

   enable_feature(cmov);
   enable_feature(mmx);
   enable_feature(sse);
   enable_feature(sse2);

   return features;
}

consteval auto
enable_baseline_feature() -> cat::bitset<32> {
   cat::bitset<32> baseline_flag{};
   baseline_flag[cat::to_underlying(processor_features::x86_64_baseline) % 32]
      .set();
   return baseline_flag;
}

struct cpu_model {
   cat::uint4 m_cpu_vendor = 0u;
   cat::uint4 m_cpu_type = 0u;
   cat::uint4 m_cpu_subtype = 0u;
   // Initialize this with all feature flags that are presumed present in any
   // x86-64 environment.
   cat::bitset<32> m_cpu_features = default_cpu_features();
};

extern "C" constinit inline detail::cpu_model __cpu_model{};  // NOLINT

// Extended x86 feature flags, such as AVX2. This is zero-intialized except for
// a single bit that expresses baseline x86-64 feature support.
extern "C" constinit inline cat::array<cat::bitset<32>, 3>
   // NOLINTNEXTLINE
   __cpu_features2(cat::bitset<32>{}, enable_baseline_feature(),
                   cat::bitset<32>{});

extern "C" inline void
__cpu_indicator_init() {  // NOLINT
   using enum processor_features;

   // Get highest values for `%EAX` below and above `0x80000000u`.
   auto&& [max_leaf, _, _, _] = cpuid(0u);
   auto&& [max_extended_leaf, _, _, _] = cpuid(0x80000000u);

   auto&& [eax, _, ecx, _] = cpuid(1u);
   cat::bitset ecx_bits = cat::bitset<32>::from(ecx);

   // Use this information to fill out x86 family model and available features.

   // Extract bits 4 through 7.
   cat::uint4 cpu_model = (eax >> 4u) & 0xfu;
   // Extract bits 8 through 11.
   cat::uint4 cpu_family = (eax >> 8u) & 0xfu;

   if (cpu_family == 6u || cpu_family == 0xfu) {
      // Bits 16 through 19.
      cpu_model += ((eax >> 16u) & 0xfu) << 4u;

      if (cpu_family == 0xfu) {
         // Bits 20 through 27.
         cpu_family += (eax >> 20u) & 0xffu;
      }
   }

   // This is an array of 4 zero-initialized bitsets rather than a single
   // `bitset<128>` to more directly map to LLVM's `__cpu_model` and
   // `__cpu_features2` ABI.
   cat::array<cat::bitset<32>, 4> feature_flags{};

   auto enable_feature = [&](processor_features const feature) {
      cat::idx const feature_index = cat::to_underlying(feature);
      feature_flags[feature_index / 32][feature_index % 32].set();
   };
   auto has_feature = [&](processor_features const feature) -> bool {
      cat::idx const feature_index = cat::to_underlying(feature);
      return feature_flags[feature_index / 32][feature_index % 32].is_set();
   };

   // These flags and bit fields are documented in the EAX=1 table at
   // https://en.wikipedia.org/wiki/CPUID
   // As well as in the file:
   // `llvm-project/compiler-rt/lib/builtins/cpu_model/x86.c`.
   if (ecx_bits[0]) {
      enable_feature(sse3);
   }
   if (ecx_bits[1]) {
      enable_feature(pclmul);
   }
   if (ecx_bits[9]) {
      enable_feature(ssse3);
   }
   if (ecx_bits[12]) {
      enable_feature(fma);
   }
   if (ecx_bits[13]) {
      enable_feature(cmpxchg16_b);
   }
   if (ecx_bits[19]) {
      enable_feature(sse4_1);
   }
   if (ecx_bits[20]) {
      enable_feature(sse4_2);
   }
   if (ecx_bits[22]) {
      enable_feature(movbe);
   }
   if (ecx_bits[23]) {
      enable_feature(popcnt);
   }
   if (ecx_bits[25]) {
      enable_feature(aes);
   }
   if (ecx_bits[27]) {
      enable_feature(xsave);

      if (ecx_bits[28]) {
         // AVX is only safe to use if `xsave` exists, which kernels use to
         // preserve SIMD registers between context switches. Supposedly some
         // environments exist where AVX exists without `xsave` support, so
         // check it to be sure.
         enable_feature(avx);
      }
   }
   if (ecx_bits[29]) {
      enable_feature(f16_c);
   }

   if (max_extended_leaf >= 0x80000001u) {
      auto&& [_, _, ecx, _] = cpuid(0x80000001u);
      cat::bitset ecx_bits = cat::bitset<32>::from(ecx);

      if (ecx_bits[0]) {
         enable_feature(lahf_lm);
      }
      if (ecx_bits[5]) {
         enable_feature(lzcnt);
      }
      if (ecx_bits[6]) {
         enable_feature(sse4_a);
      }
      if (ecx_bits[8]) {
         enable_feature(prfchw);
      }
      if (ecx_bits[11]) {
         enable_feature(xop);
      }
      if (ecx_bits[15]) {
         enable_feature(lwp);
      }
      if (ecx_bits[16]) {
         enable_feature(fma4);
      }
      if (ecx_bits[21]) {
         enable_feature(tbm);
      }
      if (ecx_bits[29]) {
         enable_feature(lm);
      }
   }

   if (max_leaf >= 7u) {
      auto&& [max_subleaf, ebx, ecx, edx] = cpuid(7u);

      cat::bitset ebx_bits = cat::bitset<32u>::from(ebx);
      cat::bitset ecx_bits = cat::bitset<32u>::from(ecx);
      cat::bitset edx_bits = cat::bitset<32u>::from(edx);

      // Enable AVX2.
      if (ebx_bits[3]) {
         enable_feature(bmi);
      }
      if (ebx_bits[5]) {
         enable_feature(avx2);
      }
      if (ebx_bits[8]) {
         enable_feature(bmi2);
      }
      if (ebx_bits[16]) {
         enable_feature(avx512_f);
      }
      if (ebx_bits[17]) {
         enable_feature(avx512_dq);
      }
      if (ebx_bits[18]) {
         enable_feature(rdseed);
      }
      if (ebx_bits[19]) {
         enable_feature(adx);
      }
      if (ebx_bits[21]) {
         enable_feature(avx512_ifma);
      }
      if (ebx_bits[26]) {
         enable_feature(avx512_pf);
      }
      if (ebx_bits[27]) {
         enable_feature(avx512_er);
      }
      if (ebx_bits[28]) {
         enable_feature(avx512_cd);
      }
      if (ebx_bits[29]) {
         enable_feature(sha);
      }
      if (ebx_bits[30]) {
         enable_feature(avx512_bw);
      }
      if (ebx_bits[31]) {
         enable_feature(avx512_vl);
      }

      if (ecx_bits[1]) {
         enable_feature(avx512_vbmi);
      }
      if (ecx_bits[9]) {
         enable_feature(vaes);
      }

      if (edx_bits[22]) {
         enable_feature(amx_bf16);
      }
      if (edx_bits[23]) {
         enable_feature(amx_fp16);
      }
      if (edx_bits[24]) {
         enable_feature(amx_tile);
      }
      if (edx_bits[25]) {
         enable_feature(amx_int8);
      }

      // TODO: Query subleaf-1 features.
      // if (max_subleaf >= 1u) {
      //    auto&& [_, ebx, ecx, _] = cpuid(7u, 1u);
      // }
   }

   // The baseline X86-64 is already set by `default_cpu_features()`.
   if (has_feature(lahf_lm) && has_feature(cmpxchg16_b) && has_feature(popcnt)
       && has_feature(sse4_2)) {
      enable_feature(x86_64_v2);

      if (has_feature(avx2) && has_feature(bmi) && has_feature(bmi2)
          && has_feature(fma) && has_feature(f16_c) && has_feature(lzcnt)
          && has_feature(movbe)) {
         enable_feature(x86_64_v3);

         if (has_feature(avx512_bw) && has_feature(avx512_cd)
             && has_feature(avx512_dq) && has_feature(avx512_vl)) {
            enable_feature(x86_64_v4);
         }
      }
   }

   __cpu_model.m_cpu_features |= feature_flags[0];
   __cpu_features2[0] = feature_flags[1];
   // This is OR'd because it contains `x86_64_baseline` by default:
   __cpu_features2[1] |= feature_flags[2];
   __cpu_features2[2] = feature_flags[3];

   // Detecting processor and subtype requires special-casing Intel and AMD.
}

}  // namespace detail
}  // namespace x64
