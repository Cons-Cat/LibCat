// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

// i386 and x86-64 are little endian.
constexpr bool1 is_little_endian = true;
constexpr bool1 is_big_endian = !is_little_endian;

namespace cat {

auto invert_endianess(meta::Integral auto value) {
    if constexpr (sizeof(value) == 1) {
        return __builtin_bswap8(value);
    }
    if constexpr (sizeof(value) == 2) {
        return __builtin_bswap16(value);
    }
    if constexpr (sizeof(value) == 4) {
        return __builtin_bswap32(value);
    }
    if constexpr (sizeof(value) == 8) {
        return __builtin_bswap64(value);
    }
}

// `Byte` is a strongly-typed `struct` rather than an `enum class`, as in the
// STL, so that it can carry member functions.
// TODO: Add some member functions.
struct Byte {  // NOLINT
    unsigned char value;

    constexpr Byte() = default;

    constexpr Byte(auto input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    constexpr Byte(auto const& input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    template <typename T>
    constexpr Byte(T&& input)  // NOLINT
        requires(sizeof(input) == 1) {
        this->value = meta::forward<T>(input);
    }

    template <typename T>
    constexpr explicit operator T() requires(sizeof(T) == 1) {
        return meta::bit_cast<T>(value);
    }

    constexpr auto operator&(meta::Integral auto from) -> Byte {
        return this->value & from;
    }
    constexpr auto operator&=(meta::Integral auto from) -> Byte& {
        this->value = this->value & from;
        return *this;
    }

    constexpr auto operator|(meta::Integral auto from) -> Byte {
        return this->value | from;
    }
    constexpr auto operator|=(meta::Integral auto from) -> Byte& {
        this->value = this->value | from;
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto from) -> Byte {
        return this->value << from;
    }
    constexpr auto operator<<=(meta::Integral auto from) -> Byte& {
        this->value = this->value << from;
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto from) -> Byte {
        return this->value >> from;
    }
    constexpr auto operator>>=(meta::Integral auto from) -> Byte& {
        this->value = this->value >> from;
        return *this;
    }
};

}  // namespace cat

constexpr auto operator""_ki(unsigned long long const input) -> long {
    return static_cast<long>(1024 * input);
}

constexpr auto operator""_mi(unsigned long long const input) -> long {
    return static_cast<long>(1024 * 1024 * input);
}

constexpr auto operator""_gi(unsigned long long const input) -> long {
    return static_cast<long>(1024 * 1024 * 1024 * input);
}
