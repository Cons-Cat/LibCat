// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <type_traits>

// i386 and x86-64 are little endian.
constexpr bool1 is_little_endian = true;
constexpr bool1 is_big_endian = !is_little_endian;

namespace cat {

auto invert_endianess(meta::Integral auto value) {
    if constexpr (sizeof(value) == 1) {
        return __builtin_bswap8(value);
    }
    if constexpr (sizeof(value) == 2) {
        return __builtin_bswap16(value);
    }
    if constexpr (sizeof(value) == 4) {
        return __builtin_bswap32(value);
    }
    if constexpr (sizeof(value) == 8) {
        return __builtin_bswap64(value);
    }
}

// `Byte` is a strongly-typed `struct` rather than an `enum class`, as in the
// STL, so that it can carry member functions.
// TODO: Add some member functions.
struct Byte {  // NOLINT
    unsigned char value;

    constexpr Byte() = default;

    constexpr Byte(auto input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    constexpr Byte(auto const& input) requires(sizeof(input) == 1) {
        this->value = input;
    }

    template <typename T>
    constexpr Byte(T&& input)  // NOLINT
        requires(sizeof(input) == 1) {
        this->value = meta::forward<T>(input);
    }

    template <typename T>
    constexpr explicit operator T() requires(sizeof(T) == 1) {
        return meta::bit_cast<T>(value);
    }

    constexpr auto operator&(meta::Integral auto from) -> Byte {
        return this->value & from;
    }
    constexpr auto operator&=(meta::Integral auto from) -> Byte& {
        this->value = this->value & from;
        return *this;
    }

    constexpr auto operator|(meta::Integral auto from) -> Byte {
        return this->value | from;
    }
    constexpr auto operator|=(meta::Integral auto from) -> Byte& {
        this->value = this->value | from;
        return *this;
    }

    constexpr auto operator<<(meta::Integral auto from) -> Byte {
        return this->value << from;
    }
    constexpr auto operator<<=(meta::Integral auto from) -> Byte& {
        this->value = this->value << from;
        return *this;
    }

    constexpr auto operator>>(meta::Integral auto from) -> Byte {
        return this->value >> from;
    }
    constexpr auto operator>>=(meta::Integral auto from) -> Byte& {
        this->value = this->value >> from;
        return *this;
    }
};

// TODO: Support `volatile` qualified pointers.
// TODO: Aligned pointer types and alignment casts.
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4201.html

// Returns `true` if `value` is aligned to the `alignment` boundary.
constexpr auto is_aligned(intptr const& value, ssize const alignment) -> bool;

// Returns a value rounded up from `value` to the nearest `alignment` boundary.
constexpr auto align_up(intptr const& value, ssize const alignment) -> intptr;

// Returns a value rounded down from `value` to the nearest `alignment`
// boundary.
constexpr auto align_down(intptr const& value, ssize const alignment) -> intptr;

}  // namespace cat

constexpr auto operator""_ki(unsigned long long const input) -> long {
    return static_cast<long>(1024 * input);
}

constexpr auto operator""_ki(long double const input) -> long {
    return static_cast<long>(1024.f * input);
}

constexpr auto operator""_mi(unsigned long long const input) -> long {
    return static_cast<long>(1024 * 1024 * input);
}

constexpr auto operator""_mi(long double const input) -> long {
    return static_cast<long>(1024.f * 1024.f * input);
}

constexpr auto operator""_gi(unsigned long long const input) -> long {
    return static_cast<long>(1024 * 1024 * 1024 * input);
}

constexpr auto operator""_gi(long double const input) -> long {
    return static_cast<long>(1024.f * 1024.f * 1024.f * 1024.f * input);
}

#include "./implementations/align_down.tpp"
#include "./implementations/align_up.tpp"
#include "./implementations/is_aligned.tpp"
