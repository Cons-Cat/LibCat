// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <math>
#include <memory>
#include <type_list>
#include <type_traits>

namespace cat {

template <typename... Ts>
class Variant {
    static constexpr ssize size = cat::max(ssizeof<Ts>()...);
    static constexpr usize alignment = cat::max(alignof(Ts)...);

    using Storage = cat::AlignedStorage<size, alignment>;
    Storage storage;
    uint1 discriminant;

    template <typename T, ssize index>
    constexpr auto find_index_of_type() -> uint1 {
        using IndexType = typename ::meta::TypeList<Ts...>::template Get<index>;
        if constexpr (::meta::is_same<T, IndexType>) {
            return static_cast<uint1>(index);
        } else {
            static_assert(index >= 1, "No type in this list was found!");
            return find_index_of_type<T, index - 1>();
        }
    }
  public:
    static constexpr ssize variant_size = static_cast<ssize>(sizeof...(Ts));

    constexpr Variant() = default;

    // Consume anything that is a valid type.
    template <typename T>
    constexpr Variant(T input) {
        this->discriminant = this->type_index<T>();
        new (cat::addressof(storage)) T{input};
    };

    template <typename T>
    constexpr auto operator=(T const& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!::meta::is_trivially_destructible<T>) {
                this->value<T>().~T();
            }
            this->value<T>() = operand;
            this->discriminant = this->type_index<T>();
        }
        return *this;
    }

    template <typename T>
    constexpr auto operator=(T&& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!::meta::is_trivially_destructible<T>) {
                this->value<T>().~T();
            }
            this->value<T>() = ::meta::forward<T>(operand);
            this->discriminant = this->type_index<T>();
        }
        return *this;
    }

    template <typename T>
    constexpr auto value() -> T& {
        // TODO: Make this assert work.
        // Result(this->is_type<T>).assert();

        // This cast is safe when the precondition holds true.
        return *reinterpret_cast<T*>(&this->storage);
    }

    template <typename T>
    constexpr auto type_index() -> uint1 {
        return this->find_index_of_type<T, this->variant_size - 1>();
    }

    template <typename T>
    constexpr auto holds_alternative() -> bool1 {
        return this->discriminant == this->type_index<T>();
    }

    constexpr auto get_index() const -> uint1 {
        return this->discriminant;
    }
};

}  // namespace cat
