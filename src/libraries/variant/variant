// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <array>
#include <concepts>
#include <math>
#include <memory>
#include <type_list>
#include <type_traits>

namespace cat {

template <typename... Ts>
requires(::meta::TypeList<Ts...>::is_unique_list) class Variant {
    static constexpr ssize size = cat::max(ssizeof<Ts>()...);
    static constexpr unsigned alignment = cat::max(alignof(Ts)...);

    using Types = ::meta::TypeList<Ts...>;

    using Storage = cat::Array<char, size>;
    alignas(alignment) Storage storage;
    uint1 discriminant;

    template <typename T, ssize index>
    static consteval auto get_index_of_type() -> uint1 requires(index >= 0) {
        using IndexType = typename Types::template Get<index>;
        if constexpr (::meta::is_same<T, IndexType>) {
            return static_cast<uint1>(index);
        } else {
            return get_index_of_type<T, index - 1>();
        }
    }
  public:
    static constexpr ssize variant_size = static_cast<ssize>(sizeof...(Ts));

    constexpr Variant() = default;

    // Consume anything that is a valid type.
    template <typename T>
    constexpr Variant(T input) requires(Types::template has_type<T>) {
        new (cat::addressof(storage)) T{input};
        this->discriminant = this->index<T>();
    };

    template <typename T>
    constexpr auto operator=(T const& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!::meta::is_trivially_destructible<T>) {
                this->value<T>().~T();
            }
            this->value<T>() = operand;
            this->discriminant = this->index<T>();
        }
        return *this;
    }

    template <typename T>
    constexpr auto operator=(T&& operand) -> Variant<Ts...>& {
        if (!this->holds_alternative<T>()) {
            if constexpr (!::meta::is_trivially_destructible<T>) {
                this->value<T>().~T();
            }
            this->value<T>() = ::meta::forward<T>(operand);
            this->discriminant = this->index<T>();
        }
        return *this;
    }

    template <typename T>
    constexpr auto value() -> T& requires(Types::template has_type<T>) {
        // TODO: Make this assert work.
        // Result(this->is_type<T>).assert();

        // This cast is safe when the precondition holds true.
        return *reinterpret_cast<T*>(&this->storage);
    }

    template <typename T>
    constexpr auto value() const
        -> T const& requires(Types::template has_type<T>) {
        // TODO: Make this assert work.
        // Result(this->is_type<T>).assert();

        // This cast is safe when the precondition holds true.
        return *reinterpret_cast<T const* const>(&this->storage);
    }

    template <typename T>
    static consteval auto index() -> uint1
        requires(Types::template has_type<T>) {
        return get_index_of_type<T, variant_size - 1>();
    }

    template <typename T>
    constexpr auto holds_alternative() -> bool1
        requires(Types::template has_type<T>) {
        return this->discriminant == this->index<T>();
    }

    template <typename T>
    constexpr auto holds_alternative() const -> bool1
        requires(Types::template has_type<T>) {
        return this->discriminant == this->index<T>();
    }

    constexpr auto get_index() const -> uint1 {
        return this->discriminant;
    }
};

}  // namespace cat
