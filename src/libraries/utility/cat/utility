// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/meta>

namespace cat {

// TODO: See if moving this into `std::` improves debuggability without breaking
// anything.
template <typename T>
constexpr auto bit_cast(auto& from_value) -> T;

template <typename T>
constexpr auto unconst(T const& value) -> T& {
    return const_cast<T&>(value);
}

template <typename T>
constexpr auto unconst(T const* p_value) -> T* {
    return const_cast<T*>(p_value);
}

constexpr auto is_constant_evaluated() -> cat::bool1;

constexpr auto ssizeof(auto const& anything) -> ssize;

template <typename T>
constexpr auto ssizeof() -> ssize;

namespace detail {
    template <typename T, ssize index, ssize current, T value, T... integers>
    constexpr auto get_integer_list_at() -> T {
        if constexpr (current == index) {
            return value;
        } else {
            return get_integer_list_at<T, index, current + 1, integers...>();
        }
    }
}  // namespace detail

template <typename T, T... integers>
requires(is_integral<T>) struct IntegerList {
    using value_type = T;

    static constexpr ssize size = ssize{sizeof...(integers)};

    template <ssize index>
    static constexpr auto get() -> T {
        return detail::get_integer_list_at<T, index, 0, integers...>();
    }
};

namespace detail {
    template <ssize count, typename T, T value, T... integers>
    constexpr auto make_integer_list() {
        if constexpr (count > 0) {
            // Recurse, appending `value` to `integers`.
            return make_integer_list<count - 1, T, value, value, integers...>();
        } else {
            return IntegerList<T, integers...>();
        }
    }

    template <ssize count, typename T, T value, T... integers>
    constexpr auto make_integer_sequence() {
        if constexpr (count > 0) {
            // Recurse, appending `count - 1` to `integers`.
            return make_integer_sequence<count - 1, T, T{count.c() - 1},
                                         T{count.c() - 1}, integers...>();
        } else {
            return IntegerList<T, integers...>();
        }
    }
}  // namespace detail

template <typename T, T value, ssize count>
constexpr auto integer_list = detail::make_integer_list<count, T, value>();

template <typename T, T value, ssize count>
using MakeIntegerList = decltype(integer_list<T, value, count>);

template <typename T, ssize count>
constexpr auto integer_sequence =
    detail::make_integer_sequence<count, T, T{count.c()}>();

template <typename T, ssize count>
using MakeIntegerSequence = decltype(integer_sequence<ssize, count>);

template <ssize... indices>
using IndexList = IntegerList<ssize, indices...>;

template <ssize value, ssize count>
constexpr auto index_list = integer_list<ssize, value, count>;

template <ssize value, ssize count>
using MakeIndexList = MakeIntegerList<ssize, value, count>;

template <ssize count>
constexpr auto index_sequence = integer_sequence<ssize, count>;

template <ssize count>
using MakeIndexSequence = MakeIntegerSequence<ssize, count>;

template <typename... Ts>
using IndexSequenceFor = MakeIndexSequence<ssize{sizeof...(Ts)}>;

}  // namespace cat

using cat::ssizeof;

// These symbols must be declared in `std::` to enable some useful GCC
// features, such as move-semantics warnings, and preventing GDB from stepping
// into the functions.
namespace std {

// NOLINTBEGIN(readability-redundant-declaration)
// The following functions are forward-declared in `<cat/meta>`, but they
// belong to the `<cat/utility>` library.

template <typename T>
constexpr auto forward(cat::RemoveReference<T>& input) -> T&&;

template <typename T>
constexpr auto forward(typename cat::RemoveReferenceTrait<T>::type&& input)
    -> T&& requires(!cat::is_lvalue_reference<T>);

template <typename T>
constexpr auto move(T&& input) -> cat::RemoveReference<T>&&;

// NOLINTEND(readability-redundant-declaration)

}  // namespace std

// `forward()` and `move()` should be usable from within a libCat namespace.
// This apparently does not prevent the aformentioned GCC features from working.
namespace cat {
using std::forward;
}  // namespace cat
namespace cat {
using std::move;
}  // namespace cat

#include "./implementations/bit_cast.tpp"
#include "./implementations/forward.tpp"
#include "./implementations/is_constant_evaluated.tpp"
#include "./implementations/move.tpp"
#include "./implementations/ssizeof.tpp"
