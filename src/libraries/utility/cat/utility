// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <cat/meta>

namespace cat {

template <typename T>
constexpr auto bit_cast(auto& from_value) -> T;

template <typename T>
constexpr auto unconst(T const& value) -> T& {
    return const_cast<T&>(value);
}

template <typename T>
constexpr auto unconst(T const* p_value) -> T* {
    return const_cast<T*>(p_value);
}

constexpr auto is_constant_evaluated() -> cat::bool1;

constexpr auto ssizeof(auto const& anything) -> ssize;

template <typename T>
constexpr auto ssizeof() -> ssize;

}  // namespace cat

using cat::ssizeof;

// These symbols must be declared in `std::` to enable some useful GCC
// features, such as move-semantics warnings, and preventing GDB from stepping
// into the functions.
namespace std {

// NOLINTBEGIN(readability-redundant-declaration)
// The following functions are forward-declared in `<cat/cat>`, but they
// belong to the `<cat/utility>` library.

template <typename T>
constexpr auto forward(cat::RemoveReference<T>& input) -> T&&;

template <typename T>
constexpr auto forward(typename cat::RemoveReferenceTrait<T>::type&& input)
    -> T&& requires(!cat::is_lvalue_reference<T>);

template <typename T>
constexpr auto move(T&& input) -> cat::RemoveReference<T>&&;

// NOLINTEND(readability-redundant-declaration)

}  // namespace std

// `forward()` and `move()` should be usable from within a libCat namespace.
// This apparently does not prevent the aformentioned GCC features from working.
namespace cat {
using std::forward;
}  // namespace cat
namespace cat {
using std::move;
}  // namespace cat

#include "./implementations/bit_cast.tpp"
#include "./implementations/forward.tpp"
#include "./implementations/is_constant_evaluated.tpp"
#include "./implementations/move.tpp"
#include "./implementations/ssizeof.tpp"
