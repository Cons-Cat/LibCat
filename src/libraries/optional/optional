// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <concepts>
#include <memory>
#include <string>
#include <type_traits>
#include <utility>

// TODO: Support `Optional<void>`.

namespace cat::detail {

// A `NullOpt` is consumed by a `Optional` constructor to prevent initializing
// its `value` member.
struct NullOpt {};

// A `Monostate` represents a `Optional` that holds no `value`.
struct Monostate {};

}  // namespace cat::detail

inline constexpr cat::detail::NullOpt nullopt;

template <typename T, auto predicate, T sentinel>
struct Predicate {};

template <typename T, T sentinel>
using Sentinel = Predicate<T,
                           [](T const value) {
                               return value != sentinel;
                           },
                           sentinel>;

template <typename T>
class Optional;

template <typename T>
struct OptionalValueStorage {
    struct Dummy {};
    union {
        // `Dummy` is required so that `OptionalValueStorage` can be initialized
        // in a `constexpr` context, because a member `union` must have at least
        // one initialized field, and it should not be `value`. `Dummy` can be
        // default-initialized, so this is well-formed.
        Dummy dummy;
        T storage;
    };
    using Value = T;
    bool1 has_some = false;

    // Enable copy and move constructors iff `Optionalvaluestorage` supports
    // them.

    // If `T` is trivially copy-constructible, use this simple copy constructor.
    constexpr OptionalValueStorage(T const& in_value) requires(
        meta::is_trivially_copy_constructible<T>)
        : storage(in_value), has_some(true){};

    // If `T` is not trivially copy-constructible, then manually construct it
    // in-place.
    constexpr OptionalValueStorage(T const& in_value) requires(
        meta::is_copy_constructible<T> &&
        !meta::is_trivially_copy_constructible<T>) {
        this->construct(in_value);
    }

    // If `T` is not copy-constructible, delete this copy constructor.
    constexpr OptionalValueStorage(T const& in_value) requires(
        !meta::is_copy_constructible<T>) = delete;

    // If `T` is trivially move-constructible, use this simple move constructor.
    constexpr OptionalValueStorage(T&& in_value) requires(
        meta::is_trivially_move_constructible<T>)
        : storage(meta::forward<T>(in_value)), has_some(true){};

    // If `T` is not trivially move-constructible, then manually invoke
    // `cat::move` on it.
    OptionalValueStorage(T&& in_value) requires(
        meta::is_move_constructible<T> &&
        !meta::is_trivially_move_constructible<T>) {
        this->construct(meta::forward<T>(in_value));
        this->has_some = true;
    }

    // If `T` is not move-constructible, delete this move constructor.
    constexpr OptionalValueStorage(T&& in_value) requires(
        !meta::is_move_constructible<T>) = delete;

    // If other destructors are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.
    constexpr ~OptionalValueStorage() = default;

    // If `T` is not trivially destructible, then manually invoke its
    // destructor.
    constexpr ~OptionalValueStorage() requires(
        !meta::is_trivially_destructible<T>) {
        if constexpr (requires { this->storage.~T(); }) {
            if (this->has_some) {
                this->storage.~T();
                this->has_some = false;
            }
        }
    }

    constexpr OptionalValueStorage(cat::detail::NullOpt) : has_some(false){};

    // If other assignment operators are not conditionally specialized by their
    // `requires`, they should be `default` or deleted.

    // If `T` is trivially copy-assignable, then forward this value.
    auto operator=(T const& in_value) -> OptionalValueStorage& requires(
        meta::is_trivially_copy_assignable<T>) {
        this->storage = in_value;
        this->has_some = true;
        return *this;
    }

    // If `T` is non-trivially copy-assignable, then manually construct it
    // in-place.
    auto operator=(T const& in_value) -> OptionalValueStorage& requires(
        meta::is_copy_assignable<T> && !meta::is_trivially_copy_assignable<T>) {
        this->assign(in_value);
        return *this;
    }

    // If `T` is not copy-assignable, delete this assignment operator to prevent
    // ambiguous overload resolution.
    auto operator=(T const& in_value) -> OptionalValueStorage& requires(
        !meta::is_copy_assignable<T>) = delete;

    // If `T` is trivially move-assignable, then forward this value.
    auto operator=(T&& in_value) -> OptionalValueStorage& requires(
        meta::is_trivially_move_assignable<T>) {
        this->storage = meta::forward<T>(in_value);
        this->has_some = true;
        return *this;
    }

    // If `T` is non-trivially move-assignable, then manually invoke
    // `cat::move()` on it.
    constexpr auto operator=(T&& in_value) -> OptionalValueStorage& requires(
        meta::is_move_assignable<T> && !meta::is_trivially_move_assignable<T>) {
        this->assign(meta::forward<T>(in_value));
        return *this;
    }

    // If `T` is not move-assignable, delete this assignment operator to prevent
    // ambiguous overload resolution.
    auto operator=(T&& in_value) -> OptionalValueStorage& requires(
        !meta::is_move_assignable<T>) = delete;

    constexpr auto value() & -> T& {
        return this->storage;
    }
    constexpr auto value() const& -> T const& {
        return this->storage;
    }
    constexpr auto value() && -> T&& {
        return cat::move(this->storage);
    }
    constexpr auto value() const&& -> T&& {
        return cat::move(this->storage);
    }

    constexpr auto has_value() const -> bool1 {
        return has_some;
    }

    // Destroy the storage unconditionally.
    void hard_reset() {
        this->storage.~T();
        this->has_some = false;
    }

    // Construct an object at the address of the held `value`.
    template <typename... Args>
    void construct(Args&&... args) {
        new (cat::addressof(this->storage)) T(meta::forward<Args>(args)...);
        this->has_some = true;
    }

    // If this is assigned an `Optional` which wraps a type that can be
    // converted to `T` , then convert that `OptionalValueStorage` to this type
    // implicitly.
    template <typename OtherOptional>
    constexpr void assign(OtherOptional&& optional) requires(
        meta::is_convertible<typename OtherOptional::Value, T>) {
        if (this->has_value()) {
            if (optional.has_value()) {
                this->storage = optional.value();
            } else {
                // If the incoming `Optional` is empty, then empty this one.
                this->hard_reset();
            }
        } else {
            if (optional.has_value()) {
                this->construct(optional.value());
            }
            // If both `Optional`s are empty, nothing happens.
        }
    }
};

template <typename T>
struct OptionalReferenceStorage {
    using Value = meta::RemoveReference<T>;
    Value* p_value = nullptr;
  public:
    // TODO: Handle non-trivial constructors and assignment operators.

    constexpr OptionalReferenceStorage(Value& in_value) requires(
        meta::is_default_constructible<Value>)
        : p_value(cat::addressof(in_value)){};

    constexpr OptionalReferenceStorage(Value const& in_value)
        : p_value(cat::addressof(in_value)){};

    template <typename U>
    constexpr OptionalReferenceStorage(U&& in_value)
        : p_value(cat::addressof(meta::forward<U>(in_value))){};

    constexpr OptionalReferenceStorage(cat::detail::NullOpt)
        : p_value(nullptr){};

    // Rebind the reference if this is assigned a new value.
    constexpr auto operator=(Value& option) -> OptionalReferenceStorage& {
        this->p_value = cat::addressof(option);
        return *this;
    }

    constexpr auto operator=(Value const& option)
        -> OptionalReferenceStorage const& {
        this->p_value = cat::addressof(option);
        return *this;
    };

    constexpr auto value() & -> Value& {
        return *(this->p_value);
    }
    constexpr auto value() const& -> Value& {
        return *(this->p_value);
    }
    constexpr auto value() && -> Value&& {
        return *(cat::move(this->p_value));
    }
    constexpr auto value() const&& -> Value&& {
        return *(cat::move(this->p_value));
    }

    constexpr auto has_value() const -> bool1 {
        return this->p_value != nullptr;
    }

    // Destroy the storage unconditionally.
    void hard_reset() {
        this->p_value->~Value();
        this->p_value = nullptr;
    }

    // Construct an object at the address of the held `value`.
    template <typename... Args>
    void construct(Args&&... args) {
        Result(this->has_value()).assert();
        new (this->p_value) T(meta::forward<Args>(args)...);
    }

    // If this is assigned an `Optional` which wraps a type that can be
    // converted to `T` , then convert that `OptionalValueStorage` to this type
    // implicitly.
    template <typename OtherOptional>
    constexpr void assign(OtherOptional&& optional) requires(
        meta::is_convertible<typename OtherOptional::Value, T>) {
        if (this->has_value()) {
            if (optional.has_value()) {
                this->storage = optional.value();
            } else {
                // If the incoming `Optional` is empty, then empty this one.
                this->hard_reset();
            }
        } else {
            if (optional.has_value()) {
                this->construct(optional.value());
            }
            // If both `Optional`s are empty, nothing happens.
        }
    }
};

template <typename T>
class Optional {
    using Storage =
        meta::Conditional<meta::is_reference<T>, OptionalReferenceStorage<T>,
                          OptionalValueStorage<T>>;
    using Value = typename Storage::Value;
    Storage storage;
  public:
    // Default-initialization is not supported.
    Optional() = delete;

    // Forward all constructors to `storage`.

    // A reference type cannot be copy-constructed, but other types can.
    template <typename U>
    Optional(U const& input) requires(!meta::is_reference<T> &&
                                      meta::is_convertible<U, Value> &&
                                      meta::is_copy_constructible<Value>)
        : storage(input){};

    template <typename U>
    Optional(U const& input) requires(
        meta::is_reference<T>&& meta::is_convertible<U, Value>)
        : storage(input){};

    template <typename U>
    Optional(U&& input) requires(meta::is_convertible<U, Value>)
        : storage(meta::forward<U>(input)){};

    template <typename U>
    Optional(Optional<U> const& input) {
        this->storage.assign(input);
    }

    template <typename U>
    Optional(Optional<U>&& input) {
        this->storage.assign(meta::forward<Optional<U>>(input));
    }

    // Consuming `nullopt` is forwarded to `storage`.
    constexpr Optional(cat::detail::NullOpt) : storage(nullopt){};

    // Forward all assignment operators to `storage`, except when assigning
    // `nullopt`.
    template <typename U>
    auto operator=(U const& value) requires(meta::is_convertible<U, T>) {
        this->storage = static_cast<T>(value);
        return *this;
    }

    template <typename U>
    auto operator=(U&& value) requires(meta::is_convertible<U, T>) {
        this->storage = static_cast<T>(meta::forward<T>(value));
        return *this;
    }

    template <typename U>
    auto operator=(Optional<U> const& optional) requires(
        meta::is_convertible<U, T>) {
        this->storage.assign(optional);
        return *this;
    }

    template <typename U>
    auto operator=(Optional<U>&& optional) requires(
        meta::is_convertible<U, T>) {
        this->storage.assign(meta::forward<Optional<U>>(optional));
        return *this;
    }

    // Assigning `nullopt` destroys any value.
    auto operator=(cat::detail::NullOpt) {
        this->storage.hard_reset();
        return *this;
    }

    constexpr auto has_value() const -> bool1 {
        return this->storage.has_value();
    }

    // TODO: Support move semantics.

    // Get the held `value` unconditionally. If `has_value()` is `false`, this
    // data is undefined. If this method is used in `-O0`, it will panic in that
    // case, unless used in a `constexpr` context.
    constexpr auto value() -> T& {
        if (meta::is_constant_evaluated()) {
            return this->storage.value();
        }
#ifdef __OPTIMIZE__
        return this->storage.value();
#else
        if (this->storage.has_value()) [[likely]] {
            return this->storage.value();
        }
        _ = cat::print(
            "`.value()` was illegally called on a `Optional` which did not hold a \
value!\n");
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    constexpr auto value() const -> T const& {
        if (meta::is_constant_evaluated()) {
            return this->storage.value();
        }
#ifdef __OPTIMIZE__
        return this->storage.value();
#else
        if (this->storage.has_value()) [[likely]] {
            return this->storage.value();
        }
        _ = cat::print(
            "`.value()` was illegally called on a `Optional` which did not hold a \
value!\n");
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    // Reference types cannot be moved.
    constexpr auto value() -> T&& requires(!meta::is_reference<T>) {
        if (meta::is_constant_evaluated()) {
            return cat::move(this->storage.value());
        }
#ifdef __OPTIMIZE__
        return cat::move(this->storage.value());
#else
        if (this->storage.has_value()) [[likely]] {
            return cat::move(this->storage.value());
        }
        _ = cat::print(
            "`.value()` was illegally called on a `Optional` which did not hold a \
value!\n");
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    // Reference types cannot be moved.
    constexpr auto value() const -> T const&& requires(!meta::is_reference<T>) {
        if (meta::is_constant_evaluated()) {
            return cat::move(this->storage.value());
        }
#ifdef __OPTIMIZE__
        return cat::move(this->storage.value());
#else
        if (this->storage.has_value()) [[likely]] {
            return cat::move(this->storage.value());
        }
        _ = cat::print(
            "`.value()` was illegally called on a `Optional` which did not hold a \
value!\n");
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    // Get the value held by a non-`const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(Value const fallback) & -> T {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    // Get the value held by a `const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(Value const fallback) const& -> T {
        if (this->storage.has_value()) {
            return this->storage.value();
        }
        return fallback;
    }

    // Get the value held by a non-`const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(Value&& fallback) && -> T&& {
        if (this->storage.has_value()) {
            return cat::move(this->storage.value());
        }
        return cat::move(fallback);
    }

    // Get the value held by a `const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(Value&& fallback) const&& -> T&& {
        if (this->storage.has_value()) {
            return cat::move(this->storage.value());
        }
        return cat::move(fallback);
    }

    // Monadic methods:

    // TODO: Support callbacks for `.transform()` that return `void`.
    // TODO: Use a `meta::invocable` `concept`.

    // If this non-`const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) & {
        if (this->storage.has_value()) {
            return Optional<T>(
                meta::forward<Function>(callback)(this->storage.value()));
        }
        return *this;
    }

    // If this `const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function without side-effects. Otherwise, propagate an empty
    // `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const& {
        if (this->storage.has_value()) {
            return Optional<T>(
                meta::forward<Function>(callback(this->storage.value())));
        }
        return *this;
    }

    // If this non-`const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) && {
        if (this->storage.has_value()) {
            return Optional<T>(meta::forward<Function>(
                callback(cat::move(this->storage.value()))));
        }
        return *this;
    }

    // If this `const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function without side-effects. Otherwise, propagate an empty
    // `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const&& {
        if (this->storage.has_value()) {
            return Optional<T>(meta::forward<Function>(
                callback(cat::move(this->storage.value()))));
        }
        return *this;
    }

    // Invoke a callback on the value of a `const`-qualified `Optional` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) & {
        return this->has_value() ? Optional<T>(meta::forward<Function>(
                                       callback)(this->storage.value()))
                                 : *this;
    }

    // Invoke a callback on the value of a `const`-qualified `Optional` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const& {
        return this->has_value() ? Optional<T>(meta::forward<Function>(
                                       callback)(this->storage.value()))
                                 : *this;
    }

    // Invoke a callback on the value of a non-`const`-qualified `Optional` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) && {
        return this->has_value()
                   ? Optional<T>(meta::forward<Function>(callback)(
                         cat::move(this->storage.value())))
                   : cat::move(*this);
    }

    // Invoke a callback on the value of a `const`-qualified `Optional` and
    // propagate the result, if it holds a value.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const&& {
        return this->has_value()
                   ? Optional<T>(meta::forward<Function>(callback)(
                         cat::move(this->storage.value())))
                   : cat::move(*this);
    }

    // Invoke a callback iff a non-`const`-qualified `Optional` holds no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) & -> Optional<T> {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    // Invoke a callback iff a `const`-qualified `Optional` holds no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) const& -> Optional<T> {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    // Invoke a callback iff a non-`const`-qualified move-only `Optional` holds
    // no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) && -> Optional<T> {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return cat::move(*this);
    }

    // Invoke a callback iff a `const`-qualified move-only `Optional` holds no
    // value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) const&& -> Optional<T> {
        if (!this->storage.has_value()) {
            meta::forward<Function>(callback)();
        }
        return cat::move(*this);
    }

    // Construct the value in-place and destroy the held value iff it exists.
    template <typename... Args>
    auto emplace(Args&&... args) -> T& {
        *this = nullopt;
        this->storage.construct(meta::forward<Args>(args)...);
        return this->storage.value();
    }
};

template <typename T, auto predicate, T sentinel>
class Optional<Predicate<T, predicate, sentinel>> {
    T storage = sentinel;
  public:
    Optional() = delete;
    ~Optional() = default;

    template <typename U = T>
    constexpr Optional(U& value) requires(!predicate(sentinel) &&
                                          (meta::is_same<U, T> ||
                                           meta::is_convertible<U, T>))
        : storage(value){};

    template <typename U = T>
    constexpr Optional(U const& value) requires(!predicate(sentinel) &&
                                                (meta::is_same<U, T> ||
                                                 meta::is_convertible<U, T>))
        : storage(value){};

    template <typename U = T>
    constexpr Optional(U const&& value) requires(!predicate(sentinel) &&
                                                 (meta::is_same<U, T> ||
                                                  meta::is_convertible<U, T>))
        : storage(cat::move(value)){};

    template <typename U = T>
    constexpr Optional(U&& value) requires(!predicate(sentinel) &&
                                           (meta::is_same<U, T> ||
                                            meta::is_convertible<U, T>))
        : storage(meta::forward<U>(value)){};

    constexpr Optional(cat::detail::NullOpt) : storage(sentinel){};

    // Forward assignment operators to `storage`:
    constexpr auto operator=(auto& input) {
        this->storage = input;
        return *this;
    }

    constexpr auto operator=(auto const& input) {
        this->storage = input;
        return *this;
    }

    template <typename U>
    constexpr auto operator=(U&& input) {
        this->storage = meta::forward<U>(input);
        return *this;
    }

    // Specify the unusual `nullopt` assignment operator.
    constexpr auto operator=(cat::detail::NullOpt) {
        this->storage = sentinel;
        return *this;
    }

    // TODO: Support non-`const`-qualified `Optional` when `has_value()` is
    // impure.
    // TODO: Support move semantics.
    // Get the held `value` unconditionally. If `has_value()` is `false`, this
    // data is undefined. If this method is used in `-O0`, it will panic in that
    // case, unless used in a `constexpr` context.
    constexpr auto value() -> T const& {
        if (meta::is_constant_evaluated()) {
            return this->storage;
        }
#ifdef __OPTIMIZE__
        return this->storage;
#else
        if (this->has_value()) [[likely]] {
            return this->storage;
        }
        _ = cat::print(
            "`.value()` was illegally called on a `Optional` which did not hold a \
value!\n");
        cat::exit(1);
#endif
        __builtin_unreachable();
    }

    // Get the value held by a non-`const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(T const fallback) & -> T& {
        if (this->has_value()) {
            return this->storage;
        }
        return fallback;
    }

    // Get the value held by a `const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(T const fallback) const& -> T& {
        if (this->has_value()) {
            return this->storage;
        }
        return fallback;
    }

    // Get the value held by a non-`const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(T&& fallback) && -> T&& {
        if (this->has_value()) {
            return cat::move(this->storage);
        }
        return cat::move(fallback);
    }

    // Get the value held by a `const`-qualified `Optional`, or a fallback
    // value if it does not hold a value.
    constexpr auto value_or(T&& fallback) const&& -> T&& {
        if (this->has_value()) {
            return cat::move(this->storage);
        }
        return cat::move(fallback);
    }

    // Monadic methods:

    // TODO: Support callbacks for `.transform()` that return `void`.
    // TODO: Use a `meta::invocable` `concept`.

    // If this non-`const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) & {
        if (this->has_value()) {
            return Optional<Predicate<T, predicate, sentinel>>(
                meta::forward<Function>(callback)(this->storage));
        }
        return Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // If this `const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const& {
        if (this->has_value()) {
            return Optional<Predicate<T, predicate, sentinel>>(
                meta::forward<Function>(callback)(this->storage));
        }
        return Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // If this non-`const`-qualified `Optional` holds a value, transform it by a
    // non -`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) && {
        if (this->has_value()) {
            return Optional<Predicate<T, predicate, sentinel>>(
                meta::forward<Function>(callback)(cat::move(this->storage)));
        }
        return Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // If this `const`-qualified `Optional` holds a value, transform it by a
    // non-`void` function. Otherwise, propagate an empty `Optional`.
    template <typename Function>
    constexpr auto transform(Function&& callback) const&& {
        if (this->has_value()) {
            return Optional<Predicate<T, predicate, sentinel>>(
                meta::forward<Function>(callback)(cat::move(this->storage)));
        }
        return Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // Invoke a callback on the value of a non-`const`-qualified `Optional` that
    // potentially mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) & {
        return this->has_value()
                   ? Optional<Predicate<T, predicate, sentinel>>(
                         meta::forward<Function>(callback)(this->storage))
                   : Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // Invoke a callback on the value of a `const`-qualified `Optional`, and
    // propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const& {
        return this->has_value()
                   ? Optional<Predicate<T, predicate, sentinel>>(
                         meta::forward<Function>(callback)(this->storage))
                   : Optional<Predicate<T, predicate, sentinel>>(nullopt);
    }

    // Invoke a callback on the value of a non-`const`-qualified `Optional` that
    // potentially mutates global state, and propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) && {
        return cat::move(
            this->has_value()
                ? Optional<Predicate<T, predicate, sentinel>>(
                      meta::forward<Function>(callback)(this->storage))
                : Optional<Predicate<T, predicate, sentinel>>(nullopt));
    }

    // Invoke a callback on the value of a `const`-qualified `Optional`, and
    // propagate the result.
    template <typename Function>
    constexpr auto and_then(Function&& callback) const&& {
        return cat::move(
            this->has_value()
                ? Optional<Predicate<T, predicate, sentinel>>(
                      meta::forward<Function>(callback)(this->storage))
                : Optional<Predicate<T, predicate, sentinel>>(nullopt));
    }

    // Invoke a callback iff a non-`const`-qualified `Optional` holds no value,
    // then return the value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) & {
        if (!this->has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    // Invoke a callback iff a `const`-qualified `Optional` holds no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) const& {
        if (!this->has_value()) {
            meta::forward<Function>(callback)();
        }
        return *this;
    }

    // Invoke a callback iff a non-`const`-qualified move-only `Optional` holds
    // no value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) && {
        if (!this->has_value()) {
            meta::forward<Function>(callback)();
        }
        return cat::move(*this);
    }

    // Invoke a callback iff a `const`-qualified move-only `Optional` holds no
    // value.
    template <typename Function>
    constexpr auto or_else(Function&& callback) const&& {
        if (!this->has_value()) {
            meta::forward<Function>(callback)();
        }
        return cat::move(*this);
    }

    constexpr auto has_value() const -> bool1 {
        return predicate(this->storage);
    }
};

template <typename T>
Optional(T) -> Optional<T>;
