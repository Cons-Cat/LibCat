// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <array>
#include <linux>
#include <string>

// TODO: Socket `concept`.
// TODO: Socket types for sequenced packets.

// Basic Socket type that any other sockets must convert into.
struct Socket {
    uint2 family;
    char data[14];
};

enum class SocketType {
    stream = 1,
    data_gram = 2,
    raw = 3,
    reliable_data_gram = 4,
    sequenced_packet = 5,
    datagram_congestion_control = 6
};

template <int2 Family, SocketType Type, int4 Protocol>
struct SocketAttributes {
    int2 const family = Family;
    static constexpr SocketType type = Type;
    static constexpr int4 protocol = Protocol;
};

template <SocketType Type, int4 Protocol = 0>
struct SocketUnix {
    SocketAttributes<1, Type, Protocol> const attributes;
    Array<char, 108> path_name;
    nix::FileDescriptor descriptor;

    // TODO: Create flags that corresponds to the value of `Protocol`.

    // Using `SocketUnix(){};` instead of `SockeUnix() = default;` prevents a
    // false-positive clangd diagnostic here.
    SocketUnix(){};  // NOLINT
    SocketUnix(nix::FileDescriptor const in_descriptor) {
        this->descriptor = in_descriptor;
    }

    // Get the size of this struct, not considering the `FileDescriptor` that it
    // holds.
    auto get_size() -> ssize {
        return sizeof(attributes) + sizeof(path_name);
    }

    // Create and return a `Socket`.
    auto create() -> Result<> {
        return nix::create_socket(this->attributes.family,
                                  static_cast<int>(Type), Protocol);
    }

    // Connect a `Socket`.
    auto connect() -> Result<> {
        return nix::connect_socket(
            this->descriptor, this,
            sizeof(attributes) + cat::string_length(static_cast<char const*>(
                                     static_cast<void*>(&this->path_name))));
    }

    auto send_string(String const& message, int8 flags = 0,
                     Socket const* p_destination_socket = nullptr,
                     ssize const addr_length = 0) -> Result<> {
        return nix::send_buffer(this->descriptor, message.p_data(),
                                message.size(), flags, p_destination_socket,
                                addr_length);
    }

    auto send_struct(auto const& message_struct, int8 flags = 0,
                     Socket const* p_destination_socket = nullptr,
                     ssize const addr_length = 0) -> Result<> {
        return nix::send_buffer(this->descriptor, &message_struct,
                                sizeof(message_struct), flags,
                                p_destination_socket, addr_length);
    }

    auto bind() -> Result<> {
        return nix::bind_socket(this->descriptor, this, this->get_size());
    }

    auto listen(int8 const backlog) -> Result<> {
        return nix::listen_to_socket(this->descriptor, backlog);
    }

    auto accept(nix::FileDescriptor listening_socket,
                void const* p_socket = nullptr,
                ssize const* p_addr_len = nullptr) -> Result<> {
        return nix::accept_socket(listening_socket, p_socket, p_addr_len);
    }

    auto accept(SocketUnix<Type, Protocol> const& listening_socket,
                void const* p_socket = nullptr,
                ssize const* p_addr_len = nullptr) -> Result<> {
        return nix::accept_socket(listening_socket.descriptor, p_socket,
                                  p_addr_len);
    }

    auto recieve(void const* p_message_buffer, ssize const buffer_length,
                 Socket const* __restrict p_addr = nullptr,
                 ssize const* __restrict p_addr_length = nullptr)
        -> Result<ssize> {
        return nix::recieve_buffer(this->descriptor, p_message_buffer,
                                   buffer_length, p_addr, p_addr_length);
    }

    auto close() -> Result<> {
        return nix::close(this->descriptor);
    }
};
