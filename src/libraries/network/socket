// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <buffer>
#include <linux>

#include "linux_flags"

// TODO: Socket descriptor types for `SOCK_STREAM` and `SOCK_SEQPACKET`.

// Basic Socket type that any other sockets must convert into.
struct Socket {
    uint2 family;
    char data[14];
};

enum class SocketType
{
    stream = 1,
    data_gram = 2,
    raw = 3,
    reliable_data_gram = 4,
    sequenced_packet = 5,
    dccp = 6
};

template <int2 Family, SocketType Type, int4 Protocol>
struct SocketDescriptor {
    // static constexpr int2 family = Family;
    int2 family = Family;
    static constexpr SocketType type = Type;
    static constexpr int4 protocol = Protocol;
    FileDescriptor value;
};

template <SocketType Type, int4 Protocol = 0>
struct SocketLocal {
    SocketDescriptor<1, Type, Protocol> descriptor;
    // TODO: `path_name` should be some kind of span type.
    Buffer<char, 108> path_name;

    // TODO: Constructor for `FileDescriptor`.

    // Create and return a `Socket`.
    auto create() -> Result<> {
        Result<int8> result = nix::syscall3(
            41u, descriptor.family, descriptor.type, descriptor.protocol);
        if (result.is_okay) {
            this->descriptor.value = result.value;
        }
        return result;
    }

    // Connect a `Socket` to an address.
    auto connect() -> Result<> {
        return syscall3(
            42u, this->descriptor.value,
            // Because this holds no 2-byte `family` value at runtime, that must
            // be accounted for in the address of this socket.
            static_cast<char*>(static_cast<void*>(this)), sizeof(SocketLocal));
    }

    auto close() -> Result<> {
        return nix::close(this->descriptor.value);
    }
};
