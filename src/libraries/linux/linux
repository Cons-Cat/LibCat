// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <bit>
#include <concepts>
#include <string>
#include <utility>

struct Socket;

constexpr usize page_size = 4096_ki;

namespace nix {

enum class MemoryProtectionFlags : unsigned int {
    none = 0b000,     // Data cannot be accessed at all.
    read = 0b001,     // Data is readable.
    write = 0b010,    // Data is writable.
    execute = 0b100,  // Data can be executed.
};

enum class MemoryFlags : unsigned int {
    shared = 0b1,          // Writes change the underlying object.
    privately = 0b10,      // Writes only change the calling process.
    fixed = 0b10000,       // Map to precisely this address, rather than virtual
                           // memory. This may fail.
    anonymous = 0b100000,  // Not backed by a file descriptor.
    // TODO: Make binary/hexa format consistent.
    grows_down = 0x00100,    // Stack-like segment.
    denywrite = 0x00800,     // ETXTBSY.
    executable = 0x01000,    // Mark it as an executable.
    locked = 0x02000,        // Lock the mapping.
    no_reserve = 0x04000,    // Don't check for reservations.
    populate = 0x08000,      // Populate (prefault) pagetables.
    non_blocking = 0x10000,  // Do not block on IO.
    stack = 0x20000,         // Allocation is for a stack.
    hugetlb = 0x40000,       // Create huge page mapping.
    sync = 0x80000,          // Perform synchronous page faults for the mapping.
    fixed_noreplace = 0x100000,  // `MmapMemoryFlags::fixed` but do not unmap
                                 // underlying mapping.
};

struct Process;

// TODO: Enforce that `FileDescriptor` cannot be constructed with a negative
// value. This is an index into the kernel's file descriptor table.
struct FileDescriptor {
    int4 value;

    FileDescriptor() = default;
    FileDescriptor(int4 const input) {
        this->value = input;
    }
};

struct ProcessId {
    // Linux supports the better part of `8` cat::Byte process IDs on 64-bit
    // systems, but only up to `4` cat::Byte process IDs on 32-bit systems.
    ssize value;

    ProcessId() = default;
    ProcessId(int8 const input) {
        this->value = input;
    }
};

struct UserId {
    int4 value;

    UserId() = default;
    UserId(int4 const input) {
        this->value = input;
    }
};

struct GroupId {
    int4 value;

    GroupId() = default;
    GroupId(int4 const input) {
        this->value = input;
    }
};

enum class WaitId {
    all = 0,
    process_id = 1,
    process_group = 2,
    file_descriptor = 3
};

// TODO: Write comments for these, and simplifiy names.
// https://linux.die.net/man/2/clone
enum class CloneFlags : unsigned int {
    csignal = 0x000000ff,
    newtime = 0x00000080,
    virtual_memory = 0x00000100,
    file_system = 0x00000200,
    file_descriptor_table = 0x00000400,
    sighand = 0x00000800 | CloneFlags::virtual_memory,
    pid_fd = 0x00001000,
    ptrace = 0x00002000,
    vfork = 0x00004000,
    parent = 0x00008000,
    thread = 0x00010000 | CloneFlags::sighand,
    newns = 0x00020000,
    sysv_semaphore = 0x00040000,
    set_tls = 0x00080000,
    parent_set_tid = 0x00100000,
    child_clear_tid = 0x00200000,
    untraced = 0x00800000,
    child_set_tid = 0x01000000,
    newcgroup = 0x02000000,
    newuts = 0x04000000,
    newipc = 0x08000000,
    newuser = 0x10000000,
    newpid = 0x20000000,
    newnet = 0x40000000,
    io = 0x80000000,
};

enum class WaitOptionsFlags : long int {
    no_hang = 1,
    untraced = 2,
    stopped = 2,
    exited = 4,
    continued = 8,
    no_wait = 0x1000000,
    no_thread = 0x20000000,
    wait_all = 0x40000000,
    clone = 0x80000000,
};

enum class OpenMode {
    read_only = 00,
    write_only = 01,
    // This flag cannot be use on a FIFO.
    read_write = 02
};

enum class OpenFlags {
    // This will create a new file. If that file already exists, it is no-op
    // unless combined with `OpenFlags::exclusive`.
    create = 0100,
    // This flag can only be used in combination with `OpenFlags::create`. This
    // will make a syscall fail if the file already exists.
    exclusive = 0200,
    no_control_tty = 0400,
    truncate = 01000,
    append_file = 02000,
    nonblocking = 04000,
    // Write I/O operations on the `FileDescriptor` shall complete as defined by
    // synchronized I/O data integrity completion.
    dsync = 010000,
    sync = 04010000,
    read_sync = 04010000,
    directory = 0200000,
    nofollow = 0400000,
    // Close the `FileDescriptor` automatically when finished with this
    // operation.
    close_exec = 02000000,

    async = 020000,
    direct = 040000,
    largefile = 0100000,
    noatime = 01000000,
    path = 010000000,
    temporary_file = 020200000,
    // This flag is used by `open_file()` implicitly. It specifies that the
    // offset value is 8-bytes.
    large_file = 0100000,
};

}  // namespace nix

// Enable using these `enum class`es as bit-flags.
template <>
struct meta::EnumFlagTrait<nix::MemoryProtectionFlags> : meta::TrueTypeTrait {};
template <>
struct meta::EnumFlagTrait<nix::MemoryFlags> : meta::TrueTypeTrait {};
template <>
struct meta::EnumFlagTrait<nix::OpenFlags> : meta::TrueTypeTrait {};
template <>
struct meta::EnumFlagTrait<nix::CloneFlags> : meta::TrueTypeTrait {};
template <>
struct meta::EnumFlagTrait<nix::WaitOptionsFlags> : meta::TrueTypeTrait {};

namespace nix {

auto read(FileDescriptor const file_descriptor, char const* p_string_buffer,
          ssize const length) -> Result<ssize>;

auto write(FileDescriptor const file_descriptor, char const* p_string_buffer,
           ssize const length) -> Result<ssize>;

auto write(FileDescriptor const file_descriptor, String const& string)
    -> Result<ssize>;

auto open_file(char const* p_file_path, OpenMode file_mode,
               OpenFlags flags = OpenFlags{0}) -> Result<FileDescriptor>;

auto create_file(char const* p_file_path, nix::OpenMode file_mode)
    -> Result<FileDescriptor>;

auto close(FileDescriptor const file_descriptor) -> Result<>;

auto unlink(char const* p_path_name) -> Result<>;

auto map_memory(usize const beginning_address, usize const bytes_size,
                MemoryProtectionFlags const protections,
                MemoryFlags const flags, FileDescriptor const file_descriptor,
                ssize const pages_offset) -> Result<void*>;

auto unmap_memory(void const* const p_memory, ssize const length) -> Result<>;

struct Thread;

auto wait(ProcessId waiting_on_id, int4* p_status_output,
          WaitOptionsFlags options, void* p_resource_usage) -> Result<Any>;

// TODO: Separate this into separate functions for waiting on pid, gid, etc.
auto waitid(WaitId type, ProcessId id, WaitOptionsFlags options) -> Result<Any>;

struct CloneArguments;

// TODO: Make all syscalls inline assembly. It did not work, last I tried.
/* The source to these functions is contained in the ./detail/ subdirectory
 * at the path of this file. They are split into individual files, because
 * GCC cannot exclude compiling unused functions individually from within
 * one .s file. */
auto syscall0(int8 const) -> Result<Any>;
auto syscall1(int8 const, Any const) -> Result<Any>;
auto syscall2(int8 const, Any const, Any const) -> Result<Any>;
auto syscall3(int8 const, Any const, Any const, Any const) -> Result<Any>;
auto syscall4(int8 const, Any const, Any const, Any const, Any const)
    -> Result<Any>;
auto syscall5(int8 const, Any const, Any const, Any const, Any const, Any const)
    -> Result<Any>;
auto syscall6(int8 const, Any const, Any const, Any const, Any const, Any const,
              Any const) -> Result<Any>;

template <typename... Args>
auto syscall(int8 const call, Args const... parameters) -> Result<Any>
requires(sizeof...(Args) < 7);

// Create and return a `Socket`.
auto create_socket(int8 const protocol_family, int8 const type,
                   int8 const protocol) -> Result<FileDescriptor>;

// Create and return a `SocketLocal` (also known as Unix socket).
auto create_socket_local(int8 const type, int8 const protocol)
    -> Result<FileDescriptor>;

// Connect a `Socket` to an address.
auto connect_socket(FileDescriptor const socket_descriptor,
                    void const* p_socket, ssize socket_size) -> Result<>;

// Make a connection over a `Socket`. This returns a new socket which has
// been connected to. This new `Socket` is not in a listening state.
// TODO: Add flags for Linux syscall `288u`.
auto accept_socket(FileDescriptor const socket_descriptor,
                   void const* __restrict p_socket = nullptr,
                   ssize const* __restrict p_addr_len = nullptr)
    -> Result<FileDescriptor>;

auto recieve_buffer(FileDescriptor const socket_descriptor,
                    void const* p_message_buffer, ssize const buffer_length,
                    Socket const* __restrict p_addr = nullptr,
                    ssize const* __restrict p_addr_length = nullptr)
    -> Result<ssize>;

auto bind_socket(FileDescriptor const socket_descriptor, void const* p_socket,
                 ssize const p_addr_len) -> Result<>;

// Mark a socket as available to make connections with `accept()`.
auto listen_to_socket(FileDescriptor const socket_descriptor,
                      int8 const backlog) -> Result<>;

// Returns the number of characters sent to `destination_socket`.
auto send_buffer(FileDescriptor const socket_descriptor,
                 void const* p_message_buffer, ssize const buffer_length,
                 int8 const flags, Socket const* p_destination_socket = nullptr,
                 ssize const addr_length = 0) -> Result<ssize>;

struct Process {
    ProcessId id;
    void* p_stack;
    ssize stack_size;

    // TODO: Why tls not work?
    static constexpr CloneFlags default_flags =
        CloneFlags::virtual_memory | CloneFlags::file_system |
        CloneFlags::file_descriptor_table | CloneFlags::io |
        CloneFlags::parent_set_tid;

    Process() = default;
    Process(Process const&) = delete;
    // TODO: Add `meta::invocable` concept.
    auto create(auto& allocator, ssize const initial_stack_size,
                auto const& function, void* p_arguments_struct,
                CloneFlags const flags = default_flags) -> Result<> {
        this->stack_size = initial_stack_size;
        // Allocate a stack for this thread, and get an address to the top of
        // it.
        bool1 failed = false;
        auto memory = allocator.malloc(initial_stack_size)
                          .or_else([&]() {
                              failed = true;
                          })
                          .value();
        if (failed) {
            return Failure(1);
        }
        this->p_stack = &allocator.get(memory);

        // TODO: Use `intptr`.
        // We need the top because memory will be pushed to it downwards on
        //  x86-64.
        volatile void* p_stack_top =
            static_cast<char*>(this->p_stack) + this->stack_size;

        Any result;
        asm goto volatile(
            R"(sub $8, %%rsi
                    mov %[p_callback], 0(%%rsi)
                    mov %[p_args], 8(%%rsi)
                    syscall

                    # Branch if this is the parent process.
                    mov %%rax, %[result]
                    test %%rax, %%rax
                    jnz %l[parent_thread]

                    # Call the function pointer if this is the child process.
                    pop %%rax
                    pop %%rdi
                    call *%%rax)"
            : /* There are no outputs. */
            : "a"(56), "D"(flags), "S"(p_stack_top),
              "d"(&(this->id)), [p_callback] "r"(&function),
              [p_args] "r"(p_arguments_struct), [result] "r"(result)
            : "rcx", "r8", "r9", "r10", "r11", "memory", "cc"
            : parent_thread);

parent_thread:
        if (static_cast<int4>(result) < 0) {
            return Failure{result};
        }
        // `this->process_id` was initialized by the syscall.
        return okay;
    }

    auto wait() const -> Result<ProcessId> {
        Result<ProcessId> result =
            nix::waitid(WaitId::process_id, this->id,
                        WaitOptionsFlags::exited | WaitOptionsFlags::clone |
                            WaitOptionsFlags::no_wait);
        return result;
        // TODO: Free the stack memory.
    }
};

struct IoVector : Span<cat::Byte> {
    static constexpr ssize max_size = 1_ki;

    constexpr IoVector() = default;
    constexpr IoVector(IoVector&&) = default;

    // Construct from any reasonable pointer type.
    template <typename T>
    constexpr IoVector(T* p_in_data, ssize in_length)
        : Span<cat::Byte>(static_cast<cat::Byte*>(p_in_data), in_length){};

    // Construct from any reasonable pointer type.
    template <typename T>
    constexpr IoVector(T* p_start, T* p_end)
        : Span<cat::Byte>(static_cast<cat::Byte*>(p_start),
                          static_cast<cat::Byte*>(p_end) -
                              static_cast<cat::Byte*>(p_start)){};

    constexpr auto operator=(IoVector const& io_vector) {
        this->p_storage = io_vector.p_storage;
        this->length = io_vector.length;
    }

    constexpr auto operator=(IoVector&& io_vector) {
        this->p_storage = io_vector.p_storage;
        this->length = cat::move(io_vector).length;
    }
};

auto write_vector(FileDescriptor const file_descriptor,
                  Span<IoVector> const& vectors) -> Result<ssize>;

auto read_vector(FileDescriptor const file_descriptor,
                 Span<IoVector> const& vectors) -> Result<ssize>;

struct File {
    char x;
};

struct FileStatus {
    uint8 device_id;
    // The index node for this file.
    uint8 inode;
    usize hard_links_count;

    uint4 protections_mode;
    UserId user_id;
    GroupId groud_id;
  private:
    uint4 padding;  // NOLINT
  public:
    uint8 rdev;
    int8 file_size;
    ssize block_size;
    int8 blocks_count;

    using Timespec = struct {
        ssize seconds;
        ssize nanoseconds;
    };

    Timespec last_access_time;
    Timespec last_modification_time;
    Timespec creation_time;
  private:
    int4 unused[3];  // NOLINT
  public:
    auto is_regular() const -> bool1 {
        return (this->protections_mode & 0170000) == 0100000;
    }

    auto is_directory() const -> bool1 {
        return (this->protections_mode & 0170000) == 0040000;
    }

    auto is_character_device() const -> bool1 {
        return (this->protections_mode & 0170000) == 0020000;
    }

    auto is_block_device() const -> bool1 {
        return (this->protections_mode & 0170000) == 0060000;
    }

    auto is_fifo() const -> bool1 {
        return (this->protections_mode & 0170000) == 0010000;
    }

    auto is_symbolic_link() const -> bool1 {
        return (this->protections_mode & 0170000) == 0120000;
    }

    auto is_socket() const -> bool1 {
        return (this->protections_mode & 0170000) == 0140000;
    }
};

auto file_path_status(String const& file_path) -> Result<FileStatus>;

auto file_descriptor_status(FileDescriptor const file_descriptor)
    -> Result<FileStatus>;

}  // namespace nix

#include "./implementations/syscall.tpp"
