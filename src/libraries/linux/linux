// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <bit>
#include <concepts>
#include <linux_flags>
#include <string>
#include <utility>

struct Socket;

namespace nix {

constexpr usize page_size = 4096_ki;

// `read()` transmits a number of bytes into a file descriptor.
auto read(FileDescriptor const file_descriptor, char const* p_string_buffer,
          ssize const string_length) -> Result<ssize>;

// `write()` forwards its arguments to a failable stdout syscall. It returns
// the number of bytes that it wrote.
auto write(FileDescriptor const file_descriptor, char const* p_string_buffer,
           ssize const string_length) -> Result<ssize>;

// auto write(FileDescriptor const file_descriptor, StringView const string)
//     -> Result<isize>;

auto close(FileDescriptor const object) -> Result<>;

auto unlink(char const* path_name) -> Result<>;

auto mmap(usize beginning_address, usize bytes_size, usize protections,
          usize flags, FileDescriptor file_descriptor, usize pages_offset)
    -> Result<void*>;

auto munmap() -> Result<>;

struct Thread;

auto wait(ProcessId waiting_on_id, int4* p_status_output, int4 options,
          void* p_resource_usage) -> Result<Any>;

// TODO: Separate this into separate functions for waiting on pid, gid, etc.
auto waitid(WaitIdType type, ProcessId id, int8 options) -> Result<Any>;

struct CloneArguments;

// TODO: Make all syscalls inline assembly. It did not work, last I tried.
/* The source to these functions is contained in the ./detail/ subdirectory
 * at the path of this file. They are split into individual files, because
 * GCC cannot exclude compiling unused functions individually from within
 * one .s file. */
// TODO: All syscalls should return a `Result`.
auto syscall0(Any) -> Result<Any>;
auto syscall1(Any, Any) -> Result<Any>;
auto syscall2(Any, Any, Any) -> Result<Any>;
auto syscall3(Any, Any, Any, Any) -> Result<Any>;
auto syscall4(Any, Any, Any, Any, Any) -> Result<Any>;
auto syscall5(Any, Any, Any, Any, Any, Any) -> Result<Any>;
auto syscall6(Any call, Any arg1, Any arg2, Any arg3, Any arg4, Any args,
              Any arg6) -> Result<Any>;

template <typename ReturnType, typename... Args>
auto syscall(Any call, Args... parameters) -> Result<ReturnType>
requires(sizeof...(Args) < 7);

// Create and return a `Socket`.
auto create_socket(int8 const protocol_family, int8 const type,
                   int8 const protocol) -> Result<FileDescriptor>;

// Create and return a `SocketLocal` (also known as Unix socket).
auto create_socket_local(int8 const type, int8 const protocol)
    -> Result<FileDescriptor>;

// Connect a `Socket` to an address.
auto connect_socket(FileDescriptor const socket_descriptor,
                    void const* p_socket, ssize socket_size) -> Result<>;

// Make a connection over a `Socket`. This returns a new socket which has
// been connected to. This new `Socket` is not in a listening state.
// TODO: Add flags for Linux syscall `288u`.
auto accept_socket(FileDescriptor const socket_descriptor,
                   void const* __restrict p_socket = nullptr,
                   ssize const* __restrict p_addr_len = nullptr)
    -> Result<FileDescriptor>;

auto recieve_buffer(FileDescriptor const socket_descriptor,
                    void const* p_message_buffer, ssize const buffer_length,
                    Socket const* __restrict p_addr = nullptr,
                    ssize const* __restrict p_addr_length = nullptr)
    -> Result<ssize>;

auto bind_socket(FileDescriptor const socket_descriptor, void const* p_socket,
                 ssize const p_addr_len) -> Result<>;

// Mark a socket as available to make connections with `accept()`.
auto listen_to_socket(FileDescriptor const socket_descriptor,
                      int8 const backlog) -> Result<>;

// Returns the number of characters sent to `destination_socket`.
auto send_buffer(FileDescriptor const socket_descriptor,
                 void const* p_message_buffer, ssize const buffer_length,
                 int4 const flags, Socket const* p_destination_socket = nullptr,
                 ssize const addr_length = 0) -> Result<ssize>;

struct Process {
    ProcessId id;
    void* p_stack;
    ssize stack_size;

    // TODO: Why tls not work?
    static constexpr uint4 default_flags =
        CloneFlags::virtual_memory | CloneFlags::file_system |
        CloneFlags::file_descriptor_table | CloneFlags::io |
        CloneFlags::parent_set_tid;

    Process() = default;
    Process(Process const&) = delete;
    // TODO: Add a `meta::allocator` concept.
    // TODO: Add `meta::invocable` concept.
    auto create(auto& allocator, ssize const initial_stack_size,
                auto const& function, void* p_arguments_struct,
                uint4 const flags = default_flags) -> Result<> {
        this->stack_size = initial_stack_size;
        // Allocate a stack for this thread, and get an address to the top of
        // it.
        this->p_stack = allocator.malloc(initial_stack_size).or_is(nullptr);
        if (this->p_stack == nullptr) {
            return Failure(1);
        }

        // We need the top because memory will be pushed to it downwards on
        //  x86-64.
        volatile void* p_stack_top =
            static_cast<char*>(this->p_stack) + this->stack_size;

        Any result;
        asm goto volatile(
            R"(sub $8, %%rsi
                    mov %[p_callback], 0(%%rsi)
                    mov %[p_args], 8(%%rsi)
                    syscall

                    # Branch if this is the parent process.
                    mov %%rax, %[result]
                    test %%rax, %%rax
                    jnz %l[parent_thread]

                    # Call the function pointer if this is the child process.
                    pop %%rax
                    pop %%rdi
                    call *%%rax)"
            : /* There are no outputs. */
            : "a"(56), "D"(flags), "S"(p_stack_top),
              "d"(&(this->id)), [p_callback] "r"(&function),
              [p_args] "r"(p_arguments_struct), [result] "r"(result)
            : "rcx", "r8", "r9", "r10", "r11", "memory", "cc"
            : parent_thread);

parent_thread:
        if (static_cast<int4>(result) < 0) {
            return Failure(result);
        }
        // `this->process_id` was initialized by the syscall.
        return okay;
    }

    auto wait() const -> Result<ProcessId> {
        auto foo = nix::waitid(
            WaitIdType::process_id, this->id,
            WaitOptions::exited | WaitOptions::clone | WaitOptions::no_wait);
        return foo;
        // TODO: Free the stack memory.
    }
};

}  // namespace nix

#include "./implementations/syscall.tpp"
