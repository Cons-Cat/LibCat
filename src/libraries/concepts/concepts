// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

#include <any>
#include <type_traits>

// TODO: Remove usage of type_traits as much as possible.
namespace meta {

template <typename T, typename U>
concept SameAs = meta::is_same<T, U>;

template <typename T>
concept Integral = meta::is_integral<T>;

template <typename T>
concept SignedIntegral = Integral<T> && meta::is_signed<T>;

template <typename T>
concept UnsignedIntegral = Integral<T> && meta::is_unsigned<T>;

template <typename T>
concept FloatingPoint = !Integral<T> && meta::is_floating_point<T>;

template <typename T>
concept IntOrFloat = Integral<T> || FloatingPoint<T>;

template <typename T>
concept Pointer = meta::is_pointer<T>;

// TODO: meta::is_safe_integral<T> does not work.
template <typename T>
concept SafeIntegral = (!meta::is_integral<T>)&&(!meta::is_floating_point<T>);

// TODO: Support more string types.
// template <typename T>
// concept string =
//     (meta::is_same<meta::RemoveConst<meta::RemoveReference<T>>,
//                    char8_t const*> ||
//      meta::is_same<meta::RemoveConst<meta::RemoveReference<T>>, char
//      const*>);

template <typename Derived, typename Base>
concept DerivedFrom = meta::is_base_of<Base, Derived> &&
    meta::is_convertible<const volatile Derived*, const volatile Base*>;

template <typename From, typename To>
concept ConvertibleTo = meta::is_convertible<From, To> && requires {
    static_cast<To>(meta::declval<From>());
};

template <typename T, typename... Args>
concept ConstructibleFrom = meta::is_constructible<T, Args...>;

template <typename T>
concept MoveConstructible = ConstructibleFrom<T, T> && ConvertibleTo<T, T>;

template <typename T>
concept CopyConstructible =
    MoveConstructible<T> && ConstructibleFrom<T, T&> && ConvertibleTo<T&, T> &&
    ConstructibleFrom<T, T const&> && ConvertibleTo<T const&, T> &&
    ConstructibleFrom<T, T const> && ConvertibleTo<T const, T>;

/* boolean_testable is adapted from the exposition-only concept
   boolean-testable. This converts a type into `bool` rather than `bool1`
   because that simplifies compilation. */
namespace detail {
    template <typename T>
    concept BooleanTestableDetail = ConvertibleTo<T, bool>;
}

template <typename T>
concept BooleanTestable = detail::BooleanTestableDetail<T> && requires(T&& b) {
    { !forward<T>(b) } -> detail::BooleanTestableDetail;
};

/* boolean_testable is adapted from the exposition-only concept
   __WeaklyEqualityComparableWith. */
namespace detail {
    template <typename T, typename U>
    concept WeaklyEqualityComparableWithDetail = requires(
        meta::RemoveReference<T> const& t, meta::RemoveReference<U> const& u) {
        { t == u } -> BooleanTestableDetail;
        { t != u } -> BooleanTestableDetail;
        { u == t } -> BooleanTestableDetail;
        { u != t } -> BooleanTestableDetail;
    };
}  // namespace detail

template <typename T>
concept EqualityComparable = detail::WeaklyEqualityComparableWithDetail<T, T>;

template <typename T>
concept EnumClass = meta::is_scoped_enum<T>;

template <typename T, typename U>
concept NarrowConvertible = requires() {
    U({meta::declval<T>()});
};

template <typename Function, typename... Args>
concept Invocable = meta::is_invocable<Function, Args...>;

}  // namespace meta
