// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

// `Raii` wrappers are curiously-recurring-template-pattern types that cannot be
// copy-constructed. They must be moved to pass into functions. Their destructor
// will call an `raii()` method on the type they wrap iff that type has an
// `raii()` method.

template <typename T>
concept HasRaii = requires(T it) {
    it.raii();
};

template <typename T>
class Raii {
    T storage;
    bool1 owns_data = true;
  public:
    // Delete non-moving constructors.
    constexpr Raii(T) = delete;
    constexpr Raii(T const&) = delete;
    constexpr Raii(Raii<T> const&) = delete;

    // Allow default-construction and move-construction.
    constexpr Raii() : storage(T()){};
    constexpr Raii(Raii<T>&& raii) : storage(raii.get()) {
        raii.owns_data = false;
    };

    // Forward any possible constructor into `storage`.
    constexpr Raii(T&& t) : storage(meta::forward<T>(t)){};

    template <typename... Args>
    Raii(Args&&... args) : storage(meta::forward<Args>(args)...){};

    // Allow move-assignment.
    auto operator=(T&& t) -> Raii<T>& {
        this->owns_data = true;

        // Delete internal storage.
        if (this->owns_data) {
            if constexpr (HasRaii<T>) {
                this->storage.raii();
            }
            this->storage.~T();
        }

        this->storage = meta::forward<T>(t);
        return *this;
    }

    auto operator=(Raii<T>&& raii) -> Raii<T>& {
        raii.owns_data = false;
        this->owns_data = true;

        // Delete internal storage.
        if (this->owns_data) {
            if constexpr (HasRaii<T>) {
                this->storage.raii();
            }
            this->storage.~T();
        }

        this->storage = cat::move(raii).get();
        return *this;
    }

    auto operator=(auto anything) {
        this->storage = anything;
    }

    ~Raii() = default;
    // If `T` holds a `.raii()` method, it will be called before `T`'s
    // destructor if this object has not lost ownership of its data.
    ~Raii() requires(HasRaii<T>) {
        if (this->owns_data) {
            this->storage.raii();
        }
    }

    constexpr auto has_ownership() -> bool1 {
        return this->owns_data;
    }

    constexpr auto get() -> T& {
        this->owns_data = false;
        return this->storage;
    }
};
