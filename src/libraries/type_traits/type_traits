// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* Be warned, ye who trot here!
 * Here be arcane remnants of the dark arts.
 * Black magic befouls the lines between yon
 * copse, so lest your eyes be lead astray,
 * know that the incantations written yonder
 * hath driven many a pony to insanity.
 *
 * Enter at your peril! */

namespace meta {

namespace detail {
    template <typename T, typename U = T&&>
    auto declval(signed int) -> U;

    template <typename T>
    auto declval(signed long) -> T;
}  // namespace detail

template <typename T>
auto declval() -> decltype(detail::declval<T>(0));

template <typename T>
struct type_identity {
    using type = T;
};
template <typename T>
using type_identity_t = typename type_identity<T>::type;

template <typename...>
using void_t = void;

template <typename T>
struct add_cv {
    using type = const volatile T;
};

template <typename T>
using add_cv_t = typename add_cv<T>::type;

template <typename T>
struct add_const {
    using type = const T;
};

template <typename T>
using add_const_t = typename add_const<T>::type;

template <typename T>
struct add_volatile {
    using type = volatile T;
};

template <typename T>
using add_volatile_t = typename add_volatile<T>::type;

template <typename T>
struct remove_const {
    using type = T;
};
template <typename T>
using remove_const_t = typename remove_const<T>::type;

template <typename T>
struct remove_const<T const> {
    using type = T;
};

template <typename T>
struct remove_volatile {
    using type = T;
};
template <typename T>
struct remove_volatile<T volatile> {
    using type = T;
};

template <typename T>
struct remove_cv {
    using type = T;
};
template <typename T>
struct remove_cv<const T> {
    using type = T;
};
template <typename T>
struct remove_cv<volatile T> {
    using type = T;
};
template <typename T>
struct remove_cv<const volatile T> {
    using type = T;
};
template <typename T>
using remove_cv_t = typename remove_cv<T>::type;

template <typename T>
struct remove_reference {
    using type = T;
};
template <typename T>
struct remove_reference<T&> {
    using type = T;
};
template <typename T>
struct remove_reference<T&&> {
    using type = T;
};
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

template <typename T>
struct remove_cvref {
    using type = remove_cv<remove_reference<T>>;
};
template <typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

namespace detail {
    template <typename T>
    struct remove_pointer {
        using type = T;
    };
    template <typename T>
    struct remove_pointer<T*> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer<T* const> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer<T* volatile> {
        using type = T;
    };
    template <typename T>
    struct remove_pointer<T* const volatile> {
        using type = T;
    };
}  // namespace detail

template <typename T>
struct remove_pointer : meta::detail::remove_pointer<T> {};
template <typename T>
using remove_pointer_t = typename remove_pointer<T>::type;

/* integral_constant has no constructor, because a `*_v` suffix contributes less
 * noise than parentheses or curly braces. */
template <typename T, T Value>
struct integral_constant {
    static constexpr T value = Value;
    using type = integral_constant<T, Value>;
};

// clang-tidy falsely warns about this.
template <typename T, T Value>                   // NOLINT
constexpr T integral_constant<T, Value>::value;  // NOLINT

template <bool Value>
using bool_constant = integral_constant<bool, Value>;

using true_type = bool_constant<true>;
constexpr bool true_type_v = true_type::value;

using false_type = bool_constant<false>;
constexpr bool false_type_v = false_type::value;

template <bool Condition, typename T, typename F>
struct conditional {
    using type = T;
};
template <typename T, typename F>
struct conditional<false, T, F> {
    using type = F;
};
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;

// `__is_enum()` is a GNU builtin.
template <typename T>
struct is_enum : public integral_constant<bool, __is_enum(T)> {};
template <typename T>
constexpr bool is_enum_v = is_enum<T>::value;
template <typename T>
using is_enum_t = typename is_enum<T>::type;

// `__is_same()` is a GNU builtin.
template <typename T, typename U>
struct is_same : bool_constant<__is_same(T, U)> {};
template <typename T, typename U>
using is_same_t = typename is_same<T, U>::type;
template <typename T, typename U>
constexpr bool is_same_v = is_same<T, U>::value;

// `__is_base_of()` is a GNU builtin.
template <typename T, typename U>
struct is_base_of : bool_constant<__is_base_of(T, U)> {};
template <typename T, typename U>
constexpr bool is_base_of_v = is_base_of<T, U>::value;
template <typename T, typename U>
using is_base_of_t = typename is_base_of<T, U>::type;

// `__is_union()` is a GNU builtin.
template <typename T>
struct is_union : public integral_constant<bool, __is_union(T)> {};

// `__is_class()` is a GNU builtin.
template <typename T>
struct is_class : public integral_constant<bool, __is_class(T)> {};

// `__is_literal_type()` is a GNU builtin.
template <typename T>
struct is_literal_type : public integral_constant<bool, __is_literal_type(T)> {
};
template <typename T>
constexpr bool is_literal_type_v = is_literal_type<T>::value;
template <typename T>
using is_literal_type_t = typename is_literal_type<T>::type;

template <typename T>
struct is_reference : false_type {};
template <typename T>
struct is_reference<T&> : true_type {};
template <typename T>
struct is_reference<T&&> : true_type {};

template <typename T>
constexpr bool is_reference_v = is_reference<T>::value;

namespace detail {
    // TODO: There has to be a more efficient way to exhaustively check
    // these.
    // template <typename>
    // struct is_safe_integral : false_type {};
    // template <>
    // struct is_safe_integral<i1> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<unsigned char>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<signed short>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<unsigned short>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<signed int>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<unsigned int>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<signed long>> : true_type {};
    // template <>
    // struct is_safe_integral<safe_integral_t<unsigned long>> : true_type {};
    // // TODO: This makes an error, and I'm not sure why:
    // // template <>
    // // struct is_safe_integral<i128> : true_type {};
    // // template <>
    // // struct is_safe_integral<u128> : true_type {};

    /* I tried using the fixed-width types initially, but some of the templates
     * would fail to resolve, for some reason. */
    template <typename>
    struct is_integral : false_type {};
    template <>
    struct is_integral<signed char> : true_type {};
    template <>
    struct is_integral<unsigned char> : true_type {};
    template <>
    struct is_integral<signed short> : true_type {};
    template <>
    struct is_integral<unsigned short> : true_type {};
    template <>
    struct is_integral<signed int> : true_type {};
    template <>
    struct is_integral<unsigned int> : true_type {};
    template <>
    struct is_integral<signed long> : true_type {};
    template <>
    struct is_integral<unsigned long> : true_type {};
    template <>
    struct is_integral<bool> : true_type {};
}  // namespace detail

// template <typename T>
// struct is_safe_integral : detail::is_safe_integral<remove_cv_t<T>> {};
// template <typename T>
// constexpr bool is_safe_integral_v = is_safe_integral<T>::value;
// template <typename T>
// using is_safe_integral_t = typename is_safe_integral<T>::type;

template <typename T>
struct is_integral : detail::is_integral<remove_cv_t<T>> {};
// TODO: `is_integral_v` does not work, and I am not sure why.
template <typename T>
constexpr bool is_integral_v = is_integral<T>::value;
template <typename T>
using is_integral_t = typename is_integral<T>::type;

template <typename T>
struct is_floating_point
    : bool_constant<is_same_v<float, remove_cv_t<T>> ||
                    is_same_v<double, remove_cv_t<T>> ||
                    is_same_v<long double, remove_cv_t<T>>> {};

template <typename T>
constexpr bool is_floating_point_v = is_floating_point<T>::value;
template <typename T>
using is_floating_point_t = typename is_floating_point<T>::type;

template <typename T>
struct is_arithmetic : conditional<is_integral_v<T>, is_integral<T>,
                                   is_floating_point<T>>::type {};

namespace detail {
    template <typename T, bool = is_arithmetic<T>::value>
    struct is_signed : bool_constant<T(-1) < T(0)> {};

    template <typename T>
    struct is_signed<T, false> : false_type {};
}  // namespace detail

template <typename T>
struct is_signed : detail::is_signed<T>::type {};
template <typename T>
constexpr bool is_signed_v = is_signed<T>::value;
template <typename T>
using is_signed_t = typename is_signed<T>::type;

namespace detail {
    template <typename T, bool = is_arithmetic<T>::value>
    struct is_unsigned : bool_constant<T(0) < T(-1)> {};
    template <typename T>
    struct is_unsigned<T, false> : false_type {};
}  // namespace detail

template <typename T>
struct is_unsigned : detail::is_unsigned<T>::type {};
template <typename T>
constexpr bool is_unsigned_v = is_unsigned<T>::value;
template <typename T>
using is_unsigned_t = typename is_unsigned<T>::type;

template <typename T>
struct is_void : is_same<void, typename remove_cv<T>::type> {};
template <typename T>
constexpr bool is_void_v = is_void<T>::value;

template <typename>
struct is_const : false_type {};
template <typename T>
struct is_const<T const> : true_type {};
template <typename T>
constexpr bool is_const_v = is_const<T>::value;
template <typename T>
using is_const_t = typename is_const<T>::type;

template <typename>
struct is_volatile : false_type {};
template <typename T>
struct is_volatile<T volatile> : true_type {};

namespace detail {
    template <typename T>
    struct is_pointer : false_type {};
    template <typename T>
    struct is_pointer<T*> : true_type {};
}  // namespace detail

template <typename T>
struct is_pointer : detail::is_pointer<T> {};
template <typename T>
constexpr bool is_pointer_v = is_pointer<T>::value;
template <typename T>
using is_pointer_t = typename is_pointer<T>::type;

template <typename>
struct is_array : false_type {};
template <typename T, int Size>
struct is_array<T[Size]> : true_type {};
template <typename T>
struct is_array<T[]> : true_type {};
template <typename T>
constexpr bool is_array_v = is_array<T>::value;
template <typename T>
using is_array_t = typename is_array<T>::type;

template <typename T>
struct remove_extent {
    using type = T;
};

template <typename T, int Size>
struct remove_extent<T[Size]> {
    using type = T;
};

template <typename T>
struct remove_extent<T[]> {
    using type = T;
};

template <typename T>
struct is_function : public bool_constant<!is_const<const T>::value> {};

template <typename T>
struct is_function<T&> : false_type {};

template <typename T>
struct is_function<T&&> : false_type {};

template <typename T, typename = void>
struct is_referenceable : false_type {};

template <typename T>
struct is_referenceable<T, void_t<T&>> : true_type {};

template <typename T>
struct is_member_pointer_helper : false_type {};

template <typename T, typename U>
struct is_member_pointer_helper<T U::*> : true_type {};

template <typename T>
struct is_member_pointer
    : is_member_pointer_helper<typename remove_cv<T>::type> {};

template <typename T>
constexpr bool is_member_pointer_v = is_member_pointer<T>::value;

template <typename T>
struct is_null_pointer : is_same<decltype(nullptr), remove_cv_t<T>> {};

template <typename T>
constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

template <typename T>
struct is_scalar
    : integral_constant<bool, is_arithmetic<T>::value || is_enum<T>::value ||
                                  is_pointer<T>::value ||
                                  is_member_pointer<T>::value ||
                                  is_null_pointer<T>::value> {};

template <typename T>
constexpr bool is_scalar_v = is_scalar<T>::value;

namespace detail {
    template <typename T,
              bool = conditional<is_referenceable<T>::value,
                                 is_referenceable<T>, is_void<T>>::value>
    struct add_pointer {
        using type = T;
    };

    template <typename T>
    struct add_pointer<T, true> {
        using type = remove_reference_t<T>*;
    };
}  // namespace detail

template <typename T>
struct add_pointer : detail::add_pointer<T> {};

namespace detail {
    template <typename T>
    auto add_lvalue_reference(int) -> type_identity<T&>;
    template <typename T>
    auto add_lvalue_reference(...) -> type_identity<T>;

    template <typename T>
    auto add_rvalue_reference(int) -> type_identity<T&&>;
    template <typename T>
    auto add_rvalue_reference(...) -> type_identity<T>;
}  // namespace detail

template <typename T>
struct add_lvalue_reference : decltype(detail::add_lvalue_reference<T>(0)) {};

template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template <typename T>
struct add_rvalue_reference : decltype(detail::add_rvalue_reference<T>(0)) {};

template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template <typename T>
struct decay {
  private:
    using U = typename remove_reference<T>::type;
  public:
    using type = typename conditional<
        is_array<U>::value, typename remove_extent<U>::type*,
        typename conditional<is_function<U>::value,
                             typename add_pointer<U>::type,
                             typename remove_cv<U>::type>::type>::type;
};
template <typename T>
using decay_t = typename decay<T>::type;

// `__underlying_type` is a GNU builtin.
template <typename T>
struct underlying_type {
    using type = __underlying_type(T);
};
template <typename T>
using underlying_type_t = typename underlying_type<T>::type;

namespace detail {
    template <typename T>
    auto returnable(int)
        -> decltype(void(static_cast<T (*)()>(nullptr)), meta::true_type{});
    template <typename>
    auto returnable(...) -> meta::false_type;

    template <typename From, typename To>
    auto implicitly_convertible(int)
        -> decltype(void(meta::declval<void (&)(To)>()(meta::declval<From>())),
                    meta::true_type{});
    template <typename, typename>
    auto implicitly_convertible(...) -> meta::false_type;

    template <typename From, typename To>
    struct is_convertible
        : meta::integral_constant<
              bool,
              (decltype(detail::returnable<To>(0))::value &&
               decltype(detail::implicitly_convertible<From, To>(0))::value) ||
                  (meta::is_void<From>::value && meta::is_void<To>::value)> {};
}  // namespace detail

template <typename From, typename To>
struct is_convertible : detail::is_convertible<From, To> {};
template <typename From, typename To>
using is_convertible_t = typename is_convertible<From, To>::type;
template <typename From, typename To>
constexpr bool is_convertible_v = is_convertible<From, To>::value;

template <typename...>
struct conjunction : meta::true_type {};
template <typename B1>
struct conjunction<B1> : B1 {};
template <typename B1, typename... Bn>
struct conjunction<B1, Bn...>
    : meta::conditional_t<bool(B1::value), conjunction<Bn...>, B1> {};

template <typename B1, typename... Bn>
using conjunction_t = typename conjunction<B1, Bn...>::type;
template <typename B1, typename... Bn>
constexpr bool conjunction_v = conjunction<B1, Bn...>::value;

namespace detail {
    template <typename T>
    auto sizable(int) -> decltype(sizeof(T), meta::true_type{});
    template <typename>
    auto sizable(...) -> meta::false_type;

    template <typename T>
    auto nonconvertible_to_int(int)
        -> decltype(static_cast<meta::false_type (*)(int)>(nullptr)(
            meta::declval<T>()));
    template <typename>
    auto nonconvertible_to_int(...) -> meta::true_type;

    template <typename T>
    constexpr bool is_scoped_enum =
        meta::conjunction_v<decltype(sizable<T>(0)),
                            decltype(nonconvertible_to_int<T>(0))>;
}  // namespace detail

template <typename>
struct is_scoped_enum : meta::false_type {};

template <typename T>
requires meta::is_enum_v<T>
struct is_scoped_enum<T> : meta::bool_constant<detail::is_scoped_enum<T>> {
};

template <typename T>
using is_scoped_enum_t = typename is_scoped_enum<T>::type;
template <typename T>
constexpr bool is_scoped_enum_v = is_scoped_enum<T>::value;

template <typename T>
struct is_object
    : meta::integral_constant<
          bool, meta::is_scalar<T>::value || meta::is_array<T>::value ||
                    meta::is_union<T>::value || meta::is_class<T>::value> {};

template <typename T>
constexpr bool is_object_v = is_object<T>::value;

template <typename>
struct is_lvalue_reference : false_type {};
template <typename T>
struct is_lvalue_reference<T&> : true_type {};
template <typename T>
constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
template <typename T>
using is_lvalue_reference_t = typename is_lvalue_reference<T>::type;

template <typename>
struct is_rvalue_reference : false_type {};
template <typename T>
struct is_rvalue_reference<T&&> : true_type {};
template <typename T>
constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
template <typename T>
using is_rvalue_reference_t = typename is_rvalue_reference<T>::type;

template <typename T, unsigned long = sizeof(T)>
constexpr auto is_complete_or_unbounded(type_identity<T>) -> true_type {
    return {};
}

template <typename, unsigned = 0>
struct extent;

template <typename>
struct remove_all_extents;

template <typename T>
struct is_bounded_array : false_type {};

template <typename T, ssize N>
struct is_bounded_array<T[N]> : true_type {};

template <typename T>
constexpr bool is_bounded_array_v = is_bounded_array<T>::value;

namespace detail {
    // `__is_constructible` is a GNU builtin.
    template <typename T, typename... Args>
    struct is_constructible : bool_constant<__is_constructible(T, Args...)> {};
}  // namespace detail

template <typename T, typename... Args>
struct is_constructible : detail::is_constructible<T, Args...> {
    static_assert(is_complete_or_unbounded(type_identity<T>{}));
};
template <typename T, typename... Args>
constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
template <typename T, typename... Args>
using is_constructible_t = typename is_constructible<T, Args...>::type;

// `__is_trivially_constructible` is a GNU builtin.
template <typename T, typename... Args>
struct is_trivially_constructible
    : public bool_constant<__is_trivially_constructible(T, Args...)> {};
template <typename T, typename... Args>
constexpr bool is_trivially_constructible_v =
    is_trivially_constructible<T, Args...>::value;

template <typename T>
struct is_default_constructible : detail::is_constructible<T>::type {
    static_assert(is_complete_or_unbounded(type_identity<T>{}));
};
template <typename T, typename>
constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
template <typename T, typename>
using is_default_constructible_t = typename is_default_constructible<T>::type;

template <typename T>
struct is_trivially_default_constructible
    : public bool_constant<is_trivially_constructible_v<T>> {};

template <typename T>
struct is_copy_constructible
    : meta::is_constructible<T, typename meta::add_lvalue_reference<
                                    typename meta::add_const<T>::type>::type> {
};
template <typename T>
constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;

template <typename T>
struct is_trivially_copy_constructible
    : meta::is_trivially_constructible<
          T, typename meta::add_lvalue_reference<
                 typename meta::add_const<T>::type>::type> {};
template <typename T>
constexpr bool is_trivially_copy_constructible_v =
    is_trivially_copy_constructible<T>::value;

namespace detail {
    struct try_destructor {
        template <typename T, typename = decltype(declval<T&>().~T())>
        static auto truth_value(int) -> meta::true_type;

        template <typename T>
        static auto truth_value(...) -> meta::false_type;
    };

    template <typename T>
    struct is_destructible : public try_destructor {
        using type = decltype(truth_value<T>(0));
    };

    template <typename T,
              bool = is_void_v<T> || !is_bounded_array_v<T> ||
                     is_function<T>::value,
              bool = is_reference_v<T> || is_scalar_v<T>>
    struct is_destructible_safe;

    template <typename T>
    struct is_destructible_safe<T, false, false>
        : public is_destructible<typename remove_all_extents<T>::type>::type {};

    template <typename T>
    struct is_destructible_safe<T, true, false> : public false_type {};

    template <typename T>
    struct is_destructible_safe<T, false, true> : public true_type {};
}  // namespace detail

template <typename T>
struct is_destructible : public detail::is_destructible_safe<T>::type {};

template <typename T>
constexpr bool is_destructible_v = is_destructible<T>::value;

// `__has_trivial_destructor()` is a GNU builtin.
template <typename T>
struct is_trivially_destructible
    : meta::integral_constant<bool, __has_trivial_destructor(T) &&
                                        meta::is_destructible<T>::value> {};

template <typename T>
constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<T>::value;

// https://stackoverflow.com/a/31763111
template <typename T, template <typename...> typename Template>
struct is_specialization : false_type {};

template <template <typename...> typename Template, typename... Args>
struct is_specialization<Template<Args...>, Template> : true_type {};

}  // namespace meta
