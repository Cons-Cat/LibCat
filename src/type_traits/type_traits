// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* Be warned, ye who trot here!
 * Here be arcane remnants of the dark arts.
 * Black magic befouls the lines between yon
 * copse, so lest your eyes be lead astray,
 * know that the incantations written yonder
 * hath driven many a pony to insanity.
 *
 * Enter at your peril! */

namespace std {

namespace detail {
    template <typename T, typename U = T&&>
    auto declval(i32) -> U;

    template <typename T>
    auto declval(i64) -> T;
}  // namespace detail

template <typename T>
auto declval() -> decltype(detail::declval<T>(0));

template <typename T>
struct type_identity {
    using type = T;
};
template <typename T>
using type_identity_t = typename type_identity<T>::type;

template <typename...>
using void_t = void;

template <typename T>
struct remove_const {
    using type = T;
};
template <typename T>
struct remove_const<T const> {
    using type = T;
};

template <typename T>
struct remove_volatile {
    using type = T;
};
template <typename T>
struct remove_volatile<T volatile> {
    using type = T;
};

template <typename T>
struct remove_cv {
    using type = T;
};
template <typename T>
struct remove_cv<T const> {
    using type = T;
};
template <typename T>
struct remove_cv<T volatile> {
    using type = T;
};
template <typename T>
struct remove_cv<T const volatile> {
    using type = T;
};
template <typename T>
using remove_cv_t = typename remove_cv<T>::type;

template <typename T>
struct remove_reference {
    using type = T;
};
template <typename T>
struct remove_reference<T&> {
    using type = T;
};
template <typename T>
struct remove_reference<T&&> {
    using type = T;
};
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

template <typename T>
struct remove_cvref {
    using type = remove_cv<remove_reference<T>>;
};

template <typename T, T Value>
struct integral_constant {
    static constexpr T value = Value;
    using value_type = T;
    using type = integral_constant<T, Value>;

    constexpr explicit operator value_type() const noexcept {
        return value;
    }
    constexpr auto operator()() const noexcept -> value_type {
        return value;
    }
};
template <typename T, T value>
constexpr T integral_constant<T, value>::value;

// __is_enum() is a GNU builtin.
template <typename T>
struct is_enum : public integral_constant<bool, __is_enum(T)> {};
template <typename T>
constexpr bool is_enum_v = is_enum<T>::value;
template <typename T>
using is_enum_t = typename is_enum<T>::type;

template <bool Value>
using bool_constant = integral_constant<bool, Value>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

// __is_same() is a GNU builtin.
template <typename T, typename U>
struct is_same : bool_constant<__is_same(T, U)> {};
template <typename T, typename U>
using is_same_t = typename is_same<T, U>::type;
template <typename T, typename U>
constexpr bool is_same_v = is_same<T, U>::value;

// __is_base_of() is a GNU builtin.
template <typename T, typename U>
struct is_base_of : bool_constant<__is_base_of(T, U)> {};
template <typename T, typename U>
constexpr bool is_base_of_v = is_base_of<T, U>::value;
template <typename T, typename U>
using is_base_of_t = typename is_base_of<T, U>::type;

// __is_union() is a GNU builtin.
template <typename T>
struct is_union : public integral_constant<bool, __is_union(T)> {};

// __is_class() is a GNU builtin.
template <typename T>
struct is_class : public integral_constant<bool, __is_class(T)> {};

/* is_literal_type was removed in C++17, but it was not replaced by a
 * better alternative. The standards committee decided it was generally
 * not useful, but I disagree. */
// __is_literal_type() is a GNU builtin.
template <typename T>
struct is_literal_type : public integral_constant<bool, __is_literal_type(T)> {
};
template <typename T>
constexpr bool is_literal_type_v = is_literal_type<T>::value;
template <typename T>
using is_literal_type_t = typename is_literal_type<T>::type;

namespace detail {
    // TODO: There has to be a more efficient way to exhaustively check
    // these.
    template <typename>
    struct is_integral : public false_type {};
    template <>
    struct is_integral<bool> : public true_type {};
    template <>
    struct is_integral<i8> : public true_type {};
    template <>
    struct is_integral<u8> : public true_type {};
    template <>
    struct is_integral<i16> : public true_type {};
    template <>
    struct is_integral<u16> : public true_type {};
    template <>
    struct is_integral<i32> : public true_type {};
    template <>
    struct is_integral<u32> : public true_type {};
    template <>
    struct is_integral<i64> : public true_type {};
    template <>
    struct is_integral<u64> : public true_type {};
}  // namespace detail

template <typename T>
struct is_integral : detail::is_integral<remove_cv_t<T>> {};
template <typename T>
constexpr bool is_integral_v = is_integral<T>::value;

template <typename T>
struct is_floating_point {
    static constexpr bool value = [] {
        return is_same<T, float>() || is_same<T, double>();
    };
};
template <typename T>
using is_floating_point_t = typename is_floating_point<T>::type;
template <typename T>
constexpr bool is_floating_point_v = is_floating_point<T>::value;

template <typename T>
struct is_arithmetic
    : integral_constant<bool,
                        is_integral<T>() || is_floating_point<T>()>::type {};

namespace detail {
    template <typename T, bool = is_arithmetic<T>::value>
    struct is_signed : integral_constant<bool, T(-1) < T(0)> {};

    template <typename T>
    struct is_signed<T, false> : false_type {};
}  // namespace detail

template <typename T>
struct is_signed : detail::is_signed<T>::type {};
template <typename T>
using is_signed_t = typename is_signed<T>::type;
template <typename T>
constexpr bool is_signed_v = is_signed<T>::value;

namespace detail {
    template <typename T, bool = is_arithmetic<T>::value>
    struct is_unsigned : integral_constant<bool, T(0) < T(-1)> {};
    template <typename T>
    struct is_unsigned<T, false> : false_type {};
}  // namespace detail

template <typename T>
struct is_unsigned : detail::is_unsigned<T>::type {};
template <typename T>
using is_unsigned_t = typename is_unsigned<T>::type;
template <typename T>
constexpr bool is_unsigned_v = is_unsigned<T>::value;

template <bool Condition, typename T, typename F>
struct conditional {
    using type = T;
};
template <typename T, typename F>
struct conditional<false, T, F> {
    using type = F;
};
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;

template <typename T>
struct is_void : is_same<void, typename remove_cv<T>::type> {};
template <typename T>
constexpr bool is_void_v = is_void<T>::value;

template <typename>
struct is_const : false_type {};
template <typename T>
struct is_const<T const> : true_type {};

template <typename>
struct is_volatile : false_type {};
template <typename T>
struct is_volatile<T volatile> : true_type {};

template <typename>
struct is_array : false_type {};

template <typename T, usize Size>
struct is_array<T[Size]> : true_type {};

template <typename T>
struct is_array<T[]> : true_type {};

template <typename T>
struct remove_extent {
    using type = T;
};

template <typename T, usize Size>
struct remove_extent<T[Size]> {
    using type = T;
};

template <typename T>
struct remove_extent<T[]> {
    using type = T;
};

template <typename T>
struct is_function : public bool_constant<!is_const<const T>::value> {};

template <typename T>
struct is_function<T&> : false_type {};

template <typename T>
struct is_function<T&&> : false_type {};

template <typename T, typename = void>
struct is_referenceable : false_type {};

template <typename T>
struct is_referenceable<T, void_t<T&>> : true_type {};

namespace detail {
    template <typename T,
              bool = conditional<is_referenceable<T>::value,
                                 is_referenceable<T>, is_void<T>>::value>
    struct add_pointer {
        using type = T;
    };

    template <typename T>
    struct add_pointer<T, true> {
        using type = remove_reference_t<T>*;
    };
}  // namespace detail

template <typename T>
struct add_pointer : detail::add_pointer<T> {};

template <typename T>
struct decay {
  private:
    using U = typename std::remove_reference<T>::type;

  public:
    using type = typename conditional<
        is_array<U>::value, typename remove_extent<U>::type*,
        typename conditional<is_function<U>::value,
                             typename add_pointer<U>::type,
                             typename std::remove_cv<U>::type>::type>::type;
};

template <typename T>
struct underlying_type {
    using type = __underlying_type(T);
};
template <typename T>
using underlying_type_t = typename underlying_type<T>::type;

namespace detail {
    template <
        typename From, typename To,
        bool = conditional<is_void<From>::value, is_void<From>,
                           conditional<is_function<To>::value, is_function<To>,
                                       is_array<To>>>::value>
    struct is_convertible {
        typedef typename is_void<To>::type type;
    };
}  // namespace detail

template <typename From, typename To>
struct is_convertible : detail::is_convertible<From, To>::type {};
template <typename From, typename To>
using is_convertible_t = typename is_convertible<From, To>::type;
template <typename From, typename To>
constexpr bool is_convertible_v = is_convertible<From, To>::value;

// is_scoped_enum is a C++23 type_trait.
namespace detail {
    template <typename T, bool = is_enum_v<T>>
    struct is_scoped_enum : false_type {};
    template <typename T>
    struct is_scoped_enum<T, true>
        : bool_constant<!is_convertible_v<T, underlying_type_t<T>>> {};
}  // namespace detail

template <typename T>
struct is_scoped_enum : detail::is_scoped_enum<T> {};
template <typename T>
constexpr bool is_scoped_enum_v = is_scoped_enum<T>::value;
template <typename T>
using is_scoped_enum_t = typename is_scoped_enum<T>::type;

template <typename>
struct is_lvalue_reference : false_type {};
template <typename T>
struct is_lvalue_reference<T&> : true_type {};
template <typename T>
constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
template <typename T>
using is_lvalue_reference_t = typename is_lvalue_reference<T>::type;

template <typename>
struct is_rvalue_reference : false_type {};
template <typename T>
struct is_rvalue_reference<T&&> : true_type {};
template <typename T>
constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
template <typename T>
using is_rvalue_reference_t = typename is_rvalue_reference<T>::type;

template <typename T, size_t = sizeof(T)>
constexpr auto is_complete_or_unbounded(type_identity<T>) -> true_type {
    return {};
}

namespace detail {
    template <typename T, typename... Args>
    struct is_constructible : bool_constant<__is_constructible(T, Args...)> {};
}  // namespace detail

/// is_constructible
template <typename T, typename... Args>
struct is_constructible : detail::is_constructible<T, Args...> {
    static_assert(std::is_complete_or_unbounded(type_identity<T>{}));
};
template <typename T, typename... Args>
constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
template <typename T, typename... Args>
using is_constructible_t = typename is_constructible<T, Args...>::type;

template <typename T>
struct is_default_constructible : detail::is_constructible<T>::type {
    static_assert(std::is_complete_or_unbounded(type_identity<T>{}));
};
template <typename T, typename>
constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
template <typename T, typename>
using is_default_constructible_t = typename is_default_constructible<T>::type;

}  // namespace std
