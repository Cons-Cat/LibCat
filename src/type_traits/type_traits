// -*- mode: c++;-*-
#pragma once

/* Be warned, ye who trot here!
 * Here be arcane remnants of the dark arts.
 * Black magic befouls the lines between yon
 * copse, so lest your eyes be lead astray,
 * know that the incantations written yonder
 * hath driven brilliant ponies to insanity.
 *
 * Enter at your peril! */

namespace std {

template <typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant<T, v>;

    constexpr explicit operator value_type() const noexcept {
        return value;
    }
    constexpr auto operator()() const noexcept -> value_type {
        return value;
    }
};

template <bool v>
using bool_constant = integral_constant<bool, v>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

// __is_same() is a GNU builtin.
template <class T, class U>
struct is_same : bool_constant<__is_same(T, U)> {};

// __is_base_of() is a GNU builtin.
template <typename T, typename U>
struct is_base_of : bool_constant<__is_base_of(T, U)> {};

// __is_literal_type() is a GNU builtin.
template <typename T>
struct is_literal_type : public integral_constant<bool, __is_literal_type(T)> {
};

template <typename T>
struct is_integral {
    static constexpr bool value =
        is_same<T, signed>() || is_same<T, unsigned>() || is_same<T, bool>();
    // TODO: This is non-exhaustive.
};

template <typename T>
struct is_floating_point {
    static constexpr bool value = [] {
        return is_same<T, float>() || is_same<T, double>();
    };
};

template <typename T>
struct is_arithmetic
    : integral_constant<bool,
                        is_integral<T>() || is_floating_point<T>()>::type {};

template <typename T, bool = is_arithmetic<T>::value>
struct is_signed : integral_constant<bool, T(-1) < T(0)> {};
template <typename T>
struct is_signed<T, false> : false_type {};

template <typename T, bool = is_arithmetic<T>::value>
struct is_unsigned : integral_constant<bool, T(0) < T(-1)> {};
template <typename T>
struct is_unsigned<T, false> : false_type {};

template <bool Condition, typename T, typename F>
struct conditional {
    using type = T;
};
template <typename T, typename F>
struct conditional<false, T, F> {
    using type = F;
};
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;

template <typename T>
struct type_identity {
    using type = T;
};

template <typename T>
struct remove_const {
    using type = T;
};
template <typename T>
struct remove_const<T const> {
    using type = T;
};

template <typename T>
struct remove_volatile {
    using type = T;
};
template <typename T>
struct remove_volatile<T volatile> {
    using type = T;
};

template <typename T>
struct remove_cv {
    using type = T;
};
template <typename T>
struct remove_cv<T const> {
    using type = T;
};
template <typename T>
struct remove_cv<T volatile> {
    using type = T;
};
template <typename T>
struct remove_cv<T const volatile> {
    using type = T;
};

template <typename T>
struct remove_reference {
    using type = T;
};
template <typename T>
struct remove_reference<T&> {
    using type = T;
};
template <typename T>
struct remove_reference<T&&> {
    using type = T;
};

template <typename T>
struct remove_cvref {
    using type = remove_cv<remove_reference<T>>;
};

template <typename T>
struct is_void : is_same<void, typename remove_cv<T>::type> {};
template <typename T>
constexpr bool is_void_v = is_void<T>::value;

template <typename>
struct is_const : public false_type {};
template <typename T>
struct is_const<T const> : public true_type {};

template <typename>
struct is_volatile : public false_type {};
template <typename T>
struct is_volatile<T volatile> : public true_type {};

template <typename>
struct is_array : public false_type {};

template <typename T, usize Size>
struct is_array<T[Size]> : public true_type {};

template <typename T>
struct is_array<T[]> : public true_type {};

template <typename T>
struct remove_extent {
    using type = T;
};

template <typename T, usize Size>
struct remove_extent<T[Size]> {
    using type = T;
};

template <typename T>
struct remove_extent<T[]> {
    using type = T;
};

template <typename T>
struct is_function : public bool_constant<!is_const<const T>::value> {};

template <typename T>
struct is_function<T&> : public false_type {};

template <typename T>
struct is_function<T&&> : public false_type {};

template <typename T>
auto add_pointer_helper(int)
    -> type_identity<typename remove_reference<T>::type*>;
template <typename T>
auto add_pointer_helper(...) -> type_identity<T>;
template <class T>
struct add_pointer : decltype(try_add_pointer<T>(0)) {};

template <typename T>
struct decay {
  private:
    using U = typename std::remove_reference<T>::type;

  public:
    using type = typename conditional<
        is_array<U>::value, typename remove_extent<U>::type*,
        typename conditional<is_function<U>::value,
                             typename add_pointer<U>::type,
                             typename std::remove_cv<U>::type>::type>::type;
};

}  // namespace std
