// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* legacy_types.hpp contains the numerical data types and constants that are
 * expected from an implementation of stdint.h. I am considering them deprecated
 * here, but they are supported because a substantial amout of C code that I
 * care about requires them.
 *
 * Those types and constants are available in both the global namespace as well
 * as the std:: namespace.
 */
#include <detail/legacy_types.hpp>

#include <concepts>
#include <type_traits>

namespace std::detail {

template <typename T>
struct SafeIntegral {
    T data;  // Unitialized by default.

    SafeIntegral() = default;
    // Any number that is smaller than this can safely cast into it.
    SafeIntegral(std::safe_integral auto from) requires(sizeof(from.data) <=
                                                        sizeof(T)) {
        data = from.data;
    }
    SafeIntegral(std::integral auto from) requires(
        std::is_signed_v<decltype(from)> == std::is_signed_v<T>) {
        data = from;
    }
    // TODO: Make a concept that limits signed-ness and size.
    operator std::integral auto() const {
        return data;
    };

    auto operator=(std::safe_integral auto from) -> SafeIntegral<T>& requires(
        (std::is_signed_v<decltype(from.data)> ==
         std::is_signed_v<T>)&&(sizeof(from.data) <= sizeof(T))) {
        data = from.data;
        return *this;
    }
    auto operator=(std::integral auto from)
        -> SafeIntegral<T>& requires(std::is_signed_v<decltype(from)> ==
                                     std::is_signed_v<T>) {
        data = from;
        return *this;
    }
};

}  // namespace std::detail

/* These must be type aliases, because derived structs cannot inherit operator
 * overloading. */
using i8 = std::detail::SafeIntegral<signed char>;
using u8 = std::detail::SafeIntegral<unsigned char>;
using i16 = std::detail::SafeIntegral<signed short>;
using u16 = std::detail::SafeIntegral<unsigned short>;
using i32 = std::detail::SafeIntegral<signed int>;
using u32 = std::detail::SafeIntegral<unsigned int>;
using i64 = std::detail::SafeIntegral<signed long>;
using u64 = std::detail::SafeIntegral<unsigned long>;
using i128 = std::detail::SafeIntegral<int128_t>;
using u128 = std::detail::SafeIntegral<uint128_t>;

using usize = size_t;
using isize = ssize_t;

// These are GCC built-in types:
// using f16 = _Float16;
using f32 = float;
using f64 = double;
using f128 = __float128;
using x128 = float __attribute__((mode(TC))) _Complex;

using bool8 = u8;
using bool16 = u16;
using bool32 = u32;

/* #include these here, so that the only -include build flag required is for
 * <cstdint>. */
#include <detail/simd.hpp>
#include <detail/vector_primitives.hpp>
