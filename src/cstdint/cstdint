// -*- mode: c++ -*-
// vim: set ft=cpp:
#pragma once

/* legacy_types.hpp contains the numerical data types and constants that are
 * expected from an implementation of stdint.h. I am considering them deprecated
 * here, but they are supported because a substantial amout of C code that I
 * care about requires them.
 *
 * Those types and constants are available in both the global namespace as well
 * as the std:: namespace.
 */
#include <detail/legacy_types.hpp>

#include <concepts>
#include <type_traits>

namespace std::detail {

template <typename T, typename U>
concept is_same_signedness = requires {
    std::is_signed_v<T> == std::is_signed_v<U>;
};

template <typename T, typename U>
concept fits_in_type = requires {
    sizeof(T) > sizeof(U);
};

template <typename T, typename U>
concept is_same_floatness = requires {
    std::is_floating_point_v<T> == std::is_floating_point_v<U>;
};

/* Get the value of a primitive number, or the value held by a
 * safe_integral_t<>. */
// template <typename T>
constexpr auto decay_integral(std::safe_integral auto from) {
    return from.data;
}
// template <typename T>
constexpr auto decay_integral(std::integral auto from) {
    return from;
}

/* safe_integral_t<> is the most interesting part of this library. LibCat uses
 * this one struct to represent all of its scalar numerical data types.
 * Operations between two specializations of a safe_integral_t<> that would
 * cause a narrowing conversion such as loss of precision, change in
 * signed-ness, or an implicit float to int conversion, *do not compile*, and
 * the code to ensure this is very simple compared to many other ways this could
 * be achieved.
 *
 * This works because all of its implicit conversion operators, arithmetic
 * operators, and constructors are generic with constraints. In other words,
 * these methods do not exist until they are actually called somewhere.
 *
 * At a method's call site, the compiler will attempt to find an overload of the
 * generic method that satisfies the inputs you provide it. Because these
 * methods are constrained by concepts and requires clauses, it is possible that
 * the compiler will fail to find any satisfying overload, and thus not compile.
 *
 * So, we can provide constraints such as "the operand must have a size that is
 * less than or equal to my own size", and this will guarantee that the compiler
 * cannot to generate a method that could cause a narrowing conversion between
 * an i64 and an i32 type. This is a concise solution, because that same
 * constraint broadly applies to all possible type conversions. */
template <typename T>
struct safe_integral_t {
    T data;  // Uninitialized by default.

    safe_integral_t() = default;
    // Any number that is smaller than this can safely cast into it.
    safe_integral_t(auto from) requires(
        is_same_signedness<T, decltype(decay_integral(from))>) {
        this->data = decay_integral(from);
    }
    // TODO: Make a concept that limits signed-ness and size.
    operator std::integral auto() const {
        return this->data;
    };

    auto operator=(auto from) -> safe_integral_t<T>& requires(
        (is_same_signedness<T, decltype(decay_integral(from))>)&&(
            fits_in_type<T, decltype(decay_integral(from))>)) {
        this->data = decay_integral(from);
        return *this;
    }
};

}  // namespace std::detail

/* These must be type aliases, because derived structs cannot inherit operator
 * overloading. */
using i8 = std::detail::safe_integral_t<signed char>;
using u8 = std::detail::safe_integral_t<unsigned char>;
using i16 = std::detail::safe_integral_t<signed short>;
using u16 = std::detail::safe_integral_t<unsigned short>;
using i32 = std::detail::safe_integral_t<signed int>;
using u32 = std::detail::safe_integral_t<unsigned int>;
using i64 = std::detail::safe_integral_t<signed long>;
using u64 = std::detail::safe_integral_t<unsigned long>;
using i128 = std::detail::safe_integral_t<int128_t>;
using u128 = std::detail::safe_integral_t<uint128_t>;

using usize = size_t;
using isize = ssize_t;

// These are GCC built-in types:
// using f16 = _Float16;
using f32 = float;
using f64 = double;
using f128 = __float128;
using x128 = float __attribute__((mode(TC))) _Complex;

using bool8 = u8;
using bool16 = u16;
using bool32 = u32;

/* #include these here, so that the only -include build flag required is for
 * <cstdint>. */
#include <detail/simd.hpp>
#include <detail/vector_primitives.hpp>
